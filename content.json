{"meta":{"title":"Melo's Blog","subtitle":"耐心的偏执狂，浪漫的现实主义","description":null,"author":"Melo","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2016-07-26T13:34:31.000Z","updated":"2016-07-26T13:34:31.410Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你足够了解Context吗？","slug":"你足够了解Context吗","date":"2016-07-27T13:29:52.585Z","updated":"2016-07-27T13:32:04.828Z","comments":true,"path":"2016/07/27/你足够了解Context吗/","link":"","permalink":"http://yoursite.com/2016/07/27/你足够了解Context吗/","excerpt":"你足够了解Context吗？这里有关于Context的一切 -写在前面： 当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。","text":"你足够了解Context吗？这里有关于Context的一切 -写在前面： 当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。 零：官方定义好吧如果你无法翻墙，推荐你两个可以看官网文档的网站： Android官方文档国内镜像站点 Android中文API 我们来看看官方文档中，Context的解释 Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. 一个应用环境的全局信息，字面意思是上下文的意思; Context是一个抽象类; 允许我们通过Context获取各种资源，服务，或者去启动一个Activity，发送一个广播，等等; 怎么去理解Context呢？其实Context就是给Android应用程序提供了一个可以实现各种操作的土壤环境，Context为Android提供了各种资源、功能、服务。如果说编写一个Android程序像搭建一座房子，那Context就为Android提供了土地，木材，和染料(启动一个Activity，弹出一个Dialog)，并且能提供呼叫各种将房屋建得更完善的其他帮助(发送一个广播，启动一个服务等)。 一：继承关系 通过继承关系可以看到，Context直接子类为ContextIml（实现类）和ContextWrapper（包装类） 再看看ContextWrapper的子类有什么，看到熟悉的Service和Application了吧，不过看到这里你一定有个疑问，为什么Activity和他们哥俩不在一个继承层级呢？而是Activity又继承了ContextThemeWrapper，那么ContextWrapper和ContextThemeWrapper的区别在哪里呢？ 看到这两个类的名字，相信你心里已经有了答案，对，区别在Theme。 该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。只有Activity需要主题，Service不需要主题， 所以Service直接继承于ContextWrapper类。而Activity因为含有Theme属性的缘故，所以继承自ContextThemeWrapper。 所以说，Context所调用的资源是不同的了？保留这个疑问，继续向下看。 二：源码阅读看到了继承结构，我们分别来看看Context及其子类的一些源码 Context 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public abstract class Context &#123; // 获取应用程序包的AssetManager实例 public abstract AssetManager getAssets(); // 获取应用程序包的Resources实例 public abstract Resources getResources(); // 获取PackageManager实例，以查看全局package信息 public abstract PackageManager getPackageManager(); // 获取应用程序包的ContentResolver实例 public abstract ContentResolver getContentResolver(); // 它返回当前进程的主线程的Looper，此线程分发调用给应用组件(activities, services等) public abstract Looper getMainLooper(); // 返回当前进程的单实例全局Application对象的Context public abstract Context getApplicationContext(); // 从string表中获取本地化的、格式化的字符序列 public final CharSequence getText(int resId) &#123; return getResources().getText(resId); &#125; // 从string表中获取本地化的字符串 public final String getString(int resId) &#123; return getResources().getString(resId); &#125; public final String getString(int resId, Object... formatArgs) &#123; return getResources().getString(resId, formatArgs); &#125; // 返回一个可用于获取包中类信息的class loader public abstract ClassLoader getClassLoader(); // 返回应用程序包名 public abstract String getPackageName(); // 返回应用程序信息 public abstract ApplicationInfo getApplicationInfo(); // 根据文件名获取SharedPreferences public abstract SharedPreferences getSharedPreferences(String name, int mode); // 其根目录为: Environment.getExternalStorageDirectory() public abstract File getExternalFilesDir(String type); // 返回应用程序obb文件路径 public abstract File getObbDir(); // 启动一个新的activity public abstract void startActivity(Intent intent); // 启动一个新的activity public void startActivityAsUser(Intent intent, UserHandle user) &#123; throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;); &#125; // 启动一个新的activity // intent: 将被启动的activity的描述信息 // options: 描述activity将如何被启动 public abstract void startActivity(Intent intent, Bundle options); // 启动多个新的activity public abstract void startActivities(Intent[] intents); // 启动多个新的activity public abstract void startActivities(Intent[] intents, Bundle options); // 广播一个intent给所有感兴趣的接收者，异步机制 public abstract void sendBroadcast(Intent intent); // 广播一个intent给所有感兴趣的接收者，异步机制 public abstract void sendBroadcast(Intent intent,String receiverPermission); public abstract void sendOrderedBroadcast(Intent intent,String receiverPermission); public abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras); public abstract void sendBroadcastAsUser(Intent intent, UserHandle user); public abstract void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission); // 注册一个BroadcastReceiver，且它将在主activity线程中运行 public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter); public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler); public abstract void unregisterReceiver(BroadcastReceiver receiver); // 请求启动一个application service public abstract ComponentName startService(Intent service); // 请求停止一个application service public abstract boolean stopService(Intent service); // 连接一个应用服务，它定义了application和service间的依赖关系 public abstract boolean bindService(Intent service, ServiceConnection conn, int flags); // 断开一个应用服务，当服务重新开始时，将不再接收到调用， // 且服务允许随时停止 public abstract void unbindService(ServiceConnection conn); public abstract Object getSystemService(String name); public abstract int checkPermission(String permission, int pid, int uid); // 返回一个新的与application name对应的Context对象 public abstract Context createPackageContext(String packageName, int flags) throws PackageManager.NameNotFoundException; // 返回基于当前Context对象的新对象，其资源与display相匹配 public abstract Context createDisplayContext(Display display); &#125; Context的源码算上注释有3000行之多，这里贴出一些重要代码，可以看到，Context几乎包含了所有你能想到的，一个Android程序需要的资源和操作，Context自己就像一个App一样，启动Activity、Service，发送Broadcast，拿到assets下的资源，获取SharedPreferences等等。 但Context只是一个顶层接口啊，又是谁帮他实现了操作呢？是ContextWrapper吗？ ContextWrapper 123456789101112131415161718192021222324252627282930313233public class ContextWrapper extends Context &#123; Context mBase; //该属性指向一个ContextIml实例 public ContextWrapper(Context base) &#123; mBase = base; &#125; /** * @param base The new base context for this wrapper. * 创建Application、Service、Activity，会调用该方法给mBase属性赋值 */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; @Override public Looper getMainLooper() &#123; return mBase.getMainLooper(); &#125; @Override public Object getSystemService(String name) &#123; return mBase.getSystemService(name); &#125; @Override public void startActivity(Intent intent) &#123; mBase.startActivity(intent); &#125;&#125; 好吧，ContextWrapper好像很懒的样子，它把所有操作都丢给了mBase，mBase又是谁呢？在构造方法和attachBaseContext方法中，指向了一个Context实例，ContextIml，我们赶紧来看看ContextIml的源码！ ContextImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */class ContextImpl extends Context &#123; private final static String TAG = &quot;ContextImpl&quot;; private final static boolean DEBUG = false; private static final HashMap&lt;String, SharedPreferencesImpl&gt; sSharedPrefs = new HashMap&lt;String, SharedPreferencesImpl&gt;(); /*package*/ LoadedApk mPackageInfo; // 关键数据成员 private String mBasePackageName; private Resources mResources; /*package*/ ActivityThread mMainThread; // 主线程 @Override public AssetManager getAssets() &#123; return getResources().getAssets(); &#125; @Override public Looper getMainLooper() &#123; return mMainThread.getLooper(); &#125; @Override public Object getSystemService(String name) &#123; ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity)null, intent, -1, options); &#125;&#125; 其实ContextImpl才是在Context的所有继承结构中唯一一个真正实现了Context中方法的类。其它Context的子类，Application，Activity，Service，都是与ContextImpl相关联，去获取资源和服务，并没有真正自己去实现，这里就不贴上ContextThemeWrapper的源码了，它是为Activity添加了一些Theme的属性，不再赘述。 思路越来越清晰，我们现在就是要去寻找，Activity，Service，Application是何时与ContextImpl完成绑定关联的。 三：关联时机我们都知道ActivityThread的main方法，是整个Android程序的入口，所以去探究ActivityThread类，也是一件非常重要的事。 推荐一篇文章，去了解下ActivityThread吧 ActivityThread简介 贴出ActivityThread的main方法部分重要的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public final class ActivityThread &#123; static ContextImpl mSystemContext = null; static IPackageManager sPackageManager; // 创建ApplicationThread实例，以接收AMS指令并执行 final ApplicationThread mAppThread = new ApplicationThread(); final Looper mLooper = Looper.myLooper(); final HashMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new HashMap&lt;IBinder, ActivityClientRecord&gt;(); final HashMap&lt;IBinder, Service&gt; mServices = new HashMap&lt;IBinder, Service&gt;(); final H mH = new H(); Application mInitialApplication; final ArrayList&lt;Application&gt; mAllApplications = new ArrayList&lt;Application&gt;(); static final ThreadLocal&lt;ActivityThread&gt; sThreadLocal = new ThreadLocal&lt;ActivityThread&gt;(); Instrumentation mInstrumentation; static Handler sMainThreadHandler; // set once in main() private class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what)); &#125; ... &#125; private class ApplicationThread extends ApplicationThreadNative &#123; private void updatePendingConfiguration(Configuration config) &#123; synchronized (mPackages) &#123; if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(config)) &#123; mPendingConfiguration = config; &#125; &#125; &#125; public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123; queueOrSendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0), configChanges); &#125; // we use token to identify this activity without having to send the // activity itself back to the activity manager. (matters more with ipc) public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward, String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profileFile = profileName; r.profileFd = profileFd; r.autoStopProfiler = autoStopProfiler; updatePendingConfiguration(curConfig); queueOrSendMessage(H.LAUNCH_ACTIVITY, r); &#125; ... &#125; public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; // 创建Activity对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case BIND_APPLICATION: // 创建Application对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: // 创建Service对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceCreate&quot;); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: // Bind Service对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; &#125; &#125; 也许你不能完全看懂、理解这些代码，不过没关系，直接告诉你结论吧，ActivityThread的一个内部类H，里面定义了activity、service等启动、销毁等事件的响应，也就是说activity、service的启动、销毁都是在ActivityThread中进行的。 当然了，一个Activity或者Service的从创建到启动是相当复杂的，其中还涉及的Binder机制等等原理，推荐给大家两篇博文，去慢慢研读消化吧。 Activity启动原理详解 Service启动原理分析 准备工作不知不觉就做了这么多，差点忘了正事，我们还是要继续寻找Application、Activity、Service是何时与ContextImpl进行关联的。 Application 123456789101112131415161718192021222324252627282930313233343536373839404142// ActivityThread.javaprivate void handleBindApplication(AppBindData data) &#123; try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125;// LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); ContextImpl appContext = new ContextImpl(); // 创建ContextImpl实例 appContext.init(this, null, mActivityThread); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); // 将Application实例传递给Context实例 &#125; catch (Exception e) &#123; ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; return app; &#125; 每个应用程序在第一次启动时，都会首先创建一个Application对象。从startActivity流程可知，创建Application的时机在handleBindApplication()方法中，该函数位于 ActivityThread.java类 Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity a = performLaunchActivity(r, customIntent); // 到下一步 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125; ... &#125;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); // 创建Context CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; ... &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 123456789101112131415161718192021222324private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ContextImpl appContext = new ContextImpl(); // 创建ContextImpl实例 appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); // For debugging purposes, if the activity&apos;s package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. Context baseContext = appContext; String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123; DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); for (int displayId : dm.getDisplayIds()) &#123; if (displayId != Display.DEFAULT_DISPLAY) &#123; Display display = dm.getRealDisplay(displayId); baseContext = appContext.createDisplayContext(display); break; &#125; &#125; &#125; return baseContext;&#125; 通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()，onStart()方法等，函数位于 ActivityThread.java类。 Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name); ContextImpl context = new ContextImpl(); // 创建ContextImpl实例 context.init(packageInfo, null, this); Application app = packageInfo.makeApplication(false, mInstrumentation); context.setOuterContext(service); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, 0, 0, 0); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to create service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125;&#125; 通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，完成相关数据操作。handleCreateService()函数位于 ActivityThread.java类 看到这里，相信你对Context的理解更进一步了，现在我们知道了Context是什么，它为Android提供了怎样的资源、功能、和服务，又在什么时候将Application、Activity、Service与ContextImpl相关联，但是所请求的资源是不是同一套资源呢？ 在这里你一定说：“当然不是，不同的Context对象明显是有区别的，用法也不同” 但是其实他们访问的，确确实实，是同一套资源。 三：Context资源详解来吧，看看不同Context对象的区别和用法的不同，参见以下表格。 这张表格是不是又支持了你的观点(也就是一直认为的，Context资源对象是不同的)，但是还是要再次强调一次，它们所请求的，确确实实是同一块资源，看看上面进行关联的源码，都走进了Context实现类的init方法，拨云见日，我们去看看init方法吧。 查看ContextImpl类源码可以看到，getResources方法直接返回内部的mResources变量 123456789101112131415161718192021final void init(LoadedApk packageInfo, IBinder activityToken, ActivityThread mainThread, Resources container) &#123; mPackageInfo = packageInfo; mResources = mPackageInfo.getResources(mainThread); if (mResources != null &amp;&amp; container != null &amp;&amp; container.getCompatibilityInfo().applicationScale != mResources.getCompatibilityInfo().applicationScale) &#123; if (DEBUG) &#123; Log.d(TAG, &quot;loaded context has different scaling. Using container&apos;s&quot; + &quot; compatiblity info:&quot; + container.getDisplayMetrics()); &#125; mResources = mainThread.getTopLevelResources( mPackageInfo.getResDir(), container.getCompatibilityInfo().copy()); &#125; mMainThread = mainThread; mContentResolver = new ApplicationContentResolver(this, mainThread); setActivityToken(activityToken); &#125; mResources又是调用LoadedApk的getResources方法进行赋值。代码如下。 123456public Resources getResources(ActivityThread mainThread) &#123; if (mResources == null) &#123; mResources = mainThread.getTopLevelResources(mResDir, this); &#125; return mResources; &#125; 从代码中可以看到，最终mResources的赋值是由AcitivtyThread的getTopLevelResources方法返回。代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Resources getTopLevelResources(String resDir, CompatibilityInfo compInfo) &#123; ResourcesKey key = new ResourcesKey(resDir, compInfo.applicationScale); Resources r; synchronized (mPackages) &#123; // Resources is app scale dependent. if (false) &#123; Slog.w(TAG, &quot;getTopLevelResources: &quot; + resDir + &quot; / &quot; + compInfo.applicationScale); &#125; WeakReference&lt;Resources&gt; wr = mActiveResources.get(key); r = wr != null ? wr.get() : null; if (r != null &amp;&amp; r.getAssets().isUpToDate()) &#123; if (false) &#123; Slog.w(TAG, &quot;Returning cached resources &quot; + r + &quot; &quot; + resDir + &quot;: appScale=&quot; + r.getCompatibilityInfo().applicationScale); &#125; return r; &#125; &#125; AssetManager assets = new AssetManager(); if (assets.addAssetPath(resDir) == 0) &#123; return null; &#125; DisplayMetrics metrics = getDisplayMetricsLocked(false); r = new Resources(assets, metrics, getConfiguration(), compInfo); if (false) &#123; Slog.i(TAG, &quot;Created app resources &quot; + resDir + &quot; &quot; + r + &quot;: &quot; + r.getConfiguration() + &quot; appScale=&quot; + r.getCompatibilityInfo().applicationScale); &#125; synchronized (mPackages) &#123; WeakReference&lt;Resources&gt; wr = mActiveResources.get(key); Resources existing = wr != null ? wr.get() : null; if (existing != null &amp;&amp; existing.getAssets().isUpToDate()) &#123; // Someone else already created the resources while we were // unlocked; go ahead and use theirs. r.getAssets().close(); return existing; &#125; // XXX need to remove entries when weak references go away mActiveResources.put(key, new WeakReference&lt;Resources&gt;(r)); return r; &#125; &#125; 以上代码中，mActiveResources对象内部保存了该应用程序所使用到的所有Resources对象，其类型为WeakReference，所以当内存紧张时，可以释放Resources占用的资源，自然这不是我们探究的重点，ResourcesKey的构造需要resDir和compInfo.applicationScale。resdDir变量的含义是资源文件所在路径，实际指的是APK程序所在路径，比如可以是：/data/app/com.haii.android.xxx-1.apk，该apk会对应/data/dalvik-cache目录下的：data@app@com.haii.android.xxx-1.apk@classes.dex文件。 所以结论来了： 如果一个应用程序没有访问该程序以外的资源，那么mActiveResources变量中就仅有一个Resources对象。 总结： 当ActivityThread类中创建Application、Service、Activity的同时，完成了与ContextImpl的关联绑定，通过ContextImpl类中init方法，获得了一个唯一的Resources对象，根据上述代码中资源的请求机制，再加上ResourcesManager采用单例模式，这样就保证了不同的ContextImpl访问的是同一套资源。 如果这篇博客现在就结束了，你一定会杀了我 - -，现在我们就来分析下，是什么造成了唯一的这个Resources，却展现出了“不同”。 举个通俗易懂的例子，我和我老妈都拿到同一块土豆，但是因为我们处理这个土豆的方法有区别，导致这个土豆最后表现出来的也不一样，我想把它做成薯片，我妈妈把它炒成了土豆丝，:-D。 再具体一点，比如除了Activity可以创建一个Dialog，其它Context都不可以创建Dialog。比如在Application中创建Dialog会报错，还有Application和Service可以启动一个Activity，但是需要创建一个新的task。比如你在Application中调用startActivity（intent）时系统也会崩溃报错。 报错的原因并不是因为他们拿到的Context资源不同，拿到的都是一个Resoucres对象，但是在创建Dialog的时候会使用到Context对象去获取当前主题信息，但是我们知道Application和Service是继承自ContextWrapper，没有实现关于主题的功能，然而Activity是继承自ContextThemeWrapper，该类是实现了关于主题功能的，因此创建Dialog的时候必须依附于Activity的Context引用。 结论： Application、Service、Activity，它们本身对Resources资源处理方法的不同，造成了这个Resoucres最后表现出来的不一样，这么说大家就都懂了吧！ 四：Context内存泄漏关于Context的内存泄漏，找到一篇比较不错的文章分享给大家。 Android开发，中可能会导致内存泄露的问题 写在最后： Context可能还有更多深层次的知识需要我们去了解，比如Context这些封装类，是具体如何通过Binder跟ContextImpl进行关联的；资源对象都被存储在ArrayMap，为什么ArrayMap中会有可能存在多个资源对象，如何访问其他应用程序的Context资源等等，剩下的这些就靠大家慢慢发掘了~ 转载请注明出处。 如果大家觉得喜欢有价值，就关注我，点下赞哈，你们的支持是我持续原创的动力。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Context","slug":"Context","permalink":"http://yoursite.com/tags/Context/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"Android的性能优化总结","slug":"Android性能优化总结","date":"2016-07-27T13:18:04.904Z","updated":"2016-07-27T13:29:17.446Z","comments":true,"path":"2016/07/27/Android性能优化总结/","link":"","permalink":"http://yoursite.com/2016/07/27/Android性能优化总结/","excerpt":"","text":"Android的性能优化写在前面： 公司给了我一周的时间去学习Android性能的优化，参考了张明云老师的一片文章，并且用公司的实际项目进行测试（附有截图），还进行了一些知识点，注意事项以及很多网址链接的补充，希望这篇博文能让做性能测试的朋友们少走一些弯路。 文中没有贴出大段代码，但是几乎所有的知识点都有链接，点进去就能看你想看的。转载注明出处。 零：性能指标 布局复杂度：布局复杂会导致布局需要更长的时间，从而导致进入应用慢、页面切换慢； 耗电量：耗电量大会导致机器发热、缩短机器的有效使用时长； 内存：内存消耗大会导致频繁GC，GC时会暂停其它工作，导致页面卡顿；内存泄露会导致剩余可用内存越来越小；内存不足会导致应用异常； 网络：频繁的网络访问会导致耗电和影响应用的性能；网络交互数据大小会影响网络传输的效率； 程序执行效率：糟糕的代码会严重影响程序的运行效率，UI线程过多的任务会阻塞应用的正常运行，长时间持有某个对象会导致潜在的内存泄露，频繁的IO操作、网络操作而不用缓存会严重影响程序的运行效率。####一：布局复杂度的优化关于布局的优化，主要分两个大方向1. 实现相同界面效果并且层级结构相同时，选用何种Layout最好在Android中单独的布局性能： 1FrameLayout&gt;LinearLayout&gt;RelativeLayout 可供参考的网址：LinearLayout与RelativeLayout的性能比较总结: RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure; RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin; 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout; 使用组合控件性能要好于两个独立控件，比如一个文本旁边有一个图片，这中情况最好要用DrawableLeft的这种属性设置图片; 2. 减少布局的层级结构 HierarchyViewer—可查看布局层次结构，View绘制时耗时。HierarchyViewer的使用 无线UIViewer—强烈推荐App工具，可在手机端直接实现HierarchyViewer的功能，查看任意界面的UI布局。无线UIViewer下载 测试图片如下：当前界面的UI布局层级如上图所示 总结： 一些复用性很高的布局文件，比如一个App的标题栏，建议使用布局重用include标签，方便引入和共同管理。 观察上图第三个层级和第四个层级，无论是Layout类型，还是所覆盖的坐标点，都是重合的，因为父FrameLayout作为一个Container，子FrameLayout作为一个子View的跟布局，这种情况，可使用merge标签进行布局层级的优化。 有些在特定情况下才会出现的界面，比如联网之后，或者未必百分之百出现的界面，可用ViewStub标签进行懒加载，性能明显要优于加载出这个界面然后gone掉。 布局优化相关网址：三种优化标签的使用情景和优势—张业兴布局优化标签的源码分析 有关布局优化的一些基础知识准备(郭霖老师的两篇博客)：Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) 二：Android开发者模式—GPU过渡绘制GPU过度绘制定义： 如果你粉刷过一个房间或一所房子，就会知道给墙壁涂上颜色需要做大量的工作。假如你还要重新粉刷一次的话，第二次粉刷的颜色会覆盖住第一次的颜色，第一次的颜色就永远不可见了，等于你第一次粉刷做的大量工作就完全被浪费掉。这太可怕了。 同样的道理，如果在你的应用程序中浪费精力去绘制一些东西同样会产生性能问题。过度绘制这个名词就是用来描述屏幕上一个像素在单个帧中被重绘了多少次。 GPU过度绘制就指的是在屏幕一个像素上绘制多次(超过一次)，GPU过度绘制或多或少对性能有些影响。 GPU过度绘制分析： 过度绘制其实是一个性能和设计的交叉点。我们在设计上追求很华丽的视觉效果，但一般来说这种视觉效果会采用非常多的层叠组件来实现，这时候就会带来过度绘制的问题。我们再来看看具体显示在Android界面层级关系： 当我们来绘制一个界面时，会有一个windows，然后是建立Activity，在Activity里可以建立多个view，或view group，view也可以嵌套view。这些组件从上到下分布，上面的组件是可以被用户看见的，而在下面的组件是不可见的，但是我们依然要花很多时间去绘制那些不可见的组件，因为在某些时候，它也可能会显示出来。 检测过度绘制： 设置-开发者选项-调试GPU过度绘制-显示过度绘制区域(过度渲染等，不同机器可能不同) 测试的颜色标识含义： 项目测试截图： 可以看到项目中并不存在太大问题，有关减少过度绘制的一些建议： 太多重叠的背景 这个问题其实最容易解决，建议前期在设计时尽量保持整体背景统一，另外开发可以检查你在布局和代码中设置的背景，有些背景是被隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。 太多重叠的view 第一个建议是：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认不可见的视图，可以动态的加载一个布局，只有你用到这个重叠着的view的时候才加载，推迟加载的时间。第二个建议是：如果使用了类似viewpager+Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态地Inflation view，它的性能要比SetVisiblity好。 复杂的Layout层级 这里的建议比较多一些，首先推荐用Android提供的布局工具Hierarchy 三：Android中耗电量的测试深入浅出Android App耗电量统计 测试截图： 本人认为这一点没有过多补充的，大多数App都不会消耗过多的电量。 四：内存、CPU、GPU应用运行时内存使用情况查看：Android Studio—Memory/CPU/GPU 通常这种测试应该使用一个自动化工具（monkey）去不停的点击App，或者切换界面，来观察内存、cpu的情况。 内存 测试截图： 在地图界面不断地刷新，正常的内存成锯齿状分布。 需要注意的情况： 出现了针状分布，说明内存发生了突变，如果内存峰值不能降下来，就说明出现了内存溢出，就值得引起我们的关注了。 CPU 测试图片： GPU Android Studio 1.4增加一项新功能：分析GPU渲染功能。作者详细讲解这一新功能的分析方法。 在GPU选项卡下，可以在屏幕上看到图形化显示的渲染每帧所花费的时间。图形中每条都表示被渲染的一帧。颜色表示进程的不同周期： 绘画（蓝色）表示View#onDraw()方法。那部分建立/更改DisplayList对象，然后转换成GPU能够理解的OpenGL命令。高的条形可能是视图复杂，而要求更多的时间绘制它们的显示列表，而许多视图在短时间内就失效了。 准备（紫色）在Lollipop中，加入另一个线程，以帮助UI线程渲染更快。这个线程叫：RenderThread。它的责任是转换显示列表为OpenGL命令，再发送给GPU。这样在渲染过程中，UI线程可以开始处理下一个帧。这时UI线程将所有资源传送给RenderThread。如果有许多资源要传递（如许多/繁重显示列表），这一步可能需要较长时间。 处理（红色）执行显示列表产生OpenGL命令。由于需要视图重绘，如果有许多/复杂显示列表要执行转换，这一步可能需要较长时间。当视图无效或是移动时，都要要重绘视图。 执行（黄色）发送OpenGL命令到GPU。由于CPU发送这些缓存的命令到GPU，并期待收回干净缓存，这就阻塞调用了。缓存数量有限，并且GPU也很忙——CPU会发现自己必须先等待缓存释放。因此，如果在这一步我们见高的条形，就可能意味着GPU在绘制UI时非常忙，这个绘制在短时间内太复杂了。 测试截图： 结论： 可以通过切换界面，看图形的峰值和颜色去判断绘制View每个阶段所花费的时间，然后根据你的需求进行优化。 五：程序的执行效率 静态代码检查工具：Android studio—Analyze—Inspect Code…/Code cleanup… ，用于检测代码中潜在的问题、存在效率问题的代码段并提供改善方案； DDMS—TraceView，用于查找程序运行时具体耗时在哪； StrictMode：用于查找程序运行时具体耗时在哪，需要集成到代码中； ####六：知名的三方性能优化工具 LeakCanaryLeakCanary是一个检测内存泄露的开源类库。你可以在 debug包种轻松检测内存泄露。强烈推荐LeakCanary，大多数公司都在使用它进行内存泄漏的测试。 以下是我找到的学习资料，写的非常棒： LeakCanary:让内存泄露无所遁形 LeakCanary中文使用说明 具体使用请参考以上两个链接，下面给出一个测试截图，供大家直观感受其便捷和强大的功能。 结论： LeakCanary非常直观的展现了MainActivity出现了内存泄漏，并且指出引用路径中的哪个引用是不该有的，然后修复问题。总而言之非常好用，处理内存泄漏首选的工具。 GT GT是腾讯开发的一款APP的随身调测平台，利用GT，可以对CPU、内存、流量、点亮、帧率/流畅度进行测试，还可以查看开发日志、crash日志、抓取网络数据包、APP内部参数调试、真机代码耗时统计等等，需要说明的是，应用需要集成GT的sdk后，GT这个apk才能在应用运行时对各个性能进行检测。 GT官方网址 下面是使用GT测试项目的截图： 具体图片是什么含义，大家去点击官网去了解学习就可以，GT还是很全面好用的，慢慢发掘吧。 第一次写技术博客，并没有贴出大量代码，如果大家需要了解原理，点进链接去看就好了，如果有什么建议和问题大家可以给我留言。有什么好的工具和方法可以同大家一起分享。 如果对大家喜欢请点赞收藏哈，你们的认可是我写作的动力O(∩_∩)O","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"},{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/经验/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-07-26T07:59:04.773Z","updated":"2016-07-27T13:05:02.809Z","comments":true,"path":"2016/07/26/hello-world/","link":"","permalink":"http://yoursite.com/2016/07/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
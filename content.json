{"meta":{"title":"Melo's Blog","subtitle":"耐心的偏执狂，浪漫的现实主义","description":null,"author":"Melo","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2016-07-26T13:34:31.000Z","updated":"2016-07-26T13:34:31.410Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ActivityThread的main方法究竟做了什么？","slug":"ActivityThread的main方法究竟做了什么？","date":"2016-07-28T02:38:32.727Z","updated":"2016-07-28T02:39:14.195Z","comments":true,"path":"2016/07/28/ActivityThread的main方法究竟做了什么？/","link":"","permalink":"http://yoursite.com/2016/07/28/ActivityThread的main方法究竟做了什么？/","excerpt":"ActivityThread的main方法究竟做了什么？写在前面：在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~","text":"ActivityThread的main方法究竟做了什么？写在前面：在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~ 问大家一个问题： Android中一个应用程序的真正入口是什么？ 无论你知道不知道，别着急回答，再问大家一个问题： Android不能像java一样直接跑在main方法的原因是什么？ Android应用程序的载体是APK文件，它本质上，是一个资源和组件的容器，APK文件和我们常见的可执行文件的区别在何处？ 每个可执行文件运行在一个进程中，但是APK文件可能运行在一个单独的进程，也可以和其他APK运行在同一进程中，结合上面，我想表达的是： Android系统的设计理念就是弱化进程，取而代之是组件的概念。 但是我们都知道，Android系统基于Linux系统之上，而Linux系统的运行环境恰恰就是由进程组成。所有的Android应用进程都是有Zygote进程fork出来的，因此构成进程的地层系统、虚拟机、动态库等，都是相同的。 当然Android除了继承从Zygote中得到的某些基础的“家当”之外，Android还需要在应用的Java层建立一套框架来管理运行的组件。由于每个应用的配置都不相同，因此不能再Zygote中完全建立好再继承，只能在应用启动时创建。 这套框架就构成了Android应用的基础。 而这套框架有很多核心类，比如： ActivityThread、ApplicationThread、Context、ActivityManagerService等等。这里我先给自己挖一个坑，将来慢慢填上，争取清晰简洁的给大家讲明白Android的组件管理。 而今天，我们现在聊聊ActivityThread的main方法 ActivityThread好像忘了点什么。。。 对对，回头看看，我们还有两个问题没解答呢，整个Android应用进程的体系非常复杂，而ActivityThread是真正的核心类，它的main方法，是整个应用进程的入口。 所以当有人问你应用进程的真正入口是什么，你回答“Activity 的 onCreate 方法”显然就没理解这个问题的意思。 而第二个问题，相信你心里肯定知道大概怎么回答，我们的一个Android应用程序可以是理解为是四大组件和各种资源的集合，它需要各种各样的环境资源，当然不能像Java直接跑在main方法里面。 而今天我们就来看看ActivityThread的main方法究竟做了些什么。 在此之前，安利一个看源码的网站，非常不错 http://grepcode.com/ 点击进去类名就可以查看源码了 ActivityThread的源码有5000多行，显然我没能力弄懂它每一行代码的意思，不过我们只要知道它大体上负责着什么功能和职责，就可以了。 看看上图中的成员变量，在给大家上一个图，就能理解ActivityThread管理着什么。 从图中可以知道，mActivities、mServices和mProviderMap 这三个变量都被保存在ArrayMap之中，他们分别保存了应用中所有的Activity对象、Services对象、和ContentProvider对象。 咦？同为四大组件的BroadcastReceive去哪里了？注意，BroadcastReceiver对象没有必要用任何数据结构来保存，因为BroadcastReceiver对象的生命周期很短暂，属于我调用它时，再创建运行，因此不需要保存BroadcastReceiver的对象。 我们都知道应用中Applicaiton对象是唯一的，而mInitialApplication变量是恰恰是Application对象。当你的应用自定义一个派生Applicaiton类，则它就是mInitialApplication了。 ApplicationThread类型变量mAppThread是一个Binder实体对象，ActivityManagerService作为Client端调用ApplicationThread的接口，目的是用来调度管理Activity，这个我们未来会细说。 变量mResourcesManager管理着应用中的资源。 一口气说了这么多，怎么样，ActivityThread是不是相当于一个CEO，管理调度着几乎所有的Android应用进程的资源和四大组件 上面非常多的问题我未来会给大家慢慢解答，因为篇幅太长反而会影响阅读和知识的吸收，话不多说，来看看入口方法main都做了些什么？ ActivityThread的main方法感兴趣的同学去刚才给出的网站上搜搜ActivityThread的类，大致浏览一下，这里先贴出main方法的代码： 12345678910111213141516171819202122232425262728293031323334353637383940public static void More ...main(String[] args) &#123;5220 SamplingProfilerIntegration.start();52215222 // CloseGuard defaults to true and can be quite spammy. We5223 // disable it here, but selectively enable it later (via5224 // StrictMode) on debug builds, but using DropBox, not logs.5225 CloseGuard.setEnabled(false);5226 // 初始化应用中需要使用的系统路径5227 Environment.initForCurrentUser();52285229 // Set the reporter for event logging in libcore5230 EventLogger.setReporter(new EventLoggingReporter());5231 //增加一个保存key的provider5232 Security.addProvider(new AndroidKeyStoreProvider());52335234 // Make sure TrustedCertificateStore looks in the right place for CA certificates //为应用设置当前用户的CA证书保存的位置5235 final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());5236 TrustedCertificateStore.setDefaultUserDirectory(configDir);5237 //设置进程的名称5238 Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);52395240 Looper.prepareMainLooper();5241 //创建ActivityThread 对象5242 ActivityThread thread = new ActivityThread();5243 thread.attach(false);52445245 if (sMainThreadHandler == null) &#123;5246 sMainThreadHandler = thread.getHandler();5247 &#125;52485249 if (false) &#123;5250 Looper.myLooper().setMessageLogging(new5251 LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));5252 &#125;52535254 Looper.loop();52555256 throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);5257 &#125; 代码并不多，但是条条关键，这些操作我都为大家写了注释，看一下就知道程序在做什么。 123456789101112131415161718Looper.prepareMainLooper();//创建ActivityThread 对象 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler =thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; 这几行代码拿出来单独讲解一下，首先Looper.prepareMainLooper();是为主线程创建了Looper，然后thread.getHandler();是保存了主线程的Handler，最后Looper.loop();进入消息循环。 如果不了解Android的消息机制，大家可以来看看以前我写的文章来了解一下： Android消息机制详解 马上就要大功告成了，最后还剩下一行代码还没解释： thread.attach(false); 继续跟进attach方法，一探究竟： 12345678910111213141516171819202122232425262728293031323334353637383940 if (!system) &#123;5080 ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;5081 @Override5082 public void More ...run() &#123;5083 ensureJitEnabled();5084 &#125;5085 &#125;);5086 android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,5087 UserHandle.myUserId());//将mAppThread放到RuntimeInit类中的静态变量5088 RuntimeInit.setApplicationObject(mAppThread.asBinder());5089 final IActivityManager mgr = ActivityManagerNative.getDefault();5090 try &#123; //将mAppThread传入ActivityThreadManager中5091 mgr.attachApplication(mAppThread);5092 &#125; catch (RemoteException ex) &#123;5093 // Ignore5094 &#125;5095 // Watch for getting close to heap limit.5096 BinderInternal.addGcWatcher(new Runnable() &#123;5097 @Override public void More ...run() &#123;5098 if (!mSomeActivitiesChanged) &#123;5099 return;5100 &#125;5101 Runtime runtime = Runtime.getRuntime();5102 long dalvikMax = runtime.maxMemory();5103 long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();5104 if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123;5105 if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024)5106 + &quot; total=&quot; + (runtime.totalMemory()/1024)5107 + &quot; used=&quot; + (dalvikUsed/1024));5108 mSomeActivitiesChanged = false;5109 try &#123;5110 mgr.releaseSomeActivities(mAppThread);5111 &#125; catch (RemoteException e) &#123;5112 &#125;5113 &#125;5114 &#125;5115 &#125;);5116 &#125; 当传入的参数为false时，就走到了如上面贴出的代码中： 此时主要完成两件事 1.调用 RuntimeInit.setApplicationObject() 方法，把对象mAppThread（Binder）放到了RuntimeInit类中的静态变量mApplicationObject中。 123 public static final void More ...setApplicationObject(IBinder app) &#123;360 mApplicationObject = app;361 &#125; mAppThread的类型是ApplicationThread，它是ActivityThread的成员变量，定义和初始化如下： 1final ApplicationThread mAppThread = new ApplicationThread(); 第二件事比较关键了，就是调用ActivityManagerService的attachApplication()方法，将mAppThread 作为参数传入ActivityManagerService，这样ActivityManagerService就可以调用ApplicaitonThread的接口了。这与我们刚才说的，ActivityManagerService作为Client端调用ApplicaitonThread的接口管理Activity，就不谋而合了。 写在后面：本文我们明白了ActiivtyThread作为进程的核心类它都管理着哪些对象，并且解释了程序真正入口ActivityThread的main方法都完成了哪些重要的操作，之后会继续带大家了解相关共同组成Android应用进程的核心类，如果有问题和疑问可以多交流，毕竟我也是边学习变整理总结嘛~ 如果有需要，推荐你了解一下Context，对你会很有帮助哦~ 你足够了解Context吗？ 最后PS：注意保护电脑不要被水淹！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"Android微信自动回复功能","slug":"Android微信自动回复功能","date":"2016-07-28T02:35:00.055Z","updated":"2016-07-28T02:35:48.630Z","comments":true,"path":"2016/07/28/Android微信自动回复功能/","link":"","permalink":"http://yoursite.com/2016/07/28/Android微信自动回复功能/","excerpt":"Android微信自动回复功能写在前面：最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。","text":"Android微信自动回复功能写在前面：最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。老大还提示我需要用AccessibilityService去实现它，当然在此之前我并不知道AccessibilityService是什么鬼，不过没关系， just do IT ！ AccessibilityServiceAccessibilityService官方文档（需翻墙） 上面这个链接是AccessibilityService的官方文档，可以翻墙点进去了解下，我再给大家总结一下： AccessibilityService是Android系统框架提供给安装在设备上应用的一个可选的导航反馈特性。AccessibilityService 可以替代应用与用户交流反馈，比如将文本转化为语音提示，或是用户的手指悬停在屏幕上一个较重要的区域时的触摸反馈等。 如果感觉上面的描述比较抽象，没关系，也许你见过下面这张图： 打开你手机的设置–辅助功能中，有很多APP提供的服务，他们都是基于AccessibilityService编写的，AccessibilityService可以侦听你的点击，长按，手势，通知栏的变化等。并且你可以通过很多种方式找到窗体中的EditText，Button等组件，去填充他们，去点击他们来帮你实现自动化的功能。 像360助手的自动安装功能，它就是侦听着系统安装的APP，然后找到“安装”按钮，实现了自动点击。微信自动抢红包功能，实现方式都是如此。 配置AccessibilityService首先我们在res文件夹下创建xml文件夹，然后创建一个名为auto_reply_service_config的文件，一会我们会在清单文件中引用它。 代码： 1234567&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged&quot; android:accessibilityFeedbackType=&quot;feedbackGeneric&quot; android:accessibilityFlags=&quot;flagDefault&quot; android:canRetrieveWindowContent=&quot;true&quot; android:description=&quot;@string/accessibility_description&quot; android:notificationTimeout=&quot;100&quot; android:packageNames=&quot;com.tencent.mm&quot; /&gt; 这个文件表示我们对AccessibilityService服务未来侦听的行为做了一些配置，比如 typeNotificationStateChanged 和 typeWindowStateChanged 表示我们需要侦听通知栏的状态变化和窗体状态改变。android:packageNames=”com.tencent.mm” 这是微信的包名，表示我们只关心微信这一个应用。 代码不打算带着大家一行一行看了，如果有不明白的，去看看文档，或者下面回复我，我给大家解答~ 创建AccessibilityService下面贴出AccessibilityService类的全部代码，注释还算详尽，如有疑问，下方回复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354package com.ileja.autoreply;import android.accessibilityservice.AccessibilityService;import android.annotation.SuppressLint;import android.app.ActivityManager;import android.app.KeyguardManager;import android.app.Notification;import android.app.PendingIntent;import android.content.ClipData;import android.content.ClipboardManager;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.os.PowerManager;import android.text.TextUtils;import android.view.KeyEvent;import android.view.accessibility.AccessibilityEvent;import android.view.accessibility.AccessibilityNodeInfo;import java.io.IOException;import java.util.List;public class AutoReplyService extends AccessibilityService &#123; private final static String MM_PNAME = &quot;com.tencent.mm&quot;; boolean hasAction = false; boolean locked = false; boolean background = false; private String name; private String scontent; AccessibilityNodeInfo itemNodeinfo; private KeyguardManager.KeyguardLock kl; private Handler handler = new Handler(); /** * 必须重写的方法，响应各种事件。 * @param event */ @Override public void onAccessibilityEvent(final AccessibilityEvent event) &#123; int eventType = event.getEventType(); android.util.Log.d(&quot;maptrix&quot;, &quot;get event = &quot; + eventType); switch (eventType) &#123; case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:// 通知栏事件 android.util.Log.d(&quot;maptrix&quot;, &quot;get notification event&quot;); List&lt;CharSequence&gt; texts = event.getText(); if (!texts.isEmpty()) &#123; for (CharSequence text : texts) &#123; String content = text.toString(); if (!TextUtils.isEmpty(content)) &#123; if (isScreenLocked()) &#123; locked = true; wakeAndUnlock(); android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is locked&quot;); if (isAppForeground(MM_PNAME)) &#123; background = false; android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;); sendNotifacationReply(event); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; sendNotifacationReply(event); if (fill()) &#123; send(); &#125; &#125; &#125;, 1000); &#125; else &#123; background = true; android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;); sendNotifacationReply(event); &#125; &#125; else &#123; locked = false; android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is unlocked&quot;); // 监听到微信红包的notification，打开通知 if (isAppForeground(MM_PNAME)) &#123; background = false; android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;); sendNotifacationReply(event); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; if (fill()) &#123; send(); &#125; &#125; &#125;, 1000); &#125; else &#123; background = true; android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;); sendNotifacationReply(event); &#125; &#125; &#125; &#125; &#125; break; case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED: android.util.Log.d(&quot;maptrix&quot;, &quot;get type window down event&quot;); if (!hasAction) break; itemNodeinfo = null; String className = event.getClassName().toString(); if (className.equals(&quot;com.tencent.mm.ui.LauncherUI&quot;)) &#123; if (fill()) &#123; send(); &#125;else &#123; if(itemNodeinfo != null)&#123; itemNodeinfo.performAction(AccessibilityNodeInfo.ACTION_CLICK); handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; if (fill()) &#123; send(); &#125; back2Home(); release(); hasAction = false; &#125; &#125;, 1000); break; &#125; &#125; &#125; //bring2Front(); back2Home(); release(); hasAction = false; break; &#125; &#125; /** * 寻找窗体中的“发送”按钮，并且点击。 */ @SuppressLint(&quot;NewApi&quot;) private void send() &#123; AccessibilityNodeInfo nodeInfo = getRootInActiveWindow(); if (nodeInfo != null) &#123; List&lt;AccessibilityNodeInfo&gt; list = nodeInfo .findAccessibilityNodeInfosByText(&quot;发送&quot;); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (AccessibilityNodeInfo n : list) &#123; if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled()) &#123; n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125; &#125; &#125; else &#123; List&lt;AccessibilityNodeInfo&gt; liste = nodeInfo .findAccessibilityNodeInfosByText(&quot;Send&quot;); if (liste != null &amp;&amp; liste.size() &gt; 0) &#123; for (AccessibilityNodeInfo n : liste) &#123; if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled()) &#123; n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125; &#125; &#125; &#125; &#125; pressBackButton(); &#125; &#125; /** * 模拟back按键 */ private void pressBackButton()&#123; Runtime runtime = Runtime.getRuntime(); try &#123; runtime.exec(&quot;input keyevent &quot; + KeyEvent.KEYCODE_BACK); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param event */ private void sendNotifacationReply(AccessibilityEvent event) &#123; hasAction = true; if (event.getParcelableData() != null &amp;&amp; event.getParcelableData() instanceof Notification) &#123; Notification notification = (Notification) event .getParcelableData(); String content = notification.tickerText.toString(); String[] cc = content.split(&quot;:&quot;); name = cc[0].trim(); scontent = cc[1].trim(); android.util.Log.i(&quot;maptrix&quot;, &quot;sender name =&quot; + name); android.util.Log.i(&quot;maptrix&quot;, &quot;sender content =&quot; + scontent); PendingIntent pendingIntent = notification.contentIntent; try &#123; pendingIntent.send(); &#125; catch (PendingIntent.CanceledException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @SuppressLint(&quot;NewApi&quot;) private boolean fill() &#123; AccessibilityNodeInfo rootNode = getRootInActiveWindow(); if (rootNode != null) &#123; return findEditText(rootNode, &quot;正在忙,稍后回复你&quot;); &#125; return false; &#125; private boolean findEditText(AccessibilityNodeInfo rootNode, String content) &#123; int count = rootNode.getChildCount(); android.util.Log.d(&quot;maptrix&quot;, &quot;root class=&quot; + rootNode.getClassName() + &quot;,&quot;+ rootNode.getText()+&quot;,&quot;+count); for (int i = 0; i &lt; count; i++) &#123; AccessibilityNodeInfo nodeInfo = rootNode.getChild(i); if (nodeInfo == null) &#123; android.util.Log.d(&quot;maptrix&quot;, &quot;nodeinfo = null&quot;); continue; &#125; android.util.Log.d(&quot;maptrix&quot;, &quot;class=&quot; + nodeInfo.getClassName()); android.util.Log.e(&quot;maptrix&quot;, &quot;ds=&quot; + nodeInfo.getContentDescription()); if(nodeInfo.getContentDescription() != null)&#123; int nindex = nodeInfo.getContentDescription().toString().indexOf(name); int cindex = nodeInfo.getContentDescription().toString().indexOf(scontent); android.util.Log.e(&quot;maptrix&quot;, &quot;nindex=&quot; + nindex + &quot; cindex=&quot; +cindex); if(nindex != -1)&#123; itemNodeinfo = nodeInfo; android.util.Log.i(&quot;maptrix&quot;, &quot;find node info&quot;); &#125; &#125; if (&quot;android.widget.EditText&quot;.equals(nodeInfo.getClassName())) &#123; android.util.Log.i(&quot;maptrix&quot;, &quot;==================&quot;); Bundle arguments = new Bundle(); arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT, AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD); arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN, true); nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY, arguments); nodeInfo.performAction(AccessibilityNodeInfo.ACTION_FOCUS); ClipData clip = ClipData.newPlainText(&quot;label&quot;, content); ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); clipboardManager.setPrimaryClip(clip); nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PASTE); return true; &#125; if (findEditText(nodeInfo, content)) &#123; return true; &#125; &#125; return false; &#125; @Override public void onInterrupt() &#123; &#125; /** * 判断指定的应用是否在前台运行 * * @param packageName * @return */ private boolean isAppForeground(String packageName) &#123; ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); ComponentName cn = am.getRunningTasks(1).get(0).topActivity; String currentPackageName = cn.getPackageName(); if (!TextUtils.isEmpty(currentPackageName) &amp;&amp; currentPackageName.equals(packageName)) &#123; return true; &#125; return false; &#125; /** * 将当前应用运行到前台 */ private void bring2Front() &#123; ActivityManager activtyManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = activtyManager.getRunningTasks(3); for (ActivityManager.RunningTaskInfo runningTaskInfo : runningTaskInfos) &#123; if (this.getPackageName().equals(runningTaskInfo.topActivity.getPackageName())) &#123; activtyManager.moveTaskToFront(runningTaskInfo.id, ActivityManager.MOVE_TASK_WITH_HOME); return; &#125; &#125; &#125; /** * 回到系统桌面 */ private void back2Home() &#123; Intent home = new Intent(Intent.ACTION_MAIN); home.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); home.addCategory(Intent.CATEGORY_HOME); startActivity(home); &#125; /** * 系统是否在锁屏状态 * * @return */ private boolean isScreenLocked() &#123; KeyguardManager keyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE); return keyguardManager.inKeyguardRestrictedInputMode(); &#125; private void wakeAndUnlock() &#123; //获取电源管理器对象 PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE); //获取PowerManager.WakeLock对象，后面的参数|表示同时传入两个值，最后的是调试用的Tag PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_BRIGHT_WAKE_LOCK, &quot;bright&quot;); //点亮屏幕 wl.acquire(1000); //得到键盘锁管理器对象 KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE); kl = km.newKeyguardLock(&quot;unLock&quot;); //解锁 kl.disableKeyguard(); &#125; private void release() &#123; if (locked &amp;&amp; kl != null) &#123; android.util.Log.d(&quot;maptrix&quot;, &quot;release the lock&quot;); //得到键盘锁管理器对象 kl.reenableKeyguard(); locked = false; &#125; &#125;&#125; 接着配置清单文件，权限和service的配置比较重要。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.ileja.autoreply&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.REORDER_TASKS&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=&quot;.AutoReplyService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/auto_reply_service_config&quot;/&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; 为了使用某些必要的API，最低API level应该是18 运行程序，打开服务，看看效果如何把~ 接着用其他手机试着发送给我几条微信 可以看到，自动回复功能就实现了。 写在后面： 代码没有给大家详细讲解，不过看注释应该可以看懂个大概。当微信程序切换到后台，或者锁屏（无锁屏密码）时，只要有通知出现，都可以实现自动回复。 关于AccessibilityService可以监控的行为非常多，所以我觉得可以实现各种各样炫酷的功能，不过我并不建议你打开某些流氓软件的AccessibilityService服务，因为很有可能造成一些安全问题，所以，自己动手写就安全多了嘛。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"跳出手机的Dialog--Presentation","slug":"跳出手机的Dialog--Presentation","date":"2016-07-28T02:33:09.556Z","updated":"2016-07-28T02:34:20.879Z","comments":true,"path":"2016/07/28/跳出手机的Dialog--Presentation/","link":"","permalink":"http://yoursite.com/2016/07/28/跳出手机的Dialog--Presentation/","excerpt":"跳出手机的Dialog–Presentation写在前面：Presentation 是 what？也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。","text":"跳出手机的Dialog–Presentation写在前面：Presentation 是 what？也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。 Presentation是说明书？Presentation是一个颁奖典礼？Presentation还是某卖药公司UE总监让所有IT人尴尬癌尽犯的PPT Presentation？ 公司做的是智能硬件方向，国内有关Presentation资料几乎是空白的，所以我的研究更多参考了Presentation官方文档和一些英文资料。如果各位看官有什么建议，一定要记得补充。 presentation的定义好吧，既然上面这些都不是，Presentation是一个类，我们翻过太平洋的墙，来看看Presentation的定义。 A presentation is a special kind of dialog whose purpose is to present content on a secondary display. 我们仅仅先来看这一句定义，因为当你对一个东西完全不了解时候，知道的越多，越会影响你的判断。 翻译下：presentation 是一种特殊的 dialog ，目的是为了在辅助屏幕上展示不同的内容。 在这句话上，我收集到了两个关键的信息： presentation 是一个 dialog根据生物遗传学的角度，presentation 无论被描述成什么天花乱坠的模样，它也是一个dialog。 presentation 目的是显示在辅助屏幕上 进一步思考下，也就是说： 我可以拿着我自己的手机，点击一个按钮，然后在你的电脑上或者手机上，弹出一个自定义的Dialog（脑补一下恶作剧场景O(∩_∩)O）？ 这与我们之前，通过一些软件，将手机屏幕同步到电脑上，区别又在哪里呢？ 相信很多人都能立刻想明白，区别在于：展示不同内容 通过软件同步到电脑，展示的东西始终与我的手机屏幕相同。 而利用 presentation 我可以自由的展示我想展示的内容，因为它是一个Dialog，是局部可控的。 寻找并投影到辅助屏幕产品经理找到我，向我提出了以下几个疑问： 现在手里有一部Android手机 能否连接以下几种设备 另一部Android手机 笔记本电脑 智能电视 小米盒子等 并且连接之后，利用presentation展示不同内容。 我乍一看这几个设备，感觉都没问题呀。可是当我拿着手机挨个尝试，几次失败，并且耐心分析之后，发现了问题。 首先Presentation是Android 4.2引出的，与之同时Android 4.2 还支持 Miracast 影像传输协议。所以它俩一定是有联系的。 Miracast Miracast简介 Miracast是一种基于WIFI的传输协议，Android 4.2以上的手机、Win8电脑、智能电视、盒子几乎都是支持它的。 不过Miracast它将设备分为发送端和接收端发送端有手机、电脑。接收端有智能电视、电视盒子。 所以，手机连手机或电脑展示Presentation，是行不通的。手机作为发射端，去寻找智能电视和盒子才是正解。 Presentation终于弄明白了要寻找的设备是怎样的，建立连接之前，参考官方文档的样例，我们先把Presentation给搭建好。 可以看到，和Activity一样，可以通过setContentView来给Presentation设置一个布局。自然布局里可以有各种各样的组件，还可以有像GLSurfaceView、SurfaceView 这种重量级的组件，来显示炫酷的动画。这里我们就仅仅写一个TextView，展示一行“show a Presentation”文字。 值得一提的是，在Presentation中的getContext得到的context与它依附的Activity的context是不同的，Presentation的context是目标屏幕属性的context，包含着辅助屏幕的属性信息。 获取辅助屏幕获取辅助屏幕有两种方式 MediaRouter DisplayManager MediaRouter 利用MediaRouter的API寻找周围设备是一种最简单的方式了，它会直接绑定周围最合适的设备。就相当于你用谷歌搜索直接点击“手气不错” 代码如下： 可以看到在Presentation的构造中，传入了一个display，这就是搜索到的那个设备 先来测试一下，Android 4.2的手机在开发中选项中，都有模拟辅助屏幕的功能，我们选择一个分辨率，打开它，模拟一个外部的屏幕。 默认辅助屏幕是同步手机屏幕的，打开之后，进入测试app，点击按钮： 注意这可不是一个Dialog，而是我们把内容展示在了一个模拟的辅助屏幕上，回头看看标题，是不是就实现了呢？ DisplayManager 第二种搜索设备的方法是DisplayManager，他可以搜索周围所有可用的display，产生一个display数组，然后你就可以选择合适的设备进行展示了。 代码如下： 代码还是挺简单的，搜索到周围所有可用设备之后，展示到ListView上，点击条目，在APP上和Presentataion上分别跑一个秒表，看看延时性如何，截图如下。 可以看到，搜索到的设备名称是 叠加视图#1 ，点击条目之后两个秒表也分别跑了起来。 总结： 上面对Presentation进行了一个简略的介绍，因为相信大家如果做的不是智能硬件方向，基本上不会遇到这个需求。关于Activity对Presentation的管理方式，官方文档的有两个Demo可以参考，需要时可以去查看。 写在后面： 周末在连接智能电视测试时，发现延时很小，完全可以投入使用。关于Presentation资料比较少，欢迎大家一同交流","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Presentation","slug":"Presentation","permalink":"http://yoursite.com/tags/Presentation/"},{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/tags/硬件/"}]},{"title":"3分钟傻瓜式反编译一个APP","slug":"3分钟傻瓜式反编译一个APP","date":"2016-07-28T02:32:03.731Z","updated":"2016-07-28T02:32:41.084Z","comments":true,"path":"2016/07/28/3分钟傻瓜式反编译一个APP/","link":"","permalink":"http://yoursite.com/2016/07/28/3分钟傻瓜式反编译一个APP/","excerpt":"3分钟傻瓜式反编译一个APP写在前面：最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。","text":"3分钟傻瓜式反编译一个APP写在前面：最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。 反编译是为了啥？我们什么时候需要反编译呢？ 想获得目标APP的资源（图片等） 有功能不会写了，参考（copy）一下同类APP 某些“羞羞”的事情 前两条需求还是蛮常见的，最后一条是开个玩笑，别做坏事就~ 准备工具 onekey decompile apk （一键反编译APK工具） 目标APK onekey decompile apk下载链接 正确姿势下载工具压缩包 多说一句，这个工具集成了三个反编译的工具的功能，一步到位。如果你对这三个工具各自的功能使用感兴趣，自行搜索学习一下。 解压到C盘根目录 这里强调一下，最好是放在C盘根目录下，放到别的盘反编译可能会失败。我就失败过一次，具体原因是什么不得而知~ 得到以下文件： 将要反编译的APK放到这个目录下： 将apk文件拖拽到_onekey-decompile-apk.bat上 然后耐心等待十几秒…… 源代码弹出，反编译完成！ 会在onekey-decompile-apk目录下生成和apk同名的目录(放置了apktools反编译出来的东西) 会在onekey-decompile-apk目录下生成和apk同名的jar文件(dex2jar反编译出来的class) 图片资源会很完整，有些代码被混淆了，不过还是能看懂个大概的~ 写在后面： 这个工具的作用不止于此，有需要再慢慢研究吧~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"反编译","slug":"反编译","permalink":"http://yoursite.com/tags/反编译/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"Handler可能造成内存泄漏（四）","slug":"Handler可能造成内存泄漏（四）","date":"2016-07-28T02:18:57.129Z","updated":"2016-07-28T02:19:58.383Z","comments":true,"path":"2016/07/28/Handler可能造成内存泄漏（四）/","link":"","permalink":"http://yoursite.com/2016/07/28/Handler可能造成内存泄漏（四）/","excerpt":"Handler可能造成内存泄漏（四）写在前面：不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：","text":"Handler可能造成内存泄漏（四）写在前面：不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：子线程为何不能更新UI（一） 第一篇中我们探究了，在Android设计之时，为何子线程允许更新UI。官方给出的解释是由于线程安全（Thread Safe）问题。（当然也有一些其他方面的猜想） 解决在子线程更新UI崩溃问题（二） 第二篇中，我们总结了三种崩溃解决的办法。 Activity.runOnUIThread(); View.post(); Handler; 我们本着寻找最优解的思路比较了三种解决办法，发现代码的实现方式都为Handler，从而真正引出了Android消息机制，Handler。 带着这篇去通关所有Handler的提问（三） 第三篇文章是我们这个系列的重头戏，我用一个还算生动的故事，为大家解释了Handler和相关核心类的关系，推荐阅读。 OK，回顾之后，我们正式来开始本篇文章。 内存泄漏是怎么一回事？可以看到，标题中有一个显眼的名词，就是内存泄漏，我想有必要给初学的朋友们讲讲何为内存泄漏。 在讨论内存泄漏之前，先简单的说说Android中内存的回收 Dalivik虚拟机扮演了常规的垃圾回收角色，为了GC能够从App中及时回收内存，我们需要时时刻刻在适当的时机来释放引用对象，Dalvik的GC会自动把离开活动线程的对象进行回收。 什么是Android内存泄漏： 虽然Android是一个自动管理内存的开发环境，但是垃圾回收器只会移除那些已经失去引用的、不可达的对象，在十几万、几十万行代码中，由于你的失误使得一个本应该被销毁的对象仍然被错误的持有，那么该对象就永远不会被释放掉，这些已经没有任何价值的对象，仍然占据聚集在你的堆内存中，GC就会被频繁触发，多说几句，如果手机不错，一次GC的时间70毫秒，不会对应用的性能产生什么影响，但是如果一个手机的性能不是那么出色，一次GC时间120毫秒，出现大量的GC操作，我相信用户就能感觉到了吧。这些无用的引用堆积在堆内存中，越积越多最终导致Crash。 有关一些性能优化推荐给大家一个我总结的博客。 Android性能优化总结 扯得好像远了一点，既然明白了内存泄漏是怎么回事，那与Handler又有什么关系呢？ Handler造成的内存泄漏参考一篇外文： inner-class-handler-memory-leak 当我们正常使用Handler时，会给出一个warning提示。翻译过来就是，这个Handler类应该是静态的，否则可能造成内存泄漏。 当我们简单的使用Handler的时候，并不会踩到内存泄漏这个坑，不过当Handler作为一个内部类或者匿名类时，这个问题就可能发生。 在上篇中，我们知道，当Android启动之时，ActivityThread类中，会创建UI线程的Looper和MessageQueue MessageQueue中的消息会被一个接一个处理。应用的所有事件(比如Activity生命周期回调方法，按钮点击等等)都会被当做一个消息对象放入到Looper的消息队列中，然后再被逐一执行。UI线程的Looper存在于整个应用的生命周期内。 当在UI线程中创建Handler对象时，它就会和UI线程中Looper的消息队列进行关联。发送到这个消息队列中的消息会持有这个Handler的引用，这样当Looper最终处理这个消息的时候framework就会调用Handler#handleMessage(Message)方法来处理具体的逻辑。 在Java中，非静态的内部类或者匿名类会隐式的持有其外部类的引用，而静态的内部类则不会。 那么，内存到底是在哪里泄露的呢？其实泄漏发生的还是比较隐晦的，但是再看看下面这段代码： 1234567891011121314151617181920212223public class SampleActivity extends Activity &#123; private final Handler mLeakyHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mLeakyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 当activity被finish的时候，延迟发送的消息仍然会存活在UI线程的消息队列中，直到10分钟后它被处理掉。这个消息持有activity的Handler的引用，Handler又隐式的持有它的外部类(这里就是SampleActivity)的引用。这个引用会一直存在直到这个消息被处理，所以垃圾回收机制就没法回收这个activity，内存泄露就发生了。需要注意的是：15行的匿名Runnable子类也会导致内存泄露。非静态的匿名类会隐式的持有外部类的引用，所以context会被泄露掉。 解决这个问题也很简单：在新的类文件中实现Handler的子类或者使用static修饰内部类。静态的内部类不会持有外部类的引用，所以activity不会被泄露。如果你要在Handler内调用外部activity类的方法的话，可以让Handler持有外部activity类的弱引用，这样也不会有泄露activity的风险。关于匿名类造成的泄露问题，我们可以用static修饰这个匿名类对象解决这个问题，因为静态的匿名类也不会持有它外部类的引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are &quot;static&quot;. */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 静态和非静态内部类的区别是非常微妙的，但这个区别是每个Android开发者应该清楚的。那么底线是什么？如果要实例化一个超出activity生命周期的内部类对象，避免使用非静态的内部类。建议使用静态内部类并且在内部类中持有外部类的弱引用。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"},{"name":"内存泄漏","slug":"内存泄漏","permalink":"http://yoursite.com/tags/内存泄漏/"}]},{"title":"带着这篇去通关所有Handler的提问（三）","slug":"带着这篇去通关所有Handler的提问（三）","date":"2016-07-28T02:17:44.984Z","updated":"2016-07-28T02:18:29.229Z","comments":true,"path":"2016/07/28/带着这篇去通关所有Handler的提问（三）/","link":"","permalink":"http://yoursite.com/2016/07/28/带着这篇去通关所有Handler的提问（三）/","excerpt":"带着这篇去通关所有Handler的提问（三）写在前面：大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的思路和知识点：","text":"带着这篇去通关所有Handler的提问（三）写在前面：大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的思路和知识点：Android消息机制字典型探究（一） 在第一篇文章中，我们总结了Android系统不允许在子线程更新UI的原因，本质上是线程安全问题，从而引出了Handler。 Android消息机制字典型探究（二） 在第二篇文章中，我们又分析了三种在子线程更新UI的方法，分别是：View.post(param); Activity.runOnUIThread(param); Handler，当我们对这三种方法的源码进一步分析发现，其实都是对Handler做了一些封装，所以本文我们就来正式全面探究有关Handler的知识点。 当时我去面试的四家公司，都问到了Handler的相关知识，有深有浅，所以重要程度不言而喻。面试官拿起你的简历，让你谈谈Handler，你仅仅在表象上回答了Android线程通信的机理，然后面试官紧接着问了你如下的几个问题： Handler是属于哪个类的？ Handler、Looper、MessageQueue何时建立的相互关系？ 主线程的Looper和MessageQueue是何时创建的？ 在同一线程中，Looper和MessageQueue是怎样的数量对应关系，与Handler又是怎样的数量对应关系？ MessageQueue中消息为空，线程阻塞挂起等待，为什么不会造成ANR？ 有关Handler的内存泄漏是怎么一回事？ so…光知道表象很可能是不够的，而且还给自己挖了一个坑，所以我们对于一个知识点的探寻要全面充分一点。下面正式开始本文。 Windows和Android消息机制的区别现在的操作系统普遍采用消息驱动模式。Windows操作系统就是典型的消息驱动模型。但是，Android的消息处理机制和Windows的消息处理机制又不太相同。我给大家画了图，看看二者的区别。 通过消息机制图的对比，Windows消息处理模型中，存在一个系统的消息队列，这个队列是整个进程的核心，几乎所有的动作都要转换成消息，然后放到这个队列中，由主线程统一处理。 而Android没有全局的消息队列，消息队列是和某个线程相关联在一起的。每个线程最多有一个消息队列，消息的取出和处理，也在这个线程本身中完成。 也就是说，Android中，如果你想在当前线程使用消息模型，则必须构建一个消息队列，而消息机制的相关主要类是：Looper、Handler、MessageQueue、Message。 我们并不着急去翻看这些类的源码，理清楚底层实现的逻辑，而且先在宏观表象上看看，Android消息机制是如何运行的？ Android消息机制的宏观原理先来看一张Android消息处理类之间的关系图 我们从表象上解释一下原理，Handler负责将Message发送至当前线程的MessageQueue中，Looper时时刻刻监视着MessageQueue，将符合时间要求的Message取出，再带给发送消息的那个Handler通过HandleMessage处理。 对于消息机制的理解不能仅仅停留在这一步，下面我们从源码的角度分析一下具体的逻辑细节。 Android消息机制相关类的源码分析其实写这篇文章之前，我就一直在思考，站在什么角度展开这个机制的描述，更容易让大家理解接受。思来想去，我觉得还是以一个Message游历的形式去描写，会显着有趣和清晰一点。 Message： 人在边境X（子线程）服役的士兵Message慵懒得躺在一个人数为50（池中最大数量）的军营（Message池）中。不料这时突然接到了上司的obtain()命令（据说obtain命令更加节省军费），让他去首都（主线程）告诉中央领导一些神秘代码。小Message慌乱地整理了下衣角和帽子，带上信封，准备出发。 上司让士兵Message收拾完毕之后等待一个神秘人的电话，并且嘱咐他：到了首都之后，0是这次任务的暗号。 Message是消息的载体，Message设计成为Parcelable类的派生类，这表明Message可以通过binder来跨进程发送。通常我们都会用obtain()方法去创建Message，如果消息池中有Message有，则取出，没有，再重新创建。这样可以防止对象的重复创建，节省资源。 “铃铃铃…”小Message接到了一个陌生男子的电话。“我叫handler，来自activity大本营，是你这次任务的接受者，一会我带你去首都的消息中心去报道。” Handler来自Activity大本营Handler部门是整个消息机制系统的核心部门，当然部门下有很多个 Handler，这次协助小Message任务的叫mHandler。Handler部门下的员工都有一个特点，就是只关心自己的message。 Handler属于Activity，创建任何一个Handler都属于重写了Activity中的Handler。 在Handler的构造中，默认完成了对当前线程Looper的绑定，至于Looper是谁，一会再谈。 通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过mLooper.mQueue获取了Looper中的MessageQueue实例。在此时，mhandler实例与looper和messageQueue实例，关联上了。 mHandler神情骄傲得对小Message说：我已经跟首都的消息中心打好了招呼，准备接收你了，现在有两种车，一种车名叫“send”，一种叫“post”，你想坐哪辆去首都都可以，不过要根据你上司的命令，选择车种类下对应的型号哦~ send post 从代码的实现上来看，post方法也是在使用send类的方法在发送消息，只是他们的参数要求是Runnable对象。 通过对Handler源码的分析，发现除了sendMessageAtFrontOfQueue方法之外，其余任何send的相关方法，都经过层层包装走到了sendMessageAtTime方法中，我们来看看源码： 这时小Message和mHandler一同上了车牌号为“sendMessage”的车，行驶在一条叫“enqueueMessage”的高速公路上，mHandler向一无所知的小Message介绍说，每个像他一样的Message都是通过enqueueMessage路进入MessageQueue的。我们是要去首都的MessageQueue中心，其实你的消息到时候也是我处理的，不过现在还不是时候哦，因为我很忙。 enqueueMessage是MessageQueue的方法，用来将Message根据时间排序，放入到MessageQueue中。其中msg.target = this，是保证每个发送Message的Handler也能处理这个Message。 Looper路上的时间不短不长，mHandler依然为小Message热心介绍着MessageQueue和Looper“在每个驻扎地（线程）中，只有一个MessageQueue和一个Looper，他们两个是相杀相爱，同生共死的好基友，Looper是个跑不死的邮差，一直负责取出MessageQueue中的Message”“不过通常只有首都（主线程）的Looper和MessageQueue是创建好的，其他地方需要我们人为地创建哦~” Looper类提供了prepare方法来创建Looper。可以看到，当重复创建Looper时，会抛出异常，也就是说，每个线程只有一个Looper。 紧接着在Looper的构造方法中，又创建了与它一一对应的MessageQueue，既然Looper在一个线程中是唯一的，所以MessageQueue也是唯一的。 在Android中，ActivityThread的main方法是程序的入口，主线程的Looper和MessageQueue就是在此时创建的。 可以看到，在main方法中，既创建了Looper，也调用了Looper.loop()方法。 mHandler和小Message通过enqueueMessage路来到了MessageQueue中，进入之前，门卫仔仔细细地给小Message贴上了以下标签：“mHandler负责带入”“处理时间为0ms”并且告诉小Message，一定要按照时间顺序排队。进入队伍中，Looper大哥正在不辞辛劳的将一个又一个跟小Message一样的士兵带走。 分析一下loop方法，有一个for的死循环，不断地调用queue.next方法，在消息队列中取Message。并且在Message中取出target，这个target其实就是发送消息的handler，调用它的dispatchMessage方法。 首都的MessageQueue中心虽然人很多，但是大家都井井有条的排着队伍，Looper老哥看了一眼手里的名单，叫到了小Message的名字，看了一眼小Message身上的标签，对他说：“喔，又是mHandler带来的人啊，那把你交给他处理了” 忐忑不安的小Message看到了一个熟悉的身影，mHandler就在面前，显然mHandler有些健忘，可能是接触了太多跟小Message一样的人，为了让mHandler想起自己，小Message说出了上司交给他的暗号0. 可以看见dispatchMessage方法中的逻辑比较简单，具体就是如果mCallback不为空，则调用mCallback的handleMessage()方法，否则直接调用Handler的handleMessage()方法，并将消息对象作为参数传递过去。 在handlerMessage()方法中，小Message出色的完成了自己的任务。 写在后面： 下一篇中，我们会探讨一下为什么loop方法中for死循环不会造成ANR，有一些有关Handler的使用技巧，以及可能造成的内存泄漏，敬请期待。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"}]},{"title":"5分钟实现Android中更换头像功能","slug":"5分钟实现Android中更换头像功能","date":"2016-07-28T02:16:11.761Z","updated":"2016-07-28T02:17:14.258Z","comments":true,"path":"2016/07/28/5分钟实现Android中更换头像功能/","link":"","permalink":"http://yoursite.com/2016/07/28/5分钟实现Android中更换头像功能/","excerpt":"5分钟实现Android中更换头像功能写在前面：更换头像这个功能在用户界面几乎是100%出现的。通过拍摄照片或者调用图库中的图片，并且进行剪裁，来进行头像的设置。功能相关截图如下：","text":"5分钟实现Android中更换头像功能写在前面：更换头像这个功能在用户界面几乎是100%出现的。通过拍摄照片或者调用图库中的图片，并且进行剪裁，来进行头像的设置。功能相关截图如下： 下面我们直接看看完整代码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class UserActivity extends BaseActivity implements OnClickListener &#123; private ImageView iv_photo; private Bitmap head;// 头像Bitmap private static String path = &quot;/sdcard/myHead/&quot;;// sd路径 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); initListener(); &#125; private void initView() &#123; setContentView(R.layout.activity_user); iv_photo = (ImageView) findViewById(R.id.iv_photo); Bitmap bt = BitmapFactory.decodeFile(path + &quot;head.jpg&quot;);// 从SD卡中找头像，转换成Bitmap if (bt != null) &#123; @SuppressWarnings(&quot;deprecation&quot;) Drawable drawable = new BitmapDrawable(bt);// 转换成drawable iv_photo.setImageDrawable(drawable); &#125; else &#123; /** * 如果SD里面没有则需要从服务器取头像，取回来的头像再保存在SD中 * */ &#125; &#125; private void initListener() &#123; iv_photo.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.iv_photo:// 更换头像 showTypeDialog(); break; &#125; &#125; private void showTypeDialog() &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); final AlertDialog dialog = builder.create(); View view = View.inflate(this, R.layout.dialog_select_photo, null); TextView tv_select_gallery = (TextView) view.findViewById(R.id.tv_select_gallery); TextView tv_select_camera = (TextView) view.findViewById(R.id.tv_select_camera); tv_select_gallery.setOnClickListener(new OnClickListener() &#123;// 在相册中选取 @Override public void onClick(View v) &#123; Intent intent1 = new Intent(Intent.ACTION_PICK, null); intent1.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;); startActivityForResult(intent1, 1); dialog.dismiss(); &#125; &#125;); tv_select_camera.setOnClickListener(new OnClickListener() &#123;// 调用照相机 @Override public void onClick(View v) &#123; Intent intent2 = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); intent2.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(Environment.getExternalStorageDirectory(), &quot;head.jpg&quot;))); startActivityForResult(intent2, 2);// 采用ForResult打开 dialog.dismiss(); &#125; &#125;); dialog.setView(view); dialog.show(); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; cropPhoto(data.getData());// 裁剪图片 &#125; break; case 2: if (resultCode == RESULT_OK) &#123; File temp = new File(Environment.getExternalStorageDirectory() + &quot;/head.jpg&quot;); cropPhoto(Uri.fromFile(temp));// 裁剪图片 &#125; break; case 3: if (data != null) &#123; Bundle extras = data.getExtras(); head = extras.getParcelable(&quot;data&quot;); if (head != null) &#123; /** * 上传服务器代码 */ setPicToView(head);// 保存在SD卡中 iv_photo.setImageBitmap(head);// 用ImageView显示出来 &#125; &#125; break; default: break; &#125; super.onActivityResult(requestCode, resultCode, data); &#125; /** * 调用系统的裁剪功能 * * @param uri */ public void cropPhoto(Uri uri) &#123; Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); // aspectX aspectY 是宽高的比例 intent.putExtra(&quot;aspectX&quot;, 1); intent.putExtra(&quot;aspectY&quot;, 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(&quot;outputX&quot;, 150); intent.putExtra(&quot;outputY&quot;, 150); intent.putExtra(&quot;return-data&quot;, true); startActivityForResult(intent, 3); &#125; private void setPicToView(Bitmap mBitmap) &#123; String sdStatus = Environment.getExternalStorageState(); if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) &#123; // 检测sd是否可用 return; &#125; FileOutputStream b = null; File file = new File(path); file.mkdirs();// 创建文件夹 String fileName = path + &quot;head.jpg&quot;;// 图片名字 try &#123; b = new FileOutputStream(fileName); mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, b);// 把数据写入文件 &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; // 关闭流 b.flush(); b.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 再添加以下权限 1234&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; Dialog的xml文件如下： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;TextView android:id=&quot;@+id/tv_select_gallery&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;20dp&quot; android:text=&quot;从图库中选取&quot; android:textColor=&quot;#000&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:background=&quot;#000&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_select_camera&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;20dp&quot; android:text=&quot;拍摄照片&quot; android:textColor=&quot;#000&quot; android:textSize=&quot;20sp&quot; /&gt;&lt;/LinearLayout&gt; 代码的注释还算全面，仔细阅读一定能看懂，大家可以试试这个demo~这样一个更换头像的功能就实现了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"}]},{"title":"Android消息机制字典型探究（二）","slug":"Android消息机制字典型探究（二）","date":"2016-07-28T02:14:33.902Z","updated":"2016-07-28T02:15:31.436Z","comments":true,"path":"2016/07/28/Android消息机制字典型探究（二）/","link":"","permalink":"http://yoursite.com/2016/07/28/Android消息机制字典型探究（二）/","excerpt":"Android消息机制字典型探究（二）写在前面：Android消息机制字典型探究（一）为了完成整个Android消息机制的探究，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中不允许子线程更新UI的原因，是由于线程安全的问题。当然我们目前分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：实践去发现问题，全面的理解问题，寻找最优解。Android本身就是一个复杂而有机的整体，由一个知识点可以牵出一条知识线。从而构成相关的知识体系。","text":"Android消息机制字典型探究（二）写在前面：Android消息机制字典型探究（一）为了完成整个Android消息机制的探究，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中不允许子线程更新UI的原因，是由于线程安全的问题。当然我们目前分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：实践去发现问题，全面的理解问题，寻找最优解。Android本身就是一个复杂而有机的整体，由一个知识点可以牵出一条知识线。从而构成相关的知识体系。这种学习方式会让你知道的越来越多，也能站在一定的高度上体会Android在设计之时的巧妙，全局的理解Android，做到融会贯通。也能在你的代码中，收获很多有益的启发。 说完以上这些，就可以正式开始本文的话题了。既然在我们只可以在主线程更新UI，那解决这个问题，一共有几种方式呢？我就来直接告诉大家，解决子线程更新UI问题的方式，一共有三种。 runOnUiThread 简单讲解一下代码，点击crash按钮，开启一个子线程，显然我们在子线程中直接给 iv_handler设置一张图片，是肯定崩溃的。当我们调用runOnUiThread方法，并且传入一个Runnable对象，并且在其中设置更新UI的逻辑，问题就解决了。相信你也和我一样对此非常好奇，那就赶紧点进去看看，源码中是如何实现的吧！ 先来翻译一下这段注释： 在UI线程中执行该Runnable. 如果当前线程是UI线程,那么该Runnable会立即执行. 如果当前的线程不是UI线程则调用UI线程handler的post()方法将其放入UI线程的消息队列中. *注意:勿在runOnUiThread(Runnable runnable)中做耗时操作 首先我想说明的是，runOnUiThread方法是属于Activity的，也就是说我们能拿到Activity才能使用该方法。我们本文的这个例子，明显是执行了mHandler.post(action)方法。我们目前不去研究handler.post方法，因为一会你就知道为什么了。再来看看第二种解决问题的办法。 view.post 代码跟上一个解决办法如出一辙，我们还是来看看源码，分析一下这个方法的实现方式。 先来翻译一下注释的意思： 将Runnable对象添加到message queue中，并且这个runnable对象会跑在UI线程中。 翻译完注释再来看代码，当View和Activity完成attach操作时，会产生一个attachInfo参数，在attachInfo参数中取出来了属于activity的mHandler，仍然去调用了mHandler.post(action)方法。也就是说无论我们是选择第一种方法还是第二种方法去解决这个崩溃问题，都是殊途同归的，最后经过层层封装，都走到了handler.post方法中。 handler.post 啊哈哈，我们连载通篇的主角Handler今天终于正式登场了，没错上面的代码就是将子线程的消息发送到主线程并处理的标准写法。等等，post方法在哪里？别着急，在本篇文章中，我并不打算给大家展开整个Handler知识体系的研究。我们先来看看post方法调用层级 可以看到，方法的调用顺序为post–sendMessageDelayed–sendMessageAtTime. 在本文中我们不再继续深究下去，未来我会对这些方法的调用层级、顺序、以及使用场景为大家进行一下完整地整理总结，本文不再赘述。 想强调的是：其实在这篇博客的目的：1.从解决问题并寻找方法的角度引出Handler，真正开启Handler的知识体系。 2.思考问题，解决问题的过程。回首第一篇文章中，我因为在子线程更新UI而造成了崩溃，然后： 在寻找解决办法之前，带着强烈的好奇心，去寻找了为何不能在子线程更新UI原因。在这个过程中，我理解了什么线程安全，深入理解了Context。 去寻找解决问题的所有办法（三种），并且去探究了这几种方法的原理，试图选择在本例中的最优解（事实上这几种方法本质上没区别）。 将问题简单化，所有问题的解决办法都指向了Handler，所以我们只需要探究Handler即可。 写在最后： 很多初学者认为Handler就是为了解决子线程更新UI的问题而存在的，事实上这种理解是错误的。Handler作为Android的线程间通信的机制，意义远不止此。下一篇中，Melo将带大家真正的理解Android的消息机制。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"}]},{"title":"Android消息机制字典型探究（一）","slug":"Android消息机制字典型探究（一）","date":"2016-07-28T02:12:46.236Z","updated":"2016-07-28T02:13:51.407Z","comments":true,"path":"2016/07/28/Android消息机制字典型探究（一）/","link":"","permalink":"http://yoursite.com/2016/07/28/Android消息机制字典型探究（一）/","excerpt":"Android消息机制字典型探究（一）子线程为啥不能更新UI？写在前面：看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了Handler这个单词，关于这个知识点，几乎是面试必问的问题，重要程度不言而喻。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚Android的消息机制。","text":"Android消息机制字典型探究（一）子线程为啥不能更新UI？写在前面：看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了Handler这个单词，关于这个知识点，几乎是面试必问的问题，重要程度不言而喻。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚Android的消息机制。既然没有了篇幅限制，自然可以全面的去讲一讲有关Handler的一切，我先来说说当时是怎么接触到Handler这个类的。 在我自学Android过程中，写了一个访问网络请求图片并显示的Demo，在子线程中我直接给ImageView设置了图片，造成了崩溃。崩溃信息如下： Only the original thread that created a view hierarchy can touch its views. 这个错误信息在字面上翻译过来就是：只有创建视图层级的原始线程，有权利处理它的视图。说白了，就是我们经常说的“子线程不能更新UI”。这句话体现了主线程在处理视图上具有唯一权力，这也就是为什么主线程也可以称为UI线程。 在解决这个崩溃问题之前，我对Android中子线程不能更新UI产生了非常大的好奇心。 Google如此设计的原因是什么呢？ 表象我们先从表象上分析一下，假设可以在子线程更新UI，会产生那些后果呢？如果不同的线程控制同一块UI，因为时间的延时性，网络的延迟性，很有可能界面图像会乱套，会花掉。而且出了问题也非常不容易排查问题出在了哪里。从硬件上考虑，每个手机只有一个显示芯片，根本上不可能同时处理多个绘制请求)，减少更新线程数，其实是提高了更新效率。 本质如果可以并发的更新UI，事实上是 “is not thread safe”的，也就是线程不安全。我们都知道，线程安全问题其实就是，不同的线程对同一块资源的调用。在更新UI的同时，会涉及context资源的调用，所以产生了线程安全问题。 相关阅读： 你足够了解Context吗？ 所以在Android中是不允许在子线程更新UI的、 本文开了一个小头，在下一篇中，将讨论如何解决本文中的崩溃问题。卖个关子，一共有三种方式哦，敬请期待~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"},{"name":"思路","slug":"思路","permalink":"http://yoursite.com/tags/思路/"}]},{"title":"Android中Fragment数据保存和恢复","slug":"Android中Fragment数据保存和恢复","date":"2016-07-27T14:13:44.702Z","updated":"2016-07-27T14:14:48.892Z","comments":true,"path":"2016/07/27/Android中Fragment数据保存和恢复/","link":"","permalink":"http://yoursite.com/2016/07/27/Android中Fragment数据保存和恢复/","excerpt":"Android中Fragment数据保存和恢复写在前面：上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：Android中Activity数据的保存和恢复","text":"Android中Fragment数据保存和恢复写在前面：上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：Android中Activity数据的保存和恢复一句话总结： 临时数据对于临时数据，我们使用onSaveInstanceState方法进行保存，并且在onCreate方法中恢复。 永久数据对于持久性数据，我们要在onPause方法中进行存储，但是要注意，onPause方法中不能进行大量操作，会影响其他Activity进入任务栈栈顶。 ps：在Activity中弹出一个当前Activity的Dialog并不会有任何生命周期方法调用（以前我曾以为会调用onPause方法）。因为Dialog作为一个View本身就是属于当前Activity的，Activity并没有失去焦点。 ok，完成了回顾，下面来开始本篇博客： Fragment在我们的项目中真的太实用和常见了，它的使用频率和数量甚至超过了Activity，所以本文目的是探究Fragment的数据保存和恢复。 在开始讲解之前，你应该对Fragment的生命周期方法有一定了解，推荐给大家一篇博客，我认为不错： Fragment生命周期方法详解 准备工作做了这么多，下面我们正式开始吧！ 本文直接选用了《第一行代码》中Fragment模块的讲解例子，点击下面的按钮分别跳转这四个Fragment。为了方便观察，我重写了Fragment所有生命周期方法和onSaveInstanceState方法，并打印了Log。 我们目的是探究Fragment数据的保存和恢复，在这里我把它分为两大类的情况： 单个Fragment遭遇一些突发情况 Fragment之间相互的切换或覆盖 在此之前，先引入一个返回栈的概念。我想你应该知道返回栈是什么，并且你以前接触的应该是保存Activity的返回栈，类比Activity，Fragment返回栈其实是保存Fragment的栈结构。区别在于：Fragment的返回栈由Activity管理；而Activity的返回栈由系统管理。 在未修改之前，本文添加并切换Fragment的方式都是在返回栈中仅有一个 fragment： 不要心急，过一会再说怎么去在返回栈中压入多个fragment，我们先来处理只有一个的情况 单个Fragment遭遇突发情况 仍然是用以下突发情况进行测试： 点击back键 点击锁屏键 点击home键 其他APP进入前台 启动了另一个Activity 屏幕方向旋转 APP被Kill 不过与上篇博客不同的是，我们在清单文件中，给Activity做了如下配置： 这么做的目的是当屏幕方向发生改变的时候，fragment所依附的Activity并不会重新销毁再创建，让情况相对简单一点。 测试结果： 当一个fragment孤零零地呆在返回栈时，它所处的情况与Activity如出一辙。类比Activity对数据的保存和恢复，我们可以对此得出结论： 临时数据 对于临时数据，我们使用onSaveInstanceState方法进行保存，并且在onCreateView方法中恢复（请注意是onCreateView）。 永久数据 对于持久性数据，我们要在onPause方法中进行存储。 Fragment之间的相互切换或覆盖当返回栈中保证只有一个Fragment，相互切换时，生命周期方法的调用是怎样的呢？例如本例中，从fragment03切换到fragment04： 可以看到，上述的这种情况，两个fragment从创建到销毁，经历了所有的生命周期方法。 如果返回栈中fragment的数量为多个呢？首先在切换时，加上以下代码，保证将fragment放入返回栈中： 使用addToBackStack方法，就能将fragment放入相应的返回栈中去了，从表象上来看区别在于进入其他fragment时，点击back键时，可以返回上一个fragment。这时候切换时，生命周期方法就是如何调用的呢？ 对比这两张生命周期方法的图，能得出两个结论。 1.无论任务栈中fragment数量为多少，onSaveInstanceState方法都没有调用 2.当fragment任务栈中有多个fragment时，进入下一个fragment时，并不会销毁fragment实例，而是仅仅销毁视图，最终调用的方法为onDestoryView。 所以此时我们要去保存临时数据，并不能仅保存在onSaveInstanceState中（因为它可能不会调用），还应该在onDestoryView方法中进行保存临时数据的操作，源码如下： 因为没有了系统提供的bundle参数，我们选择把数据保存在Arguments中，代码就不带着大家一步一步的看了，因为逻辑并不复杂，挺好理解的。通过这种方式，我们就挺容易的将临时数据和fragment的一些状态保存进bundle中并在需要时恢复了。 不知不觉本篇文章就要结束了，感兴趣的可以尝试当调用ft.add()方式去添加fragment时，生命周期方法又是怎样调用的呢？ 结束之前我们来一句话总结下本文：Fragment对临时数据的保存，仅仅依靠onSaveInstanceState方法是不行的，还需要在onDestoryView中进行相应操作，具体参考上面的代码。 Fragment中对于一些持久性的数据，仍应在onPause中保存。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"},{"name":"数据","slug":"数据","permalink":"http://yoursite.com/tags/数据/"}]},{"title":"5分钟打造Android一键退出功能","slug":"5分钟打造Android一键退出功能","date":"2016-07-27T14:11:36.057Z","updated":"2016-07-27T14:12:25.272Z","comments":true,"path":"2016/07/27/5分钟打造Android一键退出功能/","link":"","permalink":"http://yoursite.com/2016/07/27/5分钟打造Android一键退出功能/","excerpt":"5分钟打造Android一键退出功能写在前面：当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个一键退出功能。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个BaseActivity管理所有启动的Activity。","text":"5分钟打造Android一键退出功能写在前面：当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个一键退出功能。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个BaseActivity管理所有启动的Activity。下面给出完整的BaseActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.LinkedList;import java.util.List;import android.app.Activity;import android.os.Bundle;public abstract class BaseActivity extends Activity &#123; // 管理运行的所有的activity public final static List&lt;BaseActivity&gt; mActivities = new LinkedList&lt;BaseActivity&gt;(); public static BaseActivity activity; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); synchronized (mActivities) &#123; mActivities.add(this); &#125; init(); &#125; private void init() &#123; initViews(); initData(); &#125; /** * 初始化Views */ public abstract void initViews(); /** * 初始化数据 */ public void initData() &#123; &#125; @Override protected void onResume() &#123; super.onResume(); activity = this; &#125; @Override protected void onPause() &#123; super.onPause(); activity = null; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); synchronized (mActivities) &#123; mActivities.remove(this); &#125; &#125; /** * 一键退出的方法 */ public void killAll() &#123; // 复制了一份mActivities 集合 List&lt;BaseActivity&gt; copy; synchronized (mActivities) &#123; copy = new LinkedList&lt;BaseActivity&gt;(mActivities); &#125; for (BaseActivity activity : copy) &#123; activity.finish(); &#125; // 杀死当前的进程 android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 代码分析：在项目中的所有的Activity，都继承于BaseActivity，在onCreate方法中，将这个Activity add进LinkedList中（这里选择用LinkedList是因为它增删快，适合于这个场景中），在onDestory方法中将这个Activity remove掉，这样就保证每一个启动了的Activity都存于集合LinkedList中。 然后我们写一个killAll方法，复制这个集合并且遍历退出，你可以在任何地方调用这个方法，这样我们的一键退出功能就完美实现了~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"},{"name":"退出","slug":"退出","permalink":"http://yoursite.com/tags/退出/"}]},{"title":"Android中突发情况Activity数据的保存和恢复","slug":"Android中突发情况Activity数据的保存和恢复","date":"2016-07-27T14:10:07.840Z","updated":"2016-07-27T14:11:04.501Z","comments":true,"path":"2016/07/27/Android中突发情况Activity数据的保存和恢复/","link":"","permalink":"http://yoursite.com/2016/07/27/Android中突发情况Activity数据的保存和恢复/","excerpt":"Android中突发情况Activity数据的保存和恢复写在前面：在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。","text":"Android中突发情况Activity数据的保存和恢复写在前面：在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。 突发情况都有哪些？因为本文讨论的是当一些突发情况的出现时，对数据的保存和恢复。所以现在总结一下突发情况应该都有哪些？ 点击back键 点击锁屏键 点击home键 其他APP进入前台 启动了另一个Activity 屏幕方向旋转 APP被Kill 当这些突发情况发生的时候，有哪些关键的方法会被调用呢？ 写了一个简单的demo，我用上述的突发情况进行测试，代码中我重写了所有Activity的生命周期方法和onSaveInstanceState方法，并打印对应的log在控制台，下面是demo图： 这里就不贴出测试的过程了，直接来告诉大家测试的结果吧： 当我的APP处在前台，能与用户交互的情况下，出现上述的突发事件时，只有点击back键，onSaveInstanceState方法不会调用。其余的情况下， 该方法一律都会调用，这又是为什么呢？并且onPause方法是必然会调用的，这又给我们保存数据提供了怎样的思路呢？ onSaveInstanceState好吧，相信当你看到本文标题的时候，你就应该想到了这个方法。因为当我们学习Android基础知识时，用onSaveInstanceState方法进行数据恢复是你必然学到过的。所以前面我营造出的一些悬念看似是失败了，不过对于onSaveInstanceState你理应知道更多知识： 何时调用： &gt; Android calls onSaveInstanceState() before the activity becomes vulnerable to being destroyed by the system, but does not bother calling it when the instance is actually being destroyed by a user action (such as pressing the BACK key) 找到了以上一段话，翻译过来就是当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的，例如当用户按BACK键的时候。 结合我们以上的例子，其实都在说明一个词，就是**被动**。当Activity并不是由我主动点击back键而丧失焦点时，onSaveInstanceState方法就一定会调用。就例如我上述列举的那些除了点击back键的“**突发情况**”。 何地调用： 在我写的这个demo中，onSaveInstanceState的调用是处于onPause和onStop之间的，（下面关于Activity的生命周期方法，会讲解一些值得大家注意的），我查阅了一下资料，能保证的是onSaveInstanceState方法会在onStop之前调用，但是是否在onPause之前就不一定了。 结论： google工程师们对onSaveInstanceState如此设计就是让其完成对一些临时的、非永久数据存储并进行恢复。什么样的数据属于临时数据呢？举个例子，比如EditText中输入的内容，CheckBox是否勾选，ScrollView的滑动位置，目前视频的播放位置等等。 当我还没有自学Android时，玩着一些APP就会产生一个疑问，比如我在一个输入框中输入了大量文字没有提交或者保存。此时来了一个电话，如果退回的时候，输入框里面的文字消失了，那我可能会砸了电话，所以这个保存数据的操作，是Android开发者做的吗？ 然而是不需要的，因为Android的View本身自己就实现了onSaveInstanceState方法，这些控件自己就具有保存临时数据和恢复临时数据的能力。 例如TextView中的部分源码： 其他View控件都有相似的实现原理。值得一提的是，只有当你给这个wiget在xml中指定id时，它才具有保存数据并且恢复的能力，并且不同的wiget还不能共用这个id，否则会出现数据覆盖的情况。具体的源码有兴趣大家可以自己去看，这里因为篇幅的原因不再贴出，关于onSaveInstanceState我们先说这些，赶紧看看使用姿势。 onSaveInstanceState的使用姿势比如我们要保存当前视频的播放进度，这个显然控件没有帮我们实现onSaveInstanceState，所以就只能靠自己了，代码如下所示。 当在onCreate取出临时数据时，记得加一个非空判断。 看到这里，也许你认为本文该就此结束了，不过在回过头看看，我们刚才一直强调的是临时数据，毕竟onSaveInstanceState本身就是为临时数据服务的，但是一些永久性质的数据，比如插入数据库的操作，我们应该在什么方法中对其进行保存呢？ onPause在介绍onPause方法之前，还是想聊聊Activity的生命周期方法，相信大家对它应该有了初步的了解，不过在相应的生命周期方法中，我们应该做什么操作呢？推荐给大家一篇文章，我觉得不错。 Activity生命周期详解 关于onPause，我找到了一下关于它的特性： onPause(), onStop(), onDestroy() are “killable after” lifecycle methods. This indicates whether or not the system can kill the process hosting the activity at any time after the method returns, without executing another line of the activity’s code. Because onPause() is the first of the three, once the activity is created, onPause() is the last method that’s guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience. 翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得onPause是持久化相关数据的最后的可靠时机。当然onPause方法不能做大量的操作，这会影响下一个Activity入栈。 刚才我们的测试结果还说明了一个道理，onSaveInstanceState并不是百分百调用的（比如点击了back键），显然一些永久性的数据，我们并不能在此中保存。 关于本文的结论就显而易见了，我们来一句话总结一下： 临时数据使用onSaveInstanceState保存恢复，永久性数据使用onPause方法保存。 下一篇准备给大家总结一下Fragment的数据保存和恢复，敬请期待哈~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"数据","slug":"数据","permalink":"http://yoursite.com/tags/数据/"},{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}]},{"title":"程序员必备简捷开发辅助工具总结","slug":"程序员必备简捷开发辅助工具总结","date":"2016-07-27T14:08:45.130Z","updated":"2016-07-27T14:09:43.507Z","comments":true,"path":"2016/07/27/程序员必备简捷开发辅助工具总结/","link":"","permalink":"http://yoursite.com/2016/07/27/程序员必备简捷开发辅助工具总结/","excerpt":"程序员必备简捷开发辅助工具总结写在前面：工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！","text":"程序员必备简捷开发辅助工具总结写在前面：工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！零：Notepad++Notepad++ 程序员必备的文本编辑器，软件小巧高效，支持27种编程语言，通吃C,C++ ,Java ,C#, XML, HTML, PHP,JS 等，推荐各位下载使用。Notepad++ 可完美地取代微软的记事本。相信这是每个程序员必备的工具，神器不解释！ Notepad++下载地址及使用说明： Notepad++中文版下载 一：XML Marker(xml查看编辑工具)XML Marker是国外的一款非常实用的xml查看编辑工具。软件功能强大，纯文本调试输出和日志文件，你可以有效增加修改你的程序才能产生XML格式他们的作用。你也可以使用XML标记的图形功能，以现场隐藏的趋势，并更快地解决你的错误。更多的功能包括表格排序，语法高亮编辑器和自动缩进，经常编辑XML文件的用户可以下载本软件使用。 XML Marker下载地址及使用说明： XML Marker(xml查看编辑工具) 下载 二：EverythingEverything是速度最快的文件搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具、Total Commander的搜索、Google 桌面搜索或百度硬盘搜索，如果正在使用或放弃了Locate32，都值得推荐这款体积小巧、免安装、免费、速度极快（比Locate32更快）的文件搜索工具Everything！ Everything下载地址及使用说明： Everything下载地址 三：MarkMan既有爱又给力的长度标注神器！设计师、重构、前端工程师必备。马克鳗是基于AdobeAIR平台的方便高效的标注工具，可方便地为设计稿添加标记，极大节省设计师在设计稿上添加和修改标注的时间。马克鳗使用起来也是非常简单，双击添加测量，单击改变横纵方向等等功能，基本都是一键完成。 markman下载地址及使用说明： MarkMan下载地址 四：HiJson使用HiJson工具并通过此工具快速查看JSON字符串、熟悉JSON的数据结构。针对程序员来说，如果了解了连续字符串对应的JSON的数据组成，便可以快速对JSON字符串进行数据处理。 Hijson下载地址及使用说明： HiJson64位下载地址 五：XMindXmind是一款全球领先的思维导图软件，除了可以轻松绘制基本逻辑图之外，还支持组织如结构图（竖直）、树状图（水平+竖直）、思维导图（辐射）、鱼骨图、二维图（表格）模型。在企业和教育领域都有很广泛的应用。Xmind Pro可以将您的图形显示给他人，或者将图形内容导出到MicrosoftPowerpoint、Word中，令复杂的思想和信息得到更快的交流。在企业中它可以用来进行会议管理、项目管理、信息管理、计划和时间管理、企业决策分析等，在教育领域，它通常被用于教师备课、课程规划、头脑风暴等。 Xmind下载地址及使用说明： XMind破解版下载 六：Beyond CompareBeyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。在使用git提交代码时，可以比较两个文件的不同之处，处理冲突，非常实用。 Beyond Compare下载地址及使用说明： Beyond Compare 七：金山词霸这个就不多解释了，类、变量的命名尽量不要使用拼音，遇到拿不准的单词，就使用金山词霸查询一下吧。 写在后面： 如果大家还有什么还用的辅助开发工具，请在下方留言哈，不断地补充分享~ 评论朋友们的补充（感谢） 八：Sublime Text程序员必备代码编辑器，几乎每位程序员提到Sublime Text都是赞不绝口!它体积小巧，无需安装，绿色便携;它可跨平台支持Windows/Mac/Linux;支持32与64位操作系统，它在支持语法高亮、代码补全、代码片段(Snippet)、代码折叠、行号显示、自定义皮肤、配色方案等所有其它代码编辑器所拥有的功能的同时，又保证了其飞快的速度!还有着自身独特的功能，比如代码地图、多种界面布局以及全屏免打扰模式等，这些优秀特性让Sublime Text 2成了所有程序员眼中的神! Sublime Text下载地址及使用说明： Sublime text下载链接和使用教程 九：ListaryListary 是一款非常优秀的 Windows 文件浏览和搜索增强工具，可以为你 Windows 的「文件浏览对话框」、「资源管理器」等增加非常方便的文件快速定位、实时全盘搜索、常用文件夹收藏、打开历史、快速切换到已打开的路径、快捷右键菜单等一系列非常非常实用和高效的功能。 Listary下载地址及使用说明： Listary 十：strokeplusstrokesplus是一个类似strokeit的鼠标手势软件。无须.net运行环境即可运行，只占用250-500kb内存。strokesplus支持脚本动作，提供了更为强大的可操控性。 下载地址及使用说明： strokeplusStrokesPlus下载 十一：source insightSource Insight 实质上是一个支持多种开发语言（java,c ,c++等等）的编辑器，只不过由于其查找、定位、彩色显示等功能的强大，而被我们当成源代码阅读工具使用 。所以，为了有效的阅读源程序，首先必须选择功能菜单上的“Project”选项的子菜单“New Project” 新建一个项目，项目名称可以自由选定，当然也可以选择删除（Remove）一个项目。当删除一个项目的时候，并不删除原有的源代码文件,只是将该软件生成的那些工程辅助文件删除。设定之后，将会弹出一个对话框如图2，接受默认选择，如果，硬盘空间足够，可以将第一个复选框选上，该选项将会需要与源代码大致同等的空间来建立一个本地数据库以加快查找的速度。 source insightSource Insight下载地址和使用说明 相关阅读： Android开发者需要阅读的博客总结 移动开发必备书单","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/经验/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/总结/"}]},{"title":"3分钟教会你如何看eclipse中的崩溃信息","slug":"3分钟教会你如何看eclipse中的崩溃信息","date":"2016-07-27T14:07:01.801Z","updated":"2016-07-27T14:07:47.934Z","comments":true,"path":"2016/07/27/3分钟教会你如何看eclipse中的崩溃信息/","link":"","permalink":"http://yoursite.com/2016/07/27/3分钟教会你如何看eclipse中的崩溃信息/","excerpt":"3分钟教会你如何看eclipse中的崩溃信息 本文原创，转载请注明出处，坚持长期原创博客，喜欢请加关注哦，你们支持就是我动力的源泉~","text":"3分钟教会你如何看eclipse中的崩溃信息 本文原创，转载请注明出处，坚持长期原创博客，喜欢请加关注哦，你们支持就是我动力的源泉~ 写在前面： 前一阵花了足足一周的时间去研究了Context的源码，发布出来一篇文章，我觉得写得已经OK了却反响平平。前天写了一个解析json的教程却得到很多朋友门点赞认可。说明还有相当一部分刚刚入行的朋友们希望得到一些相对初级的知识和技巧，话不多说，我来一点点的教大家看崩溃Log。 以后准备每周出一篇入门、一篇进阶博客~ 我相信很多初学者用的开发工具是Eclipse，并且很多初级书籍也不会教大家怎么去看崩溃日志，虽然不难，但是靠自己琢磨还是挺浪费时间的，我们就写一个Demo来看看吧！ 注释掉创建ViewHolder对象的代码，让程序崩溃。 这个Demo很简单，就是在MainActivity中展示一个ListView，《第一行代码》中的例子。现在我们注释掉了创建ViewHolder对象的代码，连上手机，运行程序，看看崩溃信息吧！ 看图片中黑色的箭头，左边的箭头指向自己的包名过滤器，表示只显示我这个应用的logcat，右边箭头把信息的等级过滤为error级别。 这时候我们进一步去缩小范围： 其实黑框中的信息就是我们最主要关心的，但是为什么要这两个地方的信息呢？ java.lang.xxxException，这个标明你的错误类型，如果没见过，用搜索工具搜一下，就能明白，在我们这个例子里是空指针异常。 第二个黑框是我们自己应用的包名（第31行出了问题），说明这个错误就是我们自己的代码导致的，双击可以进入java代码中，后面那些android.widget开头的崩溃信息是一些牵连信息，也是可以提供参考的。 这行报了空指针异常，分析一下，说明我们的ViewHolder没有创建对象。 写在后面： 其实本文例子中的错误并不复杂，看错误日志也是一个经验活。遇到崩溃要理清头绪，寻找错误位置，分析可能造成的原因，看得多了，也就慢慢会看了。 喜欢请加关注，最近应该会出产很多文章~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"别让培训机构毁了你这一辈子","slug":"别让培训机构毁了你这一辈子","date":"2016-07-27T14:03:58.812Z","updated":"2016-07-27T14:05:14.400Z","comments":true,"path":"2016/07/27/别让培训机构毁了你这一辈子/","link":"","permalink":"http://yoursite.com/2016/07/27/别让培训机构毁了你这一辈子/","excerpt":"本文转载，个人感觉观点有些偏激，不过有些思路绝对是对我有启发的。作为一个零基础自学一路走来的程序员，等有机会写写自己自学的经历吧。","text":"本文转载，个人感觉观点有些偏激，不过有些思路绝对是对我有启发的。作为一个零基础自学一路走来的程序员，等有机会写写自己自学的经历吧。 —-写给计算机专业的同学 我在北京摸爬滚打这么多年，也算是IT界的老人了，最近，经常有老家的同学打来电话。有位同学说他侄子高中快毕业了，成绩不太理想，只能考上一所三流大学。他听说北京有很多IT培训机构，而且孩子对电脑这方面比较感兴趣，而且他听说培训出来的学生在北京挣钱也不少。现在大学生找不到工作，所以想让孩子去培训机构学一门技术，早点挣钱。我回答他:如果你侄子是我侄子，那么我会坚决要让他考大学，上培训机构的话，孩子这一辈子就完了。另一位同学说他妹妹学计算机的，大学本科毕业，找不到工作，她们学校很多大专生去北京培训了4个月，找到了工作，而且工资还不低，所以他妹妹也想去培训机构，问我能不能给介绍一家好的。 我回答她：你家里条件不错的话，就让孩子继续学习，考个研究生。研究生毕业后会比较容易找工作。如果让你妹妹去培训机构，那么这大学4年就白读了，而且可能会毁了孩子。良药苦口忠言逆耳，我作为一个认真负责的人只能这么回答他们，我不想看到一个个活泼可爱，有理想，有追求，有感情的青少年被培训机构摧残，变成一只只痴呆、愚钝的人肉代码生成器，也就是我们所说的代码民工。因为我经历的、见过的太多了。我经历过2000年前后的网络泡沫，2009年的经济危机。2009年的时候北京的软件公司很少招人，甚至有些公司裁人，这对09届大学毕业生来说简直是刚迈入社会遭到的当头一棒。当时我所在的公司在面试的时候，只挑底子特别好，计算机基础理论掌握特别牢的新人，就是这么残酷。可能就是这种就业形势带动了IT培训业的发展。 就是那一年，各个机构的培训广告，各种培训的视频铺天盖地而来。我表弟也是学计算机的，正是09年毕业，很不幸赶上了经济危机，家里不富裕，也没有钱供他继续考研，一直没工作，压力也不小，问我能不能帮忙找个工作，工资低点也行，先干着。我和表弟一致保持着联系，所以我对他是比较了解的，大学基本上没怎么学，打了4年的魔兽，考试靠作弊，最终混到了文凭。有很多大学生大学玩了4年，上网，玩游戏，喝酒，泡妞。学编程不求甚解，不求精，毕业找不到工作，抱怨社会不给大学生机会，抱怨中国教育的落后，抱怨大学知识体系与实践脱轨。老是怨这怨那，把责任推给社会。我觉着大学整天玩，不努力，到最后找不到工作是应该的！找到工作才叫不正常！我家里的意思是让我救济一下亲戚，于是我就想办法，想办法帮表弟“挽回败局”，我心里深知，很多知识的获得是要经过努力，经过刻苦地钻研，有时候遇到问题解决不了，需要熬通宵硬啃，这是很孤独的过程，是没有捷径的，因为我的大学就是这么过来的，我身边的高手也都是这么过来的。现在表弟需要的是一剂“速效药”，能在短时间内“补上”之前欠缺的，快速找到工作。 后来我在 csdn上看到一则广告，看了看他们的课堂录像视频，感觉虽然水平不是很高，但是还凑合，比有些纯粹糊弄人的培训机构要强。我抱着侥幸心理报了名。我帮表弟交了8000元送他去了这个培训班。现在回想一下，那真是个错误的决定，让我后悔不已。当时，培训机构是新生事物，大家都不懂，后来我慢慢地看清了它的真实面目。这个培训班一共4个月的课程，实际上只有3.5个月，教授的内容也很基础。一个月讲基础，一个月讲框架，剩下时间讲项目。吹嘘他们的老师都是一些年薪百万的大师级别的人物，实际上只不过是一些过早“退役”的普通程序员，被他们吹大的。过了30岁混不下去的程序员(工程师)大有人在，有些人过不下去了，为了混口饭吃就去了培训机构当老师。简单的课程体系，当初被包装成何等华丽，充满各种专业词汇的广告，我当时还以为课程会有多丰富。后来没想到竟然是这种。我这样一个老IT人竟然能被一个小小培训机构忽悠倒，更不用说涉世不深的学生了。有些学生被忽悠了还帮人家数钱，还要像别人宣传这个培训机构有多好。我很佩服这些培训机构的忽悠功力真是深不可测，看来他们的主要精力都投入到了骗术的开发上而不是教学。而且这种骗是无懈可击的，你都没发去告他们。最后半个月的课程是面试辅导，后来我弄明白了，这个培训机构是教学生怎样去撒谎，怎样写假简历，怎样去边一些冠冕堂皇的说辞，怎样去骗用人单位，说白了就是教学生骗术！教学生怎样诈骗！我表弟告诉我以后，我立马让他退学了，剩下的学费我也没去要。因为我深知欺骗用人单位后果是多么严重，赶紧悬崖勒马。 后来我表弟给我一份他同学搞的课堂录屏，讲了一些OOA OOD UML 和设计模式的东西。偏重点就是一些很浮躁的东西，然后说出一些听上去很专业的话，来蒙骗用人单位。这些开发思想类的理念，没有个3年以上的开发经验，是搞不懂的，只能给初学者造成错误的认识。培训机构为了提高就业率，不惜用这种下三滥，不负责的方法教唆学生。要知道，简历造假一旦被公司查到，可以无条件即刻开除，至少我们公司是这样的，这是国家劳动法的规定。而且造假这段不光彩的经历会伴随着人一生，对以后工作可能都有影响。培训机构为了减轻学生的负罪感在课上公开鼓吹：”大不了查出来不干了就是了”，“你不这么干，别人也会这么干的”。给学生灌输错误的人生观。后来，我表弟按照我说的，用真实的简历，真实的经历，在一家外包公司找到了一份工作3000元。他的同学通过造假，诈骗找到了5000多的工作，而且据我表弟说，这些学生还不以为耻反以为荣。向别人炫耀他们是怎样用假冒简历，假冒经历欺骗用人单位，并且得手的，而且互相交流自创的骗术。后来，在qq上，我表弟说，有几个同学因为造假被公司开除了，干了不到一星期，也没给工资。再后来，表弟告诉我他同班同学去内培训的经历,内学完后感觉什么都会了，也没有造假，就是没找到工作，即使没找到工作，他们也说*内培训质量有多好，老师水平有多高。我很悲哀现在的大学生思维判断力为什么如此低下，像牛羊一样供骗子宰割，为什么没有一点甄别真伪的能力？为什么甘愿自己冒着被开除、留下不良记录的风险也要拼命给培训机构提高就业率？为什么自己受了骗还要帮着别人数钱？还要帮骗子宣传，说骗子的好？ 有一次，我面试一位初级IOS开发(IOS和Android实质就是写UI，这里提醒有追求，有理想的同学最好不要干这行，虽然工资不低)，他期望的工资比较高，我暗示他期望有点高，后来这哥们说了实话:他有一次在网上看到了一个IOS培训的广告，点了进去，为了得到一个视频教程，他留下了自己的手机号，后来一位工作人员联系上了他，在他的软磨硬泡下，这哥们决定去参加培训，后来得知培训费竟然要一万七，哥们家是农村，拿不出来，客服有说可以先学，学会了以后付款。只要签一个协议，他糊里糊涂签了字。后来才知道这实际上就相当于一个欠条。而且即使你找不到工作也必须还钱，培训机构不断催债，他只能东拼西借。一万七！用父母的血汗钱来参加培训！对一个面朝黄土背朝天的农民来说是一个不小的天文数字。他说工资太低的话，他每月还完债，剩下的钱在北京还不够交房租的。最后他没有被录用，期望工资太高，公司不可能为他的培训费买单。天底下竟然有如此之黑的培训机构！ 我表弟学的那家虽然也是骗，不过和这家比，可以说是骗得合理，骗得仁义！骗得有分寸！小巫见大巫！过了这么多年，我表弟也是快奔30的人了，依然干着最低级的工作，虽然他的职称是软件工程师，虽然他工资上万了，但是他本质上还是一个代码民工，没变。每天写着重复的代码，仍然是当初在培训班学的那些，每天坐在电脑前10多个小时，每天加班到很晚，靠透支体力，透支生命来换钱。又一次他问我为什么一个频繁删减的集合类变量要用链表？用数组不是一样吗？我告诉他这种问题去看大学数据结构课本。他说最近在公司干得很累，干不下去了，想考研，又不想去啃课本太麻烦，脑力不如以前了。我开始反思，当年我的决定是不是错的，如果表弟参加了培训，虽然迈不过30岁这个坎，但是这10年间起码有个谋生的工作干着。实际上能迈过30这个坎的程序员能有几个？大多数都被拍死在沙滩上了。 像我这样的毕竟是少数，我不是吹，本科的时候能把《c++ primer》读透的能有几个，研究生时候把linux内核源码整体啃一遍的能有几个？培训只能教一些花拳绣腿，真正的内功还得需要自己慢慢修炼。我后悔，当时其实我可以给表弟更多一些钱，供他读研究生，继续深造，当时为了省钱送他去培训，现在看是害了他。兄弟，当哥的真是对不起你。去年，有一天中午吃晚饭，有个小伙向我问路，我正好跟他顺路，我看他拿着一个透明文件袋，问他是不是要去面试，他说是，他问我干软件测试有没有前途，我问他是学什么的，他说机械，后来参加了测试培训。我很诚实地说，干软件测试没前途，但是可以找到一份工作，吃饱饭。看他很失望，我又说，干好了可以干测试经理。 很多人都说干软件的都是吃青春饭，没错，这种短期培训出来的学生都是短期催熟的，没有经过大自然的历练，没有经过痛苦的涅槃，没有真正的内功，只玩一些花拳绣腿自然混不长远。有人问我，培训的学生和自学成才的学生有什么区别？我问你，人工养殖的人参和野人参有什么区别？如果你现在刚毕业，没有工作。如果家里比较富裕，建议你读研，继续学习，把理论和技术学精。如果你家里不太富裕，揭不开锅了，可以选择去培训，或者找其他工作先挣钱。等找到工作后挣钱，有了钱可以选择继续深造，读研毕业后，找工作就相对比较容易，可以找个比较体面的工作。如果你大学4年没努力，想借培训这3、4个月来力挽狂澜那是不可能的，你首先要接受这个现实。“参加了我们的培训可以让你挽回败局，扭转乾坤。”这只是培训机构的宣传，就是为了随和你的这种心理，而且培训机构会极力鼓吹大学教育多么无用。很多看起来高大上的培训机构，实际上都是败絮其中，专门玩弄专业术语欺骗像学生这种涉世不深的群体。我说的这些都是真话，可能会遭到培训机构的群体攻击，但是我还是要说。实际上我在工作中用到的技术很多重要的思想都是在大学学到的，你们可以看看有没有清华北大毕业的学生，毕业之后成群结队地去培训机构“补习”。你们可以看看，那些大学没有好好学习，基础理论不扎实，毕业后问父母要一万多元的血汗钱去培训机构“补习”的都是些什么样的学生。 有人说人这一辈子，有三件大事得做好:(1)考大学。(2)找工作。(3)结婚。只要这三件事做好了，一辈子一帆风顺。希望要去培训机构学习的同学能擦亮双眼，三思而行，在人生的重要的岔路口选对方向。分清什么是真正的内功，什么是花拳绣腿；什么是可以做一辈子的事业，什么是青春饭。不要被虚幻的假象和诱惑迷住了双眼。 博主觉得无论是自学还是报名培训班，真正的去喜欢代码，热爱编写代码的过程才是最重要的，我是一名纯自学的野生程序员，等我整理整理思路，为大家写写我自学Android的经历。","categories":[{"name":"心路","slug":"心路","permalink":"http://yoursite.com/categories/心路/"}],"tags":[{"name":"培训","slug":"培训","permalink":"http://yoursite.com/tags/培训/"},{"name":"教训","slug":"教训","permalink":"http://yoursite.com/tags/教训/"}]},{"title":"5分钟让你学会用最高效的工具解析所有Json","slug":"5分钟让你学会用最高效的工具解析所有Json","date":"2016-07-27T14:02:25.426Z","updated":"2016-07-27T14:03:18.855Z","comments":true,"path":"2016/07/27/5分钟让你学会用最高效的工具解析所有Json/","link":"","permalink":"http://yoursite.com/2016/07/27/5分钟让你学会用最高效的工具解析所有Json/","excerpt":"5分钟让你学会用最高效的工具解析所有Json 原创博客，转载请经过本人允许，你们的点赞和关注是我长期写作的动力~","text":"5分钟让你学会用最高效的工具解析所有Json 原创博客，转载请经过本人允许，你们的点赞和关注是我长期写作的动力~ 如果你是一个Android开发工程师，学会解析Json字符串是你的必修课，本篇文章主要以实例的方式手把手教你怎么做，花五分钟时间阅读本篇文章你就可以学会解析所有的Json字符串啦。 准备： json字符串 fastjson HiJson格式化json工具 开始教程： fastjson： 常用工作中解析json的工具类有谷歌的GSON，jackson，fastjson，这里就不做一一比较了，博主告诉大家，fastjson就是最高效最好用的，选它就没错了。FastJson出自阿里工程师之手，是一个Json处理工具包，包括“序列化”和“反序列化”两部分，它具备如下特征： 速度最快，测试表明，fastjson具有极快的性能，超越任其他的Java Json parser。包括自称最快的JackJson，是GSON解析速度的6倍； 功能强大，完全支持Java Bean、集合、Map、日期、Enum，支持范型，支持自省；无依赖，能够直接运行在Java SE 5.0以上版本；支持Android；开源 (Apache 2.0) 下载地址： [fastjson jar包下载地址](http://download.csdn.net/detail/pdsyzbaozi/8199419) HiJson： HiJson是一个将 json 字符串格式化的工具，非常好用，让你的json字符串结构一目了然，并且可以直接复制键值，强烈推荐！ 下载地址： HiJson下载地址 Fastjson API入口类是com.alibaba.fastjson.JSON，常用的序列化操作都可以在JSON类上的静态方法直接完成。 12345678public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject public static final T parseObject(String text, Class clazz); // 把JSON文本parse为JavaBean public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray public static final List parseArray(String text, Class clazz); //把JSON文本parse成JavaBean集合 public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本 public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray。 如果你从没解析过json，看不太明白没关系，现在我上面那个json字符串，手把手的教你怎么解析，学会解析这个较复杂的json串，相信其他的你也肯定也会解析了。 json串提供给大家拿去练手 12345678910111213141516171819202122232425262728293031&#123; &quot;status&quot;: &quot;2000&quot;, &quot;msg&quot;: &quot;Successful!&quot;, &quot;data&quot;: [&#123; &quot;details&quot;: [&#123; &quot;distance&quot;: 2847, &quot;nextLat&quot;: 39.994076, &quot;nextLong&quot;: 116.47764, &quot;nexti&quot;: &quot;MeloDev&quot;, &quot;status&quot;: 4 &#125;], &quot;distance&quot;: 2847, &quot;imageUrl&quot;: &quot;&quot;, &quot;overview&quot;: &quot;长期原创Android博客&quot;, &quot;source&quot;: &quot;http://www.jianshu.com/users/f5909165c1e8/latest_articles&quot;, &quot;status&quot;: &quot;SUCCESSFUL&quot; &#125;, &#123; &quot;details&quot;: [&#123; &quot;distance&quot;: 2769, &quot;nextLat&quot;: 39.97691, &quot;nextLong&quot;: 116.46019, &quot;nexti&quot;: &quot;MeloDev&quot;, &quot;status&quot;: 4 &#125;], &quot;distance&quot;: 2769, &quot;imageUrl&quot;: &quot;&quot;, &quot;overview&quot;: &quot;喜欢请加关注&quot;, &quot;source&quot;: &quot;http://www.jianshu.com/users/f5909165c1e8/latest_articles&quot;, &quot;status&quot;: &quot;SUCCESSFUL&quot; &#125;]&#125; 好的万事俱备，马上就开始！ 把下载的fastjson的两个jar包导入libs目录下： 现在开始比较关键的一步，新建一个bean对象，去作为json解析之后的载体，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class QueryResultInfo &#123; public String status; public String msg; public List&lt;DataList&gt; data; public class DataList &#123; public int distance; public String imageUrl; public String overview; public String source; public String status; public List&lt;DetailsList&gt; details; @Override public String toString() &#123; return &quot;DataList [distance=&quot; + distance + &quot;, imageUrl=&quot; + imageUrl + &quot;, overview=&quot; + overview + &quot;, source=&quot; + source + &quot;, status=&quot; + status + &quot;, details=&quot; + details.toString() + &quot;]&quot;; &#125; public class DetailsList &#123; public int distance; public double nextLat; public double nextLong; public String nexti; public int status; @Override public String toString() &#123; return &quot;DetailsList [distance=&quot; + distance + &quot;, nextLat=&quot; + nextLat + &quot;, nextLong=&quot; + nextLong + &quot;, nexti=&quot; + nexti + &quot;, status=&quot; + status + &quot;]&quot;; &#125; &#125; &#125; @Override public String toString() &#123; return &quot;QueryResultInfo [status=&quot; + status + &quot;, msg=&quot; + msg + &quot;, data=&quot; + data.toString() + &quot;]&quot;; &#125;&#125; 我来告诉大家，写一个解析json之后bean对象的技巧。首先观察json格式化的结果（HiJson工具右侧视图），java代码中： 数据的类型、键的名称都必须与json字符串保证一一对应也就是例子中，每个变量都是以json的键名称命名的，不能写错，而且数据类型也必须对应，String就是String，int就是int，float就是float 如果出现嵌套的数组，就写一个内部类，用同样的方式命名各个json字段，用List接收它，注意List的命名也得是用json中的键名。多层嵌套以此类推。 所有变量的访问域都是public的。 好了bean对象就完成了。 我把json字符串存在了String.xml下，点击按钮之后，解析json字符串，layout文件很简单，这里就不放出了。 可以看到，我们调用JSON.parseObject(myJson,AppInfo.class)这一行代码，我们就把json字符串的所有信息都解析到了appInfo对象中，想用什么就直接取出来就可以了。 这个json字符串相对还是复杂的，多层嵌套，所以这个你都会了，简单的你也肯定没问题了，当然fastjson的强大不止于此，如果有特殊需要，再慢慢发掘吧~！ 喜欢请关注哦，未来要写一篇有关线程消息机制Handler的字典型博客，正在深入研究中！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"},{"name":"Json","slug":"Json","permalink":"http://yoursite.com/tags/Json/"}]},{"title":"Android开发必读博客","slug":"Android开发必读博客","date":"2016-07-27T14:00:40.817Z","updated":"2016-07-27T14:01:48.845Z","comments":true,"path":"2016/07/27/Android开发必读博客/","link":"","permalink":"http://yoursite.com/2016/07/27/Android开发必读博客/","excerpt":"Android开发者必须阅读的博客周末闲暇在家，为大家整理了一下Android开发者需要关注的博客、公众号等优秀的学习资源~ 博主长期坚持原创分享，喜欢请关注，转载请得到本人允许。","text":"Android开发者必须阅读的博客周末闲暇在家，为大家整理了一下Android开发者需要关注的博客、公众号等优秀的学习资源~ 博主长期坚持原创分享，喜欢请关注，转载请得到本人允许。 零：技术博客 郭霖： 郭霖CSDN博客 简介：圈内人称郭神，Android最好的入门书籍《第一行代码》的作者。博文行文流畅，条理清晰，内容实用，适合读完入门书籍之后阅读，超高人气博主。 任玉刚： 任玉刚CSDN博客 简介：中科大硕士，百度Android资深工程师，进阶书籍《Android开发艺术探索》作者，博客极具深度广度，适合Android开发者的高阶学习。最近任玉刚老师推出了与书籍相配套的视频教程，感兴趣的同学可以关注下。 张鸿洋： 张鸿洋CSDN博客 CSDN超人气博主，对Android中的源码，自定义View颇有研究。并且有很多值得借鉴的应用编写技巧，值得推荐！ 兰亭风雨： 兰亭风雨CSDN博客 简介：圈内公认的Java大牛，对Java虚拟机有深度研究，出色的Java源码分析 Mr.Simple： Mr.Simple CSDN博客 简介：开源框架专家，OOP等，《从小工到专家》、《Android设计模式》作者。博主手中就有一本从小工到专家，性能优化部分非常不错，热爱分享的技术大牛，值得推荐。 爱哥： 爱哥CSDN博客 简介：博主偶然间搜索到他自定义控件部分的博客，深入浅出，幽默诙谐，逼格满满，自定义View专家。 胡凯： 胡凯个人博客 精通Android性能优化，长期坚持翻译国外先驱技术博客。 张明云： 张明云github博客 张明云老师长期活跃于知乎、简书等技术平台，对性能优化、各种坑的解决颇有研究并且乐于分享，简书上也有张明云老师的专栏，强烈推荐！ 一：值得关注的微信公众号 stormzhang： 可能是最有影响力的Android公众号了，自学成才的张哥以他励志的经历，出色的行动力和人格魅力影响了一大批初学者，也包括博主在内，通过自学走上了Android开发者的道路，如果你刚刚接触Android，跟随张哥的脚步慢慢学习是最好的选择。 stormzhang博客精华 微信公众号：AndroidDeveloper 汤涛： 如果你是一个中高级Android开发者，那汤涛哥的公众号你有必要关注一下了。汤涛哥的公众号每一篇都是精品，宁缺毋滥，专注于Android开发实战，汤涛哥人也非常好，热爱分享，专注技术深度挖掘。 微信公众号：androidtrening 移动开发前线： 分享优质iOS、Android、前端技术精品文章 微信公众号：bornmobile 二：优秀学习网站吐血推荐给大家几个学习网站，都非常不错 开发技术前线 稀土：掘金 AndroidWeekly开发技术周报 好东西传送门 相关配套阅读： 移动开发必读书单 PS：如果对你有帮助就点赞关注下吧，过两天为大家整理整理一些知名的开源项目！","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"推荐","slug":"推荐","permalink":"http://yoursite.com/tags/推荐/"}]},{"title":"移动开发必读书单","slug":"移动开发必读书单","date":"2016-07-27T13:49:04.482Z","updated":"2016-07-27T13:50:08.959Z","comments":true,"path":"2016/07/27/移动开发必读书单/","link":"","permalink":"http://yoursite.com/2016/07/27/移动开发必读书单/","excerpt":"为什么要列这一个书单？我认为某一领域的技术人，在他的职业生涯中，一定有一些绕不过去的技术和非技术的知识。有的时候，靠自己摸索、到处偷师，倒也能掌握。但是，这些别人早就趟过去的坎，大多已经有了非常棒的书籍作为总结。看了这些书，脚下的路就要平一些。这个书单，就是为了找到移动领域的这些书。","text":"为什么要列这一个书单？我认为某一领域的技术人，在他的职业生涯中，一定有一些绕不过去的技术和非技术的知识。有的时候，靠自己摸索、到处偷师，倒也能掌握。但是，这些别人早就趟过去的坎，大多已经有了非常棒的书籍作为总结。看了这些书，脚下的路就要平一些。这个书单，就是为了找到移动领域的这些书。这些书籍都是移动前线群里推荐的，都是他们自己读过，甚至是反复读的书。如果你对这些书有什么看法，欢迎发表意见，或者添上你觉得认为必须的书。 这个书单也不会一成不变，欢迎大家的增补修改。 计算机基础 《程序是怎样跑起来的》推荐理由：类似深入理解计算机的图解版本，如果第一次看深入理解计算机看不进去，可以先看看，了解个大概，再看深入理解计算机这本就容易很多。 《深入理解计算机系统》推荐理由：了解一个程序的编译、链接、执行过程，以及虚拟内存是如何分配等。 通用编程 《算法(第四版)》推荐理由：难度不及算法导论，但是更适合工程领域，导论恐高症患者的福音。 《编程珠玑》推荐理由：编程珠玑这本书推荐给有代码基础的小伙伴，推荐理由是书里会有一些优化和算法基础的思想，适合入门之后的进阶，对优化和算法能够有一些基础的认识。对程序员写出优质而高效的代码比较有帮助，至少我个人阅后感受如此。 《设计模式之禅》推荐理由：读完，通俗易懂，更深刻理解面向对象和面向接口。注：设计模式这几本书难以取舍，选一本读即可。 《大话设计模式》，《大话数据结构》推荐理由：都是菜鸟和大牛的对话模式，看着不枯燥，内容也很全。推荐理由2：推荐初级程序员看&lt;大话设计模式&gt;，这本书有个好处是他是演进式的，虽然内容很简单，看完也没办法直接指导到开发上。但是会有一种恍然大悟的感觉，原来这就是设计模式。比起四人组的设计模式，太过于专业的说明和定义，对于初级开发人员来说，往往无法消化甚至抵触。回到大话设计模式，将实践和故事相结合，即让设计模式接了地气，又引发自己的思考，我怎么可以改造既有的项目。同时作为入门书籍，看完后你会更渴望更专业的设计模式的内容也算是这本书的一个意义。总结就是，一本非常入门接地气的设计模式书籍。 《Head first 设计模式》推荐理由：漫画形式的以对话为主，都是从生活中的小例子入手，更理解一句话了：万物皆对象。 《构建之法》推荐理由：一本有趣的软件工程书，新手哪知道什么是软件工程。书里描述了作者在的团队遇到了哪些问题，如何正视，怎样改善，不断改进。理论和实践相结合。面向实战。讲述软件工程中不同角色的作用。看完后可以帮助新手更好地理解软件开发是怎么个回事，更快地走向成熟。 《代码大全》推荐理由：代码大全全面讲述了工程实践的要点，深入每个细节。可以帮助新手拓展视野，熟悉规范，也可以在学习一些概念或技术时当做字典查。总之代码大全的英文名code complete很能说明问题：帮助你完成整个编码活动的全过程。 《代码整洁之道》推荐理由：这几天在看，讲解详细，有提供示例，可以提高自己编码素质。 《图解http》推荐理由：做网络编程必须要懂的基础书，看这本书对做网络缓存和网络性能优化都有不小的帮助，最主要是书内容深入浅出 图文并茂，通俗易懂。 《单元测试的艺术》推荐理由：由浅入深地介绍了单元测试的各方面知识，告诉我们如何写好单元测试，如何写易于测试的代码，如何处理遗留代码等问题，有理论有案例。 《修改代码的艺术》推荐理由：详细讲解重构技巧的书，教你怎么处理各种遗留的烂代码，非常详实的重构操作手册。 iOS开发 《Effective Objective-C 2.0》推荐理由：这本书很适合初学者，能帮助初学者一开始就打下比较规范的基础，里面讲了很多规范。读了这本书能让初学者少走很多弯路。推荐理由2：精炼，针对性强，对一些生僻容易懵圈的知识点讲得比较细。 《iOS编程实战》推荐理由：尤其推荐小公司的没有系统学习过iOS的同学看，实战和自己闭门造车完全两码事，这书不是教人这个api怎么用，而是应该这样用。 《Objective-C高级编程 iOS与OS X多线程和内存管理》推荐理由：这本书给我带来的最大价值是：要让自己对一项技术有全面的认识，光从官方文档、开源代码中寻找答案并不够，还要会用各种工具来验证自己的想法。可以看出作者对技术非常严谨的态度，虽然偶尔有些翻译并不容易让人理解，但真的是一本进阶型的书。 《iOS编程（第4版）》推荐理由：作者之一Aaron Hillegass曾就职于NeXT公司和Apple公司。 书涵盖了初级到中级的，书中在讲到第一次出现的知识点的时候，通常会简要的解释一下，所以初学者很容易上手。缺点是这书有点老，但OC的基础知识讲解的很扎实。 《Swift Apprentice》推荐理由：这本书的优势就是从浅入深，抽死剥茧，从最基础的知识带领你到函数编程奥义的天堂，充分的实例，全英文，免去你被中文版带沟里的风险，相信这本书能告诉初学者swift2为什是大势所趋，为什么swift2即是面向对象编程语言又是函数编程语言。 《Swifter - 100 个 Swift 必备 tips》推荐理由：比较偏帮助手册类的tips，虽然没有讲Swift比较深入的，但对前期学习Swift梳理与Objective-C及混编有很大帮助。 《iOS应用逆向工程 第2版》推荐理由：iOS应用逆向最有价值参考书籍，内容涵盖多个实例，阐述class-dump、Theos、Cycript、Reveal、IDA、LLDB等常用工具的使用，通俗易懂；总结提炼出一套从UI观察切入代码分析的iOS应用逆向工程方法论，激发iOS开发人员对应用安全的思考，把主动防御的思想渗透到项目开发中。 Android开发 《第一行代码》推荐理由：我刚刚大体看了一遍 ，这本书学完之后完全足够入门，而且不会令初学者感到枯燥。在入门阶段还可以作为工具书不断去翻阅，不同时期会有不同的感受。 里面打小怪兽升级的旁白，现在回过头看还确实挺有趣的。 《App研发录》推荐理由：研发辅助类，包含了异常的分析，竞品分析和项目管理，书不厚，但是有些能增加知识的广度。 《Embedded Android》推荐理由：从底层讲解android系统的机制与设计，比较适合具有一定经验的开发者，属于进阶书籍。 《Java并发编程实战》推荐理由：通过java现成的并发工具类介绍和实例，深入浅出的说明如何安全地进行多线程操作和优化。 《Android.C++.with.the.NDK》推荐理由：android jni入门与提高，系统讲解android jni的编译、提供的接口、java jni的通讯方式等，对于需要学习jni开发的同学是必读，毕竟jni文档缺乏。 《Android开发艺术与探索》推荐理由：主要讲一些原理，主要学习为什么这么用，以及源码解析说明。 《深入了解JVM虚拟机》推荐理由：这本书对了解底层机制很有帮助，是进阶必选。 《Java编程思想》推荐理由：Java编程思想是Java圣经，要有一定经验去看效率才不错。 人文类 《程序员的职业素养》推荐理由：从企业，团队，技术，自身等各个角度阐述了作为一个专业的程序员应该如何去做到更好，不卑不亢，不投机取巧，树立非常正能量的价值观，举了很多工作学习中经常碰到的案例，读完相见恨晚。书不是太厚，个人净阅读时间在10小时左右。 《在人生拐角处》推荐理由：很多程序员对于自身的职业规划并没有，所以这本书就是帮助你化解你的迷茫，做好职业规划，里面是生涯规划师写的案例，都很贴近生活，适合不知道自己该怎么走下去的人看。 《程序员健康指南》推荐理由：本书是为了程序员量身订造的健康指南，针对头痛，眼部疲劳，背部疼痛和手腕疼痛等常见问题，简要介绍了其成因，测试方法，并列出了每天的行动计划，从运动，饮食等方面给出详细指导，帮助程序员在不改变工作方式的情况下轻松拥有健康。 《重新定义公司 How Google Works》推荐理由：一分理论三分实践相结合，告诉你互联网公司运作的合理方式。亮点是针对理论有 Google 实际的实行方式，也有多个 Google 内部项目成长的曲折过程，还有谷歌退出中国的内部爆料。 《黑客与画家》推荐理由：非常有深度的一本书，作者在经济，社科，历史，等很多方面都很有自己的见解，更不用说技术和创业了。书中很多观点有准确的例证引用，让人信服。 《Rework》推荐理由：一句话：太赞的一本书了！！！创业者必读！当然，不创业的人也能从中得到非常多的insight。作者是37signals.com的两个创始人，其中之一还是Ruby on Rails的creator。讲的是创业中需要注意的一些事情，但这些事情不仅仅是创业中才需要注意的。另外，英文原版的写的也很通俗易懂，推荐看原版的。推荐理由： 这本书本身就是小而美的37Singal自身成长的总结，特别适合小团队初创团队，很好的诠释了“好铁用在刀刃上”。 《Getting Real》推荐理由：37Signals的又一本书，也是第一本，强调用一种务实的方式做一个Web app，从产品组队实现上线推广各方面的点点滴滴。内容依然很棒，但是跟《Rework》有大量重复的地方，看过那本以后已经没有那种惊艳的感觉了。也算是知道了为这么这本书豆瓣评分达9.1, 而那本“只有”8.7了。 《代码的未来》推荐理由：Ruby发明人Matz的大作，这是一本技术性随笔，介绍了现代编程的方方面面，从lisp宏到gc技术，再到元编程，IPC，多核及云计算，NoSQL。。。虽说是随笔，还是具备一定的技术性的，很多地方要认真的看才看得懂。作者的语气很谦虚亲切，很多地方甚至有卖萌的嫌疑，哈！总之，是一本广大程序猿增长见识，拓宽视野的极佳之作！ 《GEB》推荐理由：通过对哥德尔的数理逻辑，艾舍尔的版画和巴赫的音乐三者的综合阐述，引人入胜地介绍了数理逻辑学、可计算理论、人工智能学、语言学、遗传学、音乐、绘画的理论等方面。抽象级别比设计模式高上几个数量级，看懂这本书，不仅是抽象思维上质的提升，对个人也将产生深远的影响。 效率类 《暗时间》推荐理由：讲的是关于时间管理，告诉我们怎么学习专业领域技能和非专业领域技能以及我们应该怎么自我管理性格。 《把时间当做朋友》推荐理由：它的理念就是，时间是不可以管理的，最主要改变的是自己的心智！ 技术管理 《门后的秘密》推荐理由：以场景、对话的方式讲解日常基础技术管理，适合技术人员转管理的细细阅读，入门管理实用。 《人月神话》推荐理由：管理复杂项目的见解深刻，并有大量软件工程的实践。 《人件》推荐理由：给技术管理者或者希望走向管理方向的人参考。最近在看第二遍，收获很大。软件即人件，软件开发不光要解决技术问题，更重要是人的问题。为何很多工作加班才能解决？公司为何无法留住员工？读完这本书可以找到一些答案。 最后：文章转载于公众号《移动开发前线》 应广大程序猿们留言，文章的最后加上《颈椎病康复指南》、《活着》、《编程从入门到放弃》、《单身 真好》等超人气书籍~ 最最后： 博主专注于原创高质量的Android技术博客，分享高质量的编程知识，喜欢的盆友点一个关注吧~！ 相关配套阅读： Android开发者必读博客 配套阅读","categories":[{"name":"书单","slug":"书单","permalink":"http://yoursite.com/categories/书单/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/移动开发/"},{"name":"书单","slug":"书单","permalink":"http://yoursite.com/tags/书单/"}]},{"title":"APK瘦身经验总结","slug":"APK瘦身经验总结","date":"2016-07-27T13:46:57.118Z","updated":"2016-07-27T13:48:14.493Z","comments":true,"path":"2016/07/27/APK瘦身经验总结/","link":"","permalink":"http://yoursite.com/2016/07/27/APK瘦身经验总结/","excerpt":"Android APK瘦身经验总结写在前面：无论手机的内存有多大， 我们自然都希望一个应用的安装包能越小越好，更小的APK标示着更多地用户愿意去下载和体验。本文借鉴张明云、胡凯等老师的博客，对常规的APK瘦身方法进行归纳和总结并附上资料的链接。如果能对你有所帮助，那真的再好不过了。","text":"Android APK瘦身经验总结写在前面：无论手机的内存有多大， 我们自然都希望一个应用的安装包能越小越好，更小的APK标示着更多地用户愿意去下载和体验。本文借鉴张明云、胡凯等老师的博客，对常规的APK瘦身方法进行归纳和总结并附上资料的链接。如果能对你有所帮助，那真的再好不过了。 零：瘦身的指标是什么造成了APK越来越大呢？ 先来看一张解压之后的APK的目录图： 应该从哪些方面入手对APK进行瘦身呢？ 冗余的代码，不必要的jar包； 未使用的静态资源，libs； 屏幕适配时，资源的重复使用； 错误地预置数据 native code 未进行图片资源的优化与压缩（重点） 如果看到这里感觉还没形成相应的概念，没关系，接下来对这些指标进行逐个分析，相信你很快就能明了。 一：剔除冗余代码 Proguard Proguard是编译时对java代码进行压缩，混淆，优化，预编译等操作的集成化工具。Proguard会遍历你的所有代码然后找出无用处的代码。所有这些不可达（或者不需要）的代码都会在生成最终的apk文件之前被清除掉。Proguard也会重命名你的类属性，类和接口，然整个代码尽可能地保持轻量级水平。 Android代码混淆规则设置 使用Proguard混淆Android代码 有关Proguard的配置和使用，网上有很多资料，以上两个是我认为还不错的，通过Proguard工具通常能使你的APK减小200K左右。 AndResGuard AndResGuard是微信客户端高级工程师 shwen 的开源项目，可以做到直接处理安装包.不依赖源码，不依赖编译过程，仅仅输入一个安装包，得到一个混淆包。AndResGuard的功能还是非常强大，腾讯多个产品都使用到了它，具体的源码和使用方法移步到Github上学习，已开源。 AndResGuard–github 二：剔除无用的资源 Lint Proguard它只会对代码进行分析，对比如图片之类的资源就束手无策了，不过这个时候Lint就可以发挥非常大的作用了。 Lint 一个静态的代码分析器，你只需通过调用 ./gradlewlint这个简单地命令它就能帮你检查所有无用的资源文件。它在检测完之后会提供一份详细的资源文件清单，并将无用的资源列在“UnusedResources:Unused resources” 区域之下。只要你不通过反射来反问这些无用资源，你就可以放心地移除这些文件了。 Android Studio中Lint的使用 值得注意的是，Lint 会分析资源文件(比如 /res 文件夹下面的文件) ，但是会跳过 assets 文件 ( /assets 文件夹下面的文件)。事实上 assets 文件是可以通过它们的文件名直接访问的，而不需要通过Java引用或者XML引用。因此，Lint 也不能判定某个 asset 文件在项目中是否有用。这全取决于开发者对这个文件夹的维护了。所以你要去人工排查一下assets文件夹下有没有无用的资源，如果有就移除它。 三：对资源文件进行取舍其实这步操作更多的针对是屏幕适配的知识，曾经听说一个开发者对Android所有屏幕密度下的文件夹都提供了一套图片资源（ldpi, mdpi, tvdpi, hdpi, xhdpi, xxhdpi and xxxhdpi），这是非常不理智的行为，虽然Android支持这么多的屏幕密度，但是不代表你需要为每一个都提供一套资源，下面对资源取舍的一些建议： 尽量使用一套图片资源，对于一些图片在不同分辨率手机上变现差异过大的情况，再考虑去相应文件夹下放入这个特定的图片 使用一套图、一套布局，多套dimens.xml文件，在使用最小资源的情况下搞定多分辨率适配 尽量重用图片，例如对称的图片，只需要提供一张，另外一张图片可以通过代码旋转的方式实现 去除无用的库，功能上重复的库，使用更轻量级的库，比如你仅仅是想做一些网络请求，使用volley即可，没必要去引入xutils，这就要根据你项目的情况去具体分析了。 错误的预置一些图片资源，有一些没必要跟随程序展示的图片就在需要加载它的时候再加载它，将程序与资源尽可能的分离。 四：对图片资源进行优化好了终于来到本篇博客的重头戏，其实上对一个APK大小的优化更多的就是对图片资源的一些处理技巧，我们应该在不降低图片的显示效果、保证APK显示效果的前提下压缩图片文件的大小。 tinypng 图片压缩利器tinypng 据官网介绍，它的原理是通过合并图片中相似的颜色，通过将 24 位的 PNG 图片压缩成小得多的 8 位色值的图片，并且去掉了图片中不必要的metadata（元数据，从 Photoshop 等工具中导出的图片都会带有此类信息），这种方式几乎能完美支持原图片的透明度。 拖拽图片即可使用，压缩率甚至达到了70%，感叹它强大的同时，有精力的同学可以去研究研究它的算法 开源的tinypng插件 webP 有关webP的简介 WEBP 是google推出的意图改变web图片JPG、PNG、GIF三分天下局势的一种图片格式。它不仅支持无损或有损压缩、alpha通道，还支持动画演示。在同画质的情况下，webp格式图片占用体积相较于jpg图片大约减少40%，相较于无损png图片大约减少30%。具不完全统计，互联网流量中60%都产生于图片，如果能用上webp格式，网站的访问速度将会大大提升。 不过android 4.0+才原生支持webp, 但是我们的app是兼容2.3+，所以4.0以下的设备将无法看到图片。但是引入兼容的SO文件，APK也会变大，这时候自己做个取舍吧！ 写在最后： 其实还有一些给APK瘦身的技巧和细节，并没有一一列举出，而且有些新的优化技巧涉及到一些兼容性的问题，大家多查阅资料就能明白了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/经验/"},{"name":"瘦身","slug":"瘦身","permalink":"http://yoursite.com/tags/瘦身/"}]},{"title":"如何在你的应用中正确使用Context","slug":"如何在你的应用中正确使用Context","date":"2016-07-27T13:44:22.278Z","updated":"2016-07-27T13:46:01.111Z","comments":true,"path":"2016/07/27/如何在你的应用中正确使用Context/","link":"","permalink":"http://yoursite.com/2016/07/27/如何在你的应用中正确使用Context/","excerpt":"如何在你的应用中正确使用Context写在前面：Context对象在我们的项目中实在是太常见了，启动Activity、Service、发送一个Broadcast，作为获取各种系统Resources的参数，Layout Inflation的参数，show a Dialog的参数等等。Context对象的使用不当，是可能造成内存泄漏的，当你的工程代码已经达到十几万行甚至是几十万行时，Context对象就对内存泄漏造成非常可观的影响了，所以我们应该对Context对象的使用，做到心中有数。","text":"如何在你的应用中正确使用Context写在前面：Context对象在我们的项目中实在是太常见了，启动Activity、Service、发送一个Broadcast，作为获取各种系统Resources的参数，Layout Inflation的参数，show a Dialog的参数等等。Context对象的使用不当，是可能造成内存泄漏的，当你的工程代码已经达到十几万行甚至是几十万行时，Context对象就对内存泄漏造成非常可观的影响了，所以我们应该对Context对象的使用，做到心中有数。 零：什么是Context前两天刚刚对 Context 写了一篇比较长的博客，借鉴大牛们的经验，对 Context 进行了比较详细的整合与总结，花半个小时的时间耐心读一读吧！ 你足够了解 Context 吗？ 一句话总结： Context是为一个Android程序提供各种功能、资源、服务的一个环境， Context 的资源在系统中只有一套，因为它的子类（Application、Activity、Service）对这同一块资源处理方式的不同，让Context 对象在功能上表现出各自之间的差异。 一：Context对象之间的差异相信如果你是一个初学者， Context 在你手里应该是胡乱传入的，哪里有 Context 就找哪里，各种this乱入，O(∩_∩)O哈哈，至少当时我是这样的，但是 Context 不同的对象在使用功能上是有区别的，比如以下代码： 在清单文件中做以下配置： 在界面中show a Dialog 点击按钮之后崩溃信息 当我使用Application的Context时，是无法弹出一个Dialog的，因为Dialog作为一个View，依附在Activity上，并且与Theme相关，当传入参数为Actvity的Context时，崩溃就解决了。 下面这张表展示出了Context对象之间使用上的差异： 二：Context相关的内存泄漏问题在讨论内存泄漏之前，先简单的说说Android中内存的回收 Dalivik虚拟机扮演了常规的垃圾回收角色，为了GC能够从App中及时回收内存，我们需要时时刻刻在适当的时机来释放引用对象，Dalvik的GC会自动把离开活动线程的对象进行回收。 什么是Android内存泄漏： 虽然Android是一个自动管理内存的开发环境，但是垃圾回收器只会移除那些已经失去引用的、不可达的对象，在十几万、几十万行代码中，由于你的失误使得一个本应该被销毁的对象仍然被错误的持有，那么该对象就永远不会被释放掉，这些已经没有任何价值的对象，仍然占据聚集在你的堆内存中，GC就会被频繁触发，多说几句，如果手机不错，一次GC的时间70毫秒，不会对应用的性能产生什么影响，但是如果一个手机的性能不是那么出色，一次GC时间120毫秒，出现大量的GC操作，我相信用户就能感觉到了吧。这些无用的引用堆积在堆内存中，越积越多最终导致Crash，有关一些性能优化推荐给大家一个我总结的博客。 Android性能优化总结 有些跑题了，我们赶紧来看看什么情况下Context会引发内存泄漏 错误的单例模式 我们来分析一下这个非线程安全的单例模式，假设你在Activity A去getInstance获得instance对象，顺手传了一个this，好了，现在一个常驻内存的Singleton保存了你传入Activity A的对象，并且一直持有Activity A的引用，这样即使你Activity被销毁掉，但是因为它的引用还存在于一个Singleton中，是不可能被GC掉的，这样就导致了内存泄漏。 View持有Activity的引用 再来分析一下，有一个静态的Drawable对象，当我给ImageView设置这个Drawable时，ImageView像上面那个例子一样，保存了这个mDrawable的引用（大家可以点开源码705行去看，很多UI组件都是统一的操作，一直持有传入的对象），然而ImageView传入了this，也就是ImageView同样持有一个MainActivity的mContext。因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，所以当MainActivity被销毁时，也不能被GC掉，所以也造成了内存泄漏。 三：使用Context的正确姿势通俗一点说，Context造成的内存泄漏，几乎都是当Context销毁的时候，却还被各种不合理、无端地引用着。那么哪个Context对象是不会被销毁的呢？对了，Application的Context对象可以理解为随着进程存在的，所以当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context 调用一行代码： LaucherApplication.getContext(); 回头看看上面那张表格，显然Application的Context不是万能的，涉及UI加载操作时，似乎我们只能使用Activity的Context，所以你当你使用Activity的Context时，你要对持有Activity的对象心中有数，保证它能随着生命周期的销毁而被回收，慎用static关键字，不要因为方便访问就各种static乱入。 多说一点，上表中Layout Inflation中只能使用Activity的Context，而各种View在创建时，需要传入的Context参数也是Activity的，大家懂了吧，当解析XML文件的时候，传入的参数也就统一了，相信大家一定能想明白这点。 写在最后： 给大家推荐一个内存检测的自动化工具，LeakCanary，但是当你曾经写出的代码不规范不负责，已经达到十几万行，几十万行的时候，再去抽丝剥茧试图解开已经打上层层死结的引用关联，是非常难的。所以平时还是要注意下细节哈~ 如果大家觉得喜欢有价值，就关注我，点下赞哈，你们的支持是我持续原创的动力。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"技巧","slug":"技巧","permalink":"http://yoursite.com/tags/技巧/"},{"name":"Context","slug":"Context","permalink":"http://yoursite.com/tags/Context/"},{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/应用/"}]},{"title":"你足够了解Context吗？","slug":"你足够了解Context吗","date":"2016-07-27T13:29:52.585Z","updated":"2016-07-27T13:49:24.601Z","comments":true,"path":"2016/07/27/你足够了解Context吗/","link":"","permalink":"http://yoursite.com/2016/07/27/你足够了解Context吗/","excerpt":"你足够了解Context吗？这里有关于Context的一切-写在前面： 当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。","text":"你足够了解Context吗？这里有关于Context的一切-写在前面： 当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。 零：官方定义好吧如果你无法翻墙，推荐你两个可以看官网文档的网站： Android官方文档国内镜像站点 Android中文API 我们来看看官方文档中，Context的解释 Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc. 一个应用环境的全局信息，字面意思是上下文的意思; Context是一个抽象类; 允许我们通过Context获取各种资源，服务，或者去启动一个Activity，发送一个广播，等等; 怎么去理解Context呢？其实Context就是给Android应用程序提供了一个可以实现各种操作的土壤环境，Context为Android提供了各种资源、功能、服务。如果说编写一个Android程序像搭建一座房子，那Context就为Android提供了土地，木材，和染料(启动一个Activity，弹出一个Dialog)，并且能提供呼叫各种将房屋建得更完善的其他帮助(发送一个广播，启动一个服务等)。 一：继承关系 通过继承关系可以看到，Context直接子类为ContextIml（实现类）和ContextWrapper（包装类） 再看看ContextWrapper的子类有什么，看到熟悉的Service和Application了吧，不过看到这里你一定有个疑问，为什么Activity和他们哥俩不在一个继承层级呢？而是Activity又继承了ContextThemeWrapper，那么ContextWrapper和ContextThemeWrapper的区别在哪里呢？ 看到这两个类的名字，相信你心里已经有了答案，对，区别在Theme。 该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。只有Activity需要主题，Service不需要主题， 所以Service直接继承于ContextWrapper类。而Activity因为含有Theme属性的缘故，所以继承自ContextThemeWrapper。 所以说，Context所调用的资源是不同的了？保留这个疑问，继续向下看。 二：源码阅读看到了继承结构，我们分别来看看Context及其子类的一些源码 Context 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public abstract class Context &#123; // 获取应用程序包的AssetManager实例 public abstract AssetManager getAssets(); // 获取应用程序包的Resources实例 public abstract Resources getResources(); // 获取PackageManager实例，以查看全局package信息 public abstract PackageManager getPackageManager(); // 获取应用程序包的ContentResolver实例 public abstract ContentResolver getContentResolver(); // 它返回当前进程的主线程的Looper，此线程分发调用给应用组件(activities, services等) public abstract Looper getMainLooper(); // 返回当前进程的单实例全局Application对象的Context public abstract Context getApplicationContext(); // 从string表中获取本地化的、格式化的字符序列 public final CharSequence getText(int resId) &#123; return getResources().getText(resId); &#125; // 从string表中获取本地化的字符串 public final String getString(int resId) &#123; return getResources().getString(resId); &#125; public final String getString(int resId, Object... formatArgs) &#123; return getResources().getString(resId, formatArgs); &#125; // 返回一个可用于获取包中类信息的class loader public abstract ClassLoader getClassLoader(); // 返回应用程序包名 public abstract String getPackageName(); // 返回应用程序信息 public abstract ApplicationInfo getApplicationInfo(); // 根据文件名获取SharedPreferences public abstract SharedPreferences getSharedPreferences(String name, int mode); // 其根目录为: Environment.getExternalStorageDirectory() public abstract File getExternalFilesDir(String type); // 返回应用程序obb文件路径 public abstract File getObbDir(); // 启动一个新的activity public abstract void startActivity(Intent intent); // 启动一个新的activity public void startActivityAsUser(Intent intent, UserHandle user) &#123; throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;); &#125; // 启动一个新的activity // intent: 将被启动的activity的描述信息 // options: 描述activity将如何被启动 public abstract void startActivity(Intent intent, Bundle options); // 启动多个新的activity public abstract void startActivities(Intent[] intents); // 启动多个新的activity public abstract void startActivities(Intent[] intents, Bundle options); // 广播一个intent给所有感兴趣的接收者，异步机制 public abstract void sendBroadcast(Intent intent); // 广播一个intent给所有感兴趣的接收者，异步机制 public abstract void sendBroadcast(Intent intent,String receiverPermission); public abstract void sendOrderedBroadcast(Intent intent,String receiverPermission); public abstract void sendOrderedBroadcast(Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras); public abstract void sendBroadcastAsUser(Intent intent, UserHandle user); public abstract void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission); // 注册一个BroadcastReceiver，且它将在主activity线程中运行 public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter); public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler); public abstract void unregisterReceiver(BroadcastReceiver receiver); // 请求启动一个application service public abstract ComponentName startService(Intent service); // 请求停止一个application service public abstract boolean stopService(Intent service); // 连接一个应用服务，它定义了application和service间的依赖关系 public abstract boolean bindService(Intent service, ServiceConnection conn, int flags); // 断开一个应用服务，当服务重新开始时，将不再接收到调用， // 且服务允许随时停止 public abstract void unbindService(ServiceConnection conn); public abstract Object getSystemService(String name); public abstract int checkPermission(String permission, int pid, int uid); // 返回一个新的与application name对应的Context对象 public abstract Context createPackageContext(String packageName, int flags) throws PackageManager.NameNotFoundException; // 返回基于当前Context对象的新对象，其资源与display相匹配 public abstract Context createDisplayContext(Display display); &#125; Context的源码算上注释有3000行之多，这里贴出一些重要代码，可以看到，Context几乎包含了所有你能想到的，一个Android程序需要的资源和操作，Context自己就像一个App一样，启动Activity、Service，发送Broadcast，拿到assets下的资源，获取SharedPreferences等等。 但Context只是一个顶层接口啊，又是谁帮他实现了操作呢？是ContextWrapper吗？ ContextWrapper 123456789101112131415161718192021222324252627282930313233public class ContextWrapper extends Context &#123; Context mBase; //该属性指向一个ContextIml实例 public ContextWrapper(Context base) &#123; mBase = base; &#125; /** * @param base The new base context for this wrapper. * 创建Application、Service、Activity，会调用该方法给mBase属性赋值 */ protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(&quot;Base context already set&quot;); &#125; mBase = base; &#125; @Override public Looper getMainLooper() &#123; return mBase.getMainLooper(); &#125; @Override public Object getSystemService(String name) &#123; return mBase.getSystemService(name); &#125; @Override public void startActivity(Intent intent) &#123; mBase.startActivity(intent); &#125;&#125; 好吧，ContextWrapper好像很懒的样子，它把所有操作都丢给了mBase，mBase又是谁呢？在构造方法和attachBaseContext方法中，指向了一个Context实例，ContextIml，我们赶紧来看看ContextIml的源码！ ContextImpl 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Common implementation of Context API, which provides the base * context object for Activity and other application components. */class ContextImpl extends Context &#123; private final static String TAG = &quot;ContextImpl&quot;; private final static boolean DEBUG = false; private static final HashMap&lt;String, SharedPreferencesImpl&gt; sSharedPrefs = new HashMap&lt;String, SharedPreferencesImpl&gt;(); /*package*/ LoadedApk mPackageInfo; // 关键数据成员 private String mBasePackageName; private Resources mResources; /*package*/ ActivityThread mMainThread; // 主线程 @Override public AssetManager getAssets() &#123; return getResources().getAssets(); &#125; @Override public Looper getMainLooper() &#123; return mMainThread.getLooper(); &#125; @Override public Object getSystemService(String name) &#123; ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name); return fetcher == null ? null : fetcher.getService(this); &#125; @Override public void startActivity(Intent intent, Bundle options) &#123; warnIfCallingFromSystemProcess(); if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, (Activity)null, intent, -1, options); &#125;&#125; 其实ContextImpl才是在Context的所有继承结构中唯一一个真正实现了Context中方法的类。其它Context的子类，Application，Activity，Service，都是与ContextImpl相关联，去获取资源和服务，并没有真正自己去实现，这里就不贴上ContextThemeWrapper的源码了，它是为Activity添加了一些Theme的属性，不再赘述。 思路越来越清晰，我们现在就是要去寻找，Activity，Service，Application是何时与ContextImpl完成绑定关联的。 三：关联时机我们都知道ActivityThread的main方法，是整个Android程序的入口，所以去探究ActivityThread类，也是一件非常重要的事。 推荐一篇文章，去了解下ActivityThread吧 ActivityThread简介 贴出ActivityThread的main方法部分重要的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public final class ActivityThread &#123; static ContextImpl mSystemContext = null; static IPackageManager sPackageManager; // 创建ApplicationThread实例，以接收AMS指令并执行 final ApplicationThread mAppThread = new ApplicationThread(); final Looper mLooper = Looper.myLooper(); final HashMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new HashMap&lt;IBinder, ActivityClientRecord&gt;(); final HashMap&lt;IBinder, Service&gt; mServices = new HashMap&lt;IBinder, Service&gt;(); final H mH = new H(); Application mInitialApplication; final ArrayList&lt;Application&gt; mAllApplications = new ArrayList&lt;Application&gt;(); static final ThreadLocal&lt;ActivityThread&gt; sThreadLocal = new ThreadLocal&lt;ActivityThread&gt;(); Instrumentation mInstrumentation; static Handler sMainThreadHandler; // set once in main() private class H extends Handler &#123; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what)); &#125; ... &#125; private class ApplicationThread extends ApplicationThreadNative &#123; private void updatePendingConfiguration(Configuration config) &#123; synchronized (mPackages) &#123; if (mPendingConfiguration == null || mPendingConfiguration.isOtherSeqNewer(config)) &#123; mPendingConfiguration = config; &#125; &#125; &#125; public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges) &#123; queueOrSendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0), configChanges); &#125; // we use token to identify this activity without having to send the // activity itself back to the activity manager. (matters more with ipc) public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, Bundle state, List&lt;ResultInfo&gt; pendingResults, List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward, String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profileFile = profileName; r.profileFd = profileFd; r.autoStopProfiler = autoStopProfiler; updatePendingConfiguration(curConfig); queueOrSendMessage(H.LAUNCH_ACTIVITY, r); &#125; ... &#125; public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); // 创建ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); &#125; public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; // 创建Activity对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); ActivityClientRecord r = (ActivityClientRecord)msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case BIND_APPLICATION: // 创建Application对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: // 创建Service对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceCreate&quot;); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: // Bind Service对象 Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; &#125; &#125; 也许你不能完全看懂、理解这些代码，不过没关系，直接告诉你结论吧，ActivityThread的一个内部类H，里面定义了activity、service等启动、销毁等事件的响应，也就是说activity、service的启动、销毁都是在ActivityThread中进行的。 当然了，一个Activity或者Service的从创建到启动是相当复杂的，其中还涉及的Binder机制等等原理，推荐给大家两篇博文，去慢慢研读消化吧。 Activity启动原理详解 Service启动原理分析 准备工作不知不觉就做了这么多，差点忘了正事，我们还是要继续寻找Application、Activity、Service是何时与ContextImpl进行关联的。 Application 123456789101112131415161718192021222324252627282930313233343536373839404142// ActivityThread.javaprivate void handleBindApplication(AppBindData data) &#123; try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... &#125; finally &#123; StrictMode.setThreadPolicy(savedPolicy); &#125;&#125;// LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123; return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = &quot;android.app.Application&quot;; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); ContextImpl appContext = new ContextImpl(); // 创建ContextImpl实例 appContext.init(this, null, mActivityThread); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); // 将Application实例传递给Context实例 &#125; catch (Exception e) &#123; ... &#125; mActivityThread.mAllApplications.add(app); mApplication = app; return app; &#125; 每个应用程序在第一次启动时，都会首先创建一个Application对象。从startActivity流程可知，创建Application的时机在handleBindApplication()方法中，该函数位于 ActivityThread.java类 Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity a = performLaunchActivity(r, customIntent); // 到下一步 if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); ... &#125; ... &#125;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); // 创建Context CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; ... &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 123456789101112131415161718192021222324private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) &#123; ContextImpl appContext = new ContextImpl(); // 创建ContextImpl实例 appContext.init(r.packageInfo, r.token, this); appContext.setOuterContext(activity); // For debugging purposes, if the activity&apos;s package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. Context baseContext = appContext; String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123; DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); for (int displayId : dm.getDisplayIds()) &#123; if (displayId != Display.DEFAULT_DISPLAY) &#123; Display display = dm.getRealDisplay(displayId); baseContext = appContext.createDisplayContext(display); break; &#125; &#125; &#125; return baseContext;&#125; 通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()，onStart()方法等，函数位于 ActivityThread.java类。 Service 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name); ContextImpl context = new ContextImpl(); // 创建ContextImpl实例 context.init(packageInfo, null, this); Application app = packageInfo.makeApplication(false, mInstrumentation); context.setOuterContext(service); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, 0, 0, 0); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( &quot;Unable to create service &quot; + data.info.name + &quot;: &quot; + e.toString(), e); &#125; &#125;&#125; 通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，完成相关数据操作。handleCreateService()函数位于 ActivityThread.java类 看到这里，相信你对Context的理解更进一步了，现在我们知道了Context是什么，它为Android提供了怎样的资源、功能、和服务，又在什么时候将Application、Activity、Service与ContextImpl相关联，但是所请求的资源是不是同一套资源呢？ 在这里你一定说：“当然不是，不同的Context对象明显是有区别的，用法也不同” 但是其实他们访问的，确确实实，是同一套资源。 三：Context资源详解来吧，看看不同Context对象的区别和用法的不同，参见以下表格。 这张表格是不是又支持了你的观点(也就是一直认为的，Context资源对象是不同的)，但是还是要再次强调一次，它们所请求的，确确实实是同一块资源，看看上面进行关联的源码，都走进了Context实现类的init方法，拨云见日，我们去看看init方法吧。 查看ContextImpl类源码可以看到，getResources方法直接返回内部的mResources变量 123456789101112131415161718192021final void init(LoadedApk packageInfo, IBinder activityToken, ActivityThread mainThread, Resources container) &#123; mPackageInfo = packageInfo; mResources = mPackageInfo.getResources(mainThread); if (mResources != null &amp;&amp; container != null &amp;&amp; container.getCompatibilityInfo().applicationScale != mResources.getCompatibilityInfo().applicationScale) &#123; if (DEBUG) &#123; Log.d(TAG, &quot;loaded context has different scaling. Using container&apos;s&quot; + &quot; compatiblity info:&quot; + container.getDisplayMetrics()); &#125; mResources = mainThread.getTopLevelResources( mPackageInfo.getResDir(), container.getCompatibilityInfo().copy()); &#125; mMainThread = mainThread; mContentResolver = new ApplicationContentResolver(this, mainThread); setActivityToken(activityToken); &#125; mResources又是调用LoadedApk的getResources方法进行赋值。代码如下。 123456public Resources getResources(ActivityThread mainThread) &#123; if (mResources == null) &#123; mResources = mainThread.getTopLevelResources(mResDir, this); &#125; return mResources; &#125; 从代码中可以看到，最终mResources的赋值是由AcitivtyThread的getTopLevelResources方法返回。代码如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Resources getTopLevelResources(String resDir, CompatibilityInfo compInfo) &#123; ResourcesKey key = new ResourcesKey(resDir, compInfo.applicationScale); Resources r; synchronized (mPackages) &#123; // Resources is app scale dependent. if (false) &#123; Slog.w(TAG, &quot;getTopLevelResources: &quot; + resDir + &quot; / &quot; + compInfo.applicationScale); &#125; WeakReference&lt;Resources&gt; wr = mActiveResources.get(key); r = wr != null ? wr.get() : null; if (r != null &amp;&amp; r.getAssets().isUpToDate()) &#123; if (false) &#123; Slog.w(TAG, &quot;Returning cached resources &quot; + r + &quot; &quot; + resDir + &quot;: appScale=&quot; + r.getCompatibilityInfo().applicationScale); &#125; return r; &#125; &#125; AssetManager assets = new AssetManager(); if (assets.addAssetPath(resDir) == 0) &#123; return null; &#125; DisplayMetrics metrics = getDisplayMetricsLocked(false); r = new Resources(assets, metrics, getConfiguration(), compInfo); if (false) &#123; Slog.i(TAG, &quot;Created app resources &quot; + resDir + &quot; &quot; + r + &quot;: &quot; + r.getConfiguration() + &quot; appScale=&quot; + r.getCompatibilityInfo().applicationScale); &#125; synchronized (mPackages) &#123; WeakReference&lt;Resources&gt; wr = mActiveResources.get(key); Resources existing = wr != null ? wr.get() : null; if (existing != null &amp;&amp; existing.getAssets().isUpToDate()) &#123; // Someone else already created the resources while we were // unlocked; go ahead and use theirs. r.getAssets().close(); return existing; &#125; // XXX need to remove entries when weak references go away mActiveResources.put(key, new WeakReference&lt;Resources&gt;(r)); return r; &#125; &#125; 以上代码中，mActiveResources对象内部保存了该应用程序所使用到的所有Resources对象，其类型为WeakReference，所以当内存紧张时，可以释放Resources占用的资源，自然这不是我们探究的重点，ResourcesKey的构造需要resDir和compInfo.applicationScale。resdDir变量的含义是资源文件所在路径，实际指的是APK程序所在路径，比如可以是：/data/app/com.haii.android.xxx-1.apk，该apk会对应/data/dalvik-cache目录下的：data@app@com.haii.android.xxx-1.apk@classes.dex文件。 所以结论来了： 如果一个应用程序没有访问该程序以外的资源，那么mActiveResources变量中就仅有一个Resources对象。 总结： 当ActivityThread类中创建Application、Service、Activity的同时，完成了与ContextImpl的关联绑定，通过ContextImpl类中init方法，获得了一个唯一的Resources对象，根据上述代码中资源的请求机制，再加上ResourcesManager采用单例模式，这样就保证了不同的ContextImpl访问的是同一套资源。 如果这篇博客现在就结束了，你一定会杀了我 - -，现在我们就来分析下，是什么造成了唯一的这个Resources，却展现出了“不同”。 举个通俗易懂的例子，我和我老妈都拿到同一块土豆，但是因为我们处理这个土豆的方法有区别，导致这个土豆最后表现出来的也不一样，我想把它做成薯片，我妈妈把它炒成了土豆丝，:-D。 再具体一点，比如除了Activity可以创建一个Dialog，其它Context都不可以创建Dialog。比如在Application中创建Dialog会报错，还有Application和Service可以启动一个Activity，但是需要创建一个新的task。比如你在Application中调用startActivity（intent）时系统也会崩溃报错。 报错的原因并不是因为他们拿到的Context资源不同，拿到的都是一个Resoucres对象，但是在创建Dialog的时候会使用到Context对象去获取当前主题信息，但是我们知道Application和Service是继承自ContextWrapper，没有实现关于主题的功能，然而Activity是继承自ContextThemeWrapper，该类是实现了关于主题功能的，因此创建Dialog的时候必须依附于Activity的Context引用。 结论： Application、Service、Activity，它们本身对Resources资源处理方法的不同，造成了这个Resoucres最后表现出来的不一样，这么说大家就都懂了吧！ 四：Context内存泄漏关于Context的内存泄漏，找到一篇比较不错的文章分享给大家。 Android开发，中可能会导致内存泄露的问题 写在最后： Context可能还有更多深层次的知识需要我们去了解，比如Context这些封装类，是具体如何通过Binder跟ContextImpl进行关联的；资源对象都被存储在ArrayMap，为什么ArrayMap中会有可能存在多个资源对象，如何访问其他应用程序的Context资源等等，剩下的这些就靠大家慢慢发掘了~ 转载请注明出处。 如果大家觉得喜欢有价值，就关注我，点下赞哈，你们的支持是我持续原创的动力。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"},{"name":"Context","slug":"Context","permalink":"http://yoursite.com/tags/Context/"}]},{"title":"Android的性能优化总结","slug":"Android性能优化总结","date":"2016-07-27T13:18:04.904Z","updated":"2016-07-27T13:34:31.269Z","comments":true,"path":"2016/07/27/Android性能优化总结/","link":"","permalink":"http://yoursite.com/2016/07/27/Android性能优化总结/","excerpt":"Android的性能优化写在前面： 公司给了我一周的时间去学习Android性能的优化，参考了张明云老师的一片文章，并且用公司的实际项目进行测试（附有截图），还进行了一些知识点，注意事项以及很多网址链接的补充，希望这篇博文能让做性能测试的朋友们少走一些弯路。 文中没有贴出大段代码，但是几乎所有的知识点都有链接，点进去就能看你想看的。转载注明出处。","text":"Android的性能优化写在前面： 公司给了我一周的时间去学习Android性能的优化，参考了张明云老师的一片文章，并且用公司的实际项目进行测试（附有截图），还进行了一些知识点，注意事项以及很多网址链接的补充，希望这篇博文能让做性能测试的朋友们少走一些弯路。 文中没有贴出大段代码，但是几乎所有的知识点都有链接，点进去就能看你想看的。转载注明出处。 零：性能指标 布局复杂度：布局复杂会导致布局需要更长的时间，从而导致进入应用慢、页面切换慢； 耗电量：耗电量大会导致机器发热、缩短机器的有效使用时长； 内存：内存消耗大会导致频繁GC，GC时会暂停其它工作，导致页面卡顿；内存泄露会导致剩余可用内存越来越小；内存不足会导致应用异常； 网络：频繁的网络访问会导致耗电和影响应用的性能；网络交互数据大小会影响网络传输的效率； 程序执行效率：糟糕的代码会严重影响程序的运行效率，UI线程过多的任务会阻塞应用的正常运行，长时间持有某个对象会导致潜在的内存泄露，频繁的IO操作、网络操作而不用缓存会严重影响程序的运行效率。####一：布局复杂度的优化关于布局的优化，主要分两个大方向1. 实现相同界面效果并且层级结构相同时，选用何种Layout最好在Android中单独的布局性能： 1FrameLayout&gt;LinearLayout&gt;RelativeLayout 可供参考的网址：LinearLayout与RelativeLayout的性能比较总结: RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure; RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin; 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout; 使用组合控件性能要好于两个独立控件，比如一个文本旁边有一个图片，这中情况最好要用DrawableLeft的这种属性设置图片; 2. 减少布局的层级结构 HierarchyViewer—可查看布局层次结构，View绘制时耗时。HierarchyViewer的使用 无线UIViewer—强烈推荐App工具，可在手机端直接实现HierarchyViewer的功能，查看任意界面的UI布局。无线UIViewer下载 测试图片如下：当前界面的UI布局层级如上图所示 总结： 一些复用性很高的布局文件，比如一个App的标题栏，建议使用布局重用include标签，方便引入和共同管理。 观察上图第三个层级和第四个层级，无论是Layout类型，还是所覆盖的坐标点，都是重合的，因为父FrameLayout作为一个Container，子FrameLayout作为一个子View的跟布局，这种情况，可使用merge标签进行布局层级的优化。 有些在特定情况下才会出现的界面，比如联网之后，或者未必百分之百出现的界面，可用ViewStub标签进行懒加载，性能明显要优于加载出这个界面然后gone掉。 布局优化相关网址：三种优化标签的使用情景和优势—张业兴布局优化标签的源码分析 有关布局优化的一些基础知识准备(郭霖老师的两篇博客)：Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) 二：Android开发者模式—GPU过渡绘制GPU过度绘制定义： 如果你粉刷过一个房间或一所房子，就会知道给墙壁涂上颜色需要做大量的工作。假如你还要重新粉刷一次的话，第二次粉刷的颜色会覆盖住第一次的颜色，第一次的颜色就永远不可见了，等于你第一次粉刷做的大量工作就完全被浪费掉。这太可怕了。 同样的道理，如果在你的应用程序中浪费精力去绘制一些东西同样会产生性能问题。过度绘制这个名词就是用来描述屏幕上一个像素在单个帧中被重绘了多少次。 GPU过度绘制就指的是在屏幕一个像素上绘制多次(超过一次)，GPU过度绘制或多或少对性能有些影响。 GPU过度绘制分析： 过度绘制其实是一个性能和设计的交叉点。我们在设计上追求很华丽的视觉效果，但一般来说这种视觉效果会采用非常多的层叠组件来实现，这时候就会带来过度绘制的问题。我们再来看看具体显示在Android界面层级关系： 当我们来绘制一个界面时，会有一个windows，然后是建立Activity，在Activity里可以建立多个view，或view group，view也可以嵌套view。这些组件从上到下分布，上面的组件是可以被用户看见的，而在下面的组件是不可见的，但是我们依然要花很多时间去绘制那些不可见的组件，因为在某些时候，它也可能会显示出来。 检测过度绘制： 设置-开发者选项-调试GPU过度绘制-显示过度绘制区域(过度渲染等，不同机器可能不同) 测试的颜色标识含义： 项目测试截图： 可以看到项目中并不存在太大问题，有关减少过度绘制的一些建议： 太多重叠的背景 这个问题其实最容易解决，建议前期在设计时尽量保持整体背景统一，另外开发可以检查你在布局和代码中设置的背景，有些背景是被隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。 太多重叠的view 第一个建议是：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认不可见的视图，可以动态的加载一个布局，只有你用到这个重叠着的view的时候才加载，推迟加载的时间。第二个建议是：如果使用了类似viewpager+Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态地Inflation view，它的性能要比SetVisiblity好。 复杂的Layout层级 这里的建议比较多一些，首先推荐用Android提供的布局工具Hierarchy 三：Android中耗电量的测试深入浅出Android App耗电量统计 测试截图： 本人认为这一点没有过多补充的，大多数App都不会消耗过多的电量。 四：内存、CPU、GPU应用运行时内存使用情况查看：Android Studio—Memory/CPU/GPU 通常这种测试应该使用一个自动化工具（monkey）去不停的点击App，或者切换界面，来观察内存、cpu的情况。 内存 测试截图： 在地图界面不断地刷新，正常的内存成锯齿状分布。 需要注意的情况： 出现了针状分布，说明内存发生了突变，如果内存峰值不能降下来，就说明出现了内存溢出，就值得引起我们的关注了。 CPU 测试图片： GPU Android Studio 1.4增加一项新功能：分析GPU渲染功能。作者详细讲解这一新功能的分析方法。 在GPU选项卡下，可以在屏幕上看到图形化显示的渲染每帧所花费的时间。图形中每条都表示被渲染的一帧。颜色表示进程的不同周期： 绘画（蓝色）表示View#onDraw()方法。那部分建立/更改DisplayList对象，然后转换成GPU能够理解的OpenGL命令。高的条形可能是视图复杂，而要求更多的时间绘制它们的显示列表，而许多视图在短时间内就失效了。 准备（紫色）在Lollipop中，加入另一个线程，以帮助UI线程渲染更快。这个线程叫：RenderThread。它的责任是转换显示列表为OpenGL命令，再发送给GPU。这样在渲染过程中，UI线程可以开始处理下一个帧。这时UI线程将所有资源传送给RenderThread。如果有许多资源要传递（如许多/繁重显示列表），这一步可能需要较长时间。 处理（红色）执行显示列表产生OpenGL命令。由于需要视图重绘，如果有许多/复杂显示列表要执行转换，这一步可能需要较长时间。当视图无效或是移动时，都要要重绘视图。 执行（黄色）发送OpenGL命令到GPU。由于CPU发送这些缓存的命令到GPU，并期待收回干净缓存，这就阻塞调用了。缓存数量有限，并且GPU也很忙——CPU会发现自己必须先等待缓存释放。因此，如果在这一步我们见高的条形，就可能意味着GPU在绘制UI时非常忙，这个绘制在短时间内太复杂了。 测试截图： 结论： 可以通过切换界面，看图形的峰值和颜色去判断绘制View每个阶段所花费的时间，然后根据你的需求进行优化。 五：程序的执行效率 静态代码检查工具：Android studio—Analyze—Inspect Code…/Code cleanup… ，用于检测代码中潜在的问题、存在效率问题的代码段并提供改善方案； DDMS—TraceView，用于查找程序运行时具体耗时在哪； StrictMode：用于查找程序运行时具体耗时在哪，需要集成到代码中； ####六：知名的三方性能优化工具 LeakCanaryLeakCanary是一个检测内存泄露的开源类库。你可以在 debug包种轻松检测内存泄露。强烈推荐LeakCanary，大多数公司都在使用它进行内存泄漏的测试。 以下是我找到的学习资料，写的非常棒： LeakCanary:让内存泄露无所遁形 LeakCanary中文使用说明 具体使用请参考以上两个链接，下面给出一个测试截图，供大家直观感受其便捷和强大的功能。 结论： LeakCanary非常直观的展现了MainActivity出现了内存泄漏，并且指出引用路径中的哪个引用是不该有的，然后修复问题。总而言之非常好用，处理内存泄漏首选的工具。 GT GT是腾讯开发的一款APP的随身调测平台，利用GT，可以对CPU、内存、流量、点亮、帧率/流畅度进行测试，还可以查看开发日志、crash日志、抓取网络数据包、APP内部参数调试、真机代码耗时统计等等，需要说明的是，应用需要集成GT的sdk后，GT这个apk才能在应用运行时对各个性能进行检测。 GT官方网址 下面是使用GT测试项目的截图： 具体图片是什么含义，大家去点击官网去了解学习就可以，GT还是很全面好用的，慢慢发掘吧。 第一次写技术博客，并没有贴出大量代码，如果大家需要了解原理，点进链接去看就好了，如果有什么建议和问题大家可以给我留言。有什么好的工具和方法可以同大家一起分享。 如果对大家喜欢请点赞收藏哈，你们的认可是我写作的动力O(∩_∩)O","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"},{"name":"经验","slug":"经验","permalink":"http://yoursite.com/tags/经验/"}]}]}
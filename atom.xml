<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Melo&#39;s Blog</title>
  <subtitle>耐心的偏执狂，浪漫的现实主义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-07-27T13:34:37.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melo</name>
    <email>MeloAndroid@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你足够了解Context吗？</title>
    <link href="http://yoursite.com/2016/07/27/%E4%BD%A0%E8%B6%B3%E5%A4%9F%E4%BA%86%E8%A7%A3Context%E5%90%97/"/>
    <id>http://yoursite.com/2016/07/27/你足够了解Context吗/</id>
    <published>2016-07-27T13:29:52.585Z</published>
    <updated>2016-07-27T13:34:37.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你足够了解Context吗？"><a href="#你足够了解Context吗？" class="headerlink" title="你足够了解Context吗？"></a><strong>你足够了解Context吗？</strong></h2><p>这里有关于Context的一切<br>-<br><strong>写在前面：</strong></p>
<blockquote>
<p>当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。</p>
</blockquote>
<a id="more"></a>
<h2 id="零：官方定义"><a href="#零：官方定义" class="headerlink" title="零：官方定义"></a>零：官方定义</h2><p>好吧如果你无法翻墙，推荐你两个可以看官网文档的网站：</p>
<p><a href="http://wear.techbrood.com/" target="_blank" rel="external">Android官方文档国内镜像站点</a></p>
<p><a href="http://www.android-doc.com/" target="_blank" rel="external">Android中文API</a></p>
<p><strong>我们来看看官方文档中，Context的解释</strong></p>
<blockquote>
<p>Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.</p>
</blockquote>
<ul>
<li>一个应用环境的全局信息，字面意思是上下文的意思;</li>
<li>Context是一个抽象类;</li>
<li>允许我们通过Context获取各种资源，服务，或者去启动一个Activity，发送一个广播，等等;</li>
</ul>
<p>怎么去理解Context呢？其实Context就是给Android应用程序提供了一个可以实现各种操作的土壤环境，Context为Android提供了各种资源、功能、服务。如果说编写一个Android程序像搭建一座房子，那Context就为Android提供了土地，木材，和染料(启动一个Activity，弹出一个Dialog)，并且能提供呼叫各种将房屋建得更完善的其他帮助(发送一个广播，启动一个服务等)。</p>
<h2 id="一：继承关系"><a href="#一：继承关系" class="headerlink" title="一：继承关系"></a>一：继承关系</h2><p><img src="http://upload-images.jianshu.io/upload_images/1915184-21051266e7de1602?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Context继承关系"></p>
<p>通过继承关系可以看到，Context直接子类为ContextIml（实现类）和ContextWrapper（包装类）</p>
<p>再看看ContextWrapper的子类有什么，看到熟悉的Service和Application了吧，不过看到这里你一定有个疑问，为什么Activity和他们哥俩不在一个继承层级呢？而是Activity又继承了ContextThemeWrapper，那么ContextWrapper和ContextThemeWrapper的区别在哪里呢？</p>
<p>看到这两个类的名字，相信你心里已经有了答案，对，区别在<strong>Theme</strong>。</p>
<p><strong>该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。</strong><br>只有Activity需要主题，Service不需要主题，<br>   所以Service直接继承于ContextWrapper类。而Activity因为含有Theme属性的缘故，所以继承自ContextThemeWrapper。</p>
<p><strong>所以说，Context所调用的资源是不同的了？</strong>保留这个疑问，继续向下看。</p>
<h2 id="二：源码阅读"><a href="#二：源码阅读" class="headerlink" title="二：源码阅读"></a>二：源码阅读</h2><p>看到了继承结构，我们分别来看看Context及其子类的一些源码</p>
<ul>
<li><strong>Context</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">public abstract class Context &#123;</div><div class="line"></div><div class="line">    // 获取应用程序包的AssetManager实例</div><div class="line">    public abstract AssetManager getAssets();</div><div class="line"> </div><div class="line">    // 获取应用程序包的Resources实例</div><div class="line">    public abstract Resources getResources();</div><div class="line"></div><div class="line">    // 获取PackageManager实例，以查看全局package信息	</div><div class="line">    public abstract PackageManager getPackageManager();</div><div class="line"></div><div class="line">    // 获取应用程序包的ContentResolver实例</div><div class="line">    public abstract ContentResolver getContentResolver();</div><div class="line">    </div><div class="line">    // 它返回当前进程的主线程的Looper，此线程分发调用给应用组件(activities, services等)</div><div class="line">    public abstract Looper getMainLooper();</div><div class="line"></div><div class="line">    // 返回当前进程的单实例全局Application对象的Context     </div><div class="line">    public abstract Context getApplicationContext();</div><div class="line"></div><div class="line">    // 从string表中获取本地化的、格式化的字符序列</div><div class="line">    public final CharSequence getText(int resId) &#123;</div><div class="line">        return getResources().getText(resId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 从string表中获取本地化的字符串</div><div class="line">    public final String getString(int resId) &#123;</div><div class="line">        return getResources().getString(resId);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final String getString(int resId, Object... formatArgs) &#123;</div><div class="line">        return getResources().getString(resId, formatArgs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回一个可用于获取包中类信息的class loader</div><div class="line">    public abstract ClassLoader getClassLoader();</div><div class="line"></div><div class="line">    // 返回应用程序包名</div><div class="line">    public abstract String getPackageName();</div><div class="line"></div><div class="line">    // 返回应用程序信息</div><div class="line">    public abstract ApplicationInfo getApplicationInfo();</div><div class="line"></div><div class="line">    // 根据文件名获取SharedPreferences</div><div class="line">    public abstract SharedPreferences getSharedPreferences(String name,</div><div class="line">            int mode);</div><div class="line"></div><div class="line">    // 其根目录为: Environment.getExternalStorageDirectory()</div><div class="line">    </div><div class="line">    public abstract File getExternalFilesDir(String type);</div><div class="line"></div><div class="line">    // 返回应用程序obb文件路径</div><div class="line">    public abstract File getObbDir();</div><div class="line"></div><div class="line">    // 启动一个新的activity </div><div class="line">    public abstract void startActivity(Intent intent);</div><div class="line"></div><div class="line">    // 启动一个新的activity </div><div class="line">    public void startActivityAsUser(Intent intent, UserHandle user) &#123;</div><div class="line">        throw new RuntimeException(&quot;Not implemented. Must override in a subclass.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 启动一个新的activity </div><div class="line">    // intent: 将被启动的activity的描述信息</div><div class="line">    // options: 描述activity将如何被启动</div><div class="line">    public abstract void startActivity(Intent intent, Bundle options);</div><div class="line"></div><div class="line">    // 启动多个新的activity</div><div class="line">    public abstract void startActivities(Intent[] intents);</div><div class="line"></div><div class="line">    // 启动多个新的activity</div><div class="line">    public abstract void startActivities(Intent[] intents, Bundle options);</div><div class="line"></div><div class="line">    // 广播一个intent给所有感兴趣的接收者，异步机制 </div><div class="line">    public abstract void sendBroadcast(Intent intent);</div><div class="line"></div><div class="line">    // 广播一个intent给所有感兴趣的接收者，异步机制 </div><div class="line">    public abstract void sendBroadcast(Intent intent,String receiverPermission);</div><div class="line"></div><div class="line">    public abstract void sendOrderedBroadcast(Intent intent,String receiverPermission);</div><div class="line"> </div><div class="line">    public abstract void sendOrderedBroadcast(Intent intent,</div><div class="line">            String receiverPermission, BroadcastReceiver resultReceiver,</div><div class="line">            Handler scheduler, int initialCode, String initialData,</div><div class="line">            Bundle initialExtras);</div><div class="line"></div><div class="line">    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user);</div><div class="line"></div><div class="line">    public abstract void sendBroadcastAsUser(Intent intent, UserHandle user,</div><div class="line">            String receiverPermission);</div><div class="line">  </div><div class="line">    // 注册一个BroadcastReceiver，且它将在主activity线程中运行</div><div class="line">    public abstract Intent registerReceiver(BroadcastReceiver receiver,</div><div class="line">                                            IntentFilter filter);</div><div class="line"></div><div class="line">    public abstract Intent registerReceiver(BroadcastReceiver receiver,</div><div class="line">            IntentFilter filter, String broadcastPermission, Handler scheduler);</div><div class="line"></div><div class="line">    public abstract void unregisterReceiver(BroadcastReceiver receiver);</div><div class="line"> </div><div class="line">    // 请求启动一个application service</div><div class="line">    public abstract ComponentName startService(Intent service);</div><div class="line"></div><div class="line">    // 请求停止一个application service</div><div class="line">    public abstract boolean stopService(Intent service);</div><div class="line"> </div><div class="line">    // 连接一个应用服务，它定义了application和service间的依赖关系</div><div class="line">    public abstract boolean bindService(Intent service, ServiceConnection conn,</div><div class="line">            int flags);</div><div class="line"></div><div class="line">    // 断开一个应用服务，当服务重新开始时，将不再接收到调用， </div><div class="line">    // 且服务允许随时停止</div><div class="line">    public abstract void unbindService(ServiceConnection conn);</div><div class="line"> </div><div class="line">    public abstract Object getSystemService(String name);</div><div class="line"> </div><div class="line">    public abstract int checkPermission(String permission, int pid, int uid);</div><div class="line"> </div><div class="line">    // 返回一个新的与application name对应的Context对象</div><div class="line">    public abstract Context createPackageContext(String packageName,</div><div class="line">            int flags) throws PackageManager.NameNotFoundException;</div><div class="line">    </div><div class="line">    // 返回基于当前Context对象的新对象，其资源与display相匹配</div><div class="line">    public abstract Context createDisplayContext(Display display);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Context的源码算上注释有3000行之多，这里贴出一些重要代码，可以看到，Context几乎包含了所有你能想到的，一个Android程序需要的资源和操作，Context自己就像一个App一样，启动Activity、Service，发送Broadcast，拿到assets下的资源，获取SharedPreferences等等。</p>
<p>但Context只是一个顶层接口啊，又是谁帮他实现了操作呢？是<strong>ContextWrapper</strong>吗？</p>
<ul>
<li><strong>ContextWrapper</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class ContextWrapper extends Context &#123;</div><div class="line">    Context mBase; //该属性指向一个ContextIml实例</div><div class="line"></div><div class="line">    public ContextWrapper(Context base) &#123;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param base The new base context for this wrapper.</div><div class="line">     * 创建Application、Service、Activity，会调用该方法给mBase属性赋值</div><div class="line">     */</div><div class="line">    protected void attachBaseContext(Context base) &#123;</div><div class="line">        if (mBase != null) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);</div><div class="line">        &#125;</div><div class="line">        mBase = base;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Looper getMainLooper() &#123;</div><div class="line">        return mBase.getMainLooper();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getSystemService(String name) &#123;</div><div class="line">        return mBase.getSystemService(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void startActivity(Intent intent) &#123;</div><div class="line">        mBase.startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，ContextWrapper好像很懒的样子，它把所有操作都丢给了mBase，mBase又是谁呢？在构造方法和attachBaseContext方法中，指向了一个Context实例，<strong>ContextIml</strong>，我们赶紧来看看ContextIml的源码！</p>
<ul>
<li><strong>ContextImpl</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Common implementation of Context API, which provides the base</div><div class="line"> * context object for Activity and other application components.</div><div class="line"> */</div><div class="line">class ContextImpl extends Context &#123;</div><div class="line">    private final static String TAG = &quot;ContextImpl&quot;;</div><div class="line">    private final static boolean DEBUG = false;</div><div class="line"></div><div class="line">    private static final HashMap&lt;String, SharedPreferencesImpl&gt; sSharedPrefs =</div><div class="line">            new HashMap&lt;String, SharedPreferencesImpl&gt;();</div><div class="line"></div><div class="line">    /*package*/ LoadedApk mPackageInfo; // 关键数据成员</div><div class="line">    private String mBasePackageName;</div><div class="line">    private Resources mResources;</div><div class="line">    /*package*/ ActivityThread mMainThread; // 主线程</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public AssetManager getAssets() &#123;</div><div class="line">        return getResources().getAssets();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Looper getMainLooper() &#123;</div><div class="line">        return mMainThread.getLooper();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getSystemService(String name) &#123;</div><div class="line">        ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);</div><div class="line">        return fetcher == null ? null : fetcher.getService(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void startActivity(Intent intent, Bundle options) &#123;</div><div class="line">        warnIfCallingFromSystemProcess();</div><div class="line">        if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123;</div><div class="line">            throw new AndroidRuntimeException(</div><div class="line">                    &quot;Calling startActivity() from outside of an Activity &quot;</div><div class="line">                    + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</div><div class="line">                    + &quot; Is this really what you want?&quot;);</div><div class="line">        &#125;</div><div class="line">        mMainThread.getInstrumentation().execStartActivity(</div><div class="line">            getOuterContext(), mMainThread.getApplicationThread(), null,</div><div class="line">            (Activity)null, intent, -1, options);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实ContextImpl才是在Context的所有继承结构中唯一一个真正实现了Context中方法的类。其它Context的子类，Application，Activity，Service，都是与ContextImpl相关联，去获取资源和服务，并没有真正自己去实现，这里就不贴上ContextThemeWrapper的源码了，它是为Activity添加了一些Theme的属性，不再赘述。</p>
<p>思路越来越清晰，我们现在就是要去寻找，<strong>Activity，Service，Application</strong>是何时与<strong>ContextImpl</strong>完成绑定关联的。</p>
<h2 id="三：关联时机"><a href="#三：关联时机" class="headerlink" title="三：关联时机"></a>三：关联时机</h2><p>我们都知道<strong>ActivityThread</strong>的<strong>main</strong>方法，是整个<strong>Android</strong>程序的入口，所以去探究<strong>ActivityThread</strong>类，也是一件非常重要的事。</p>
<p>推荐一篇文章，去了解下<strong>ActivityThread</strong>吧</p>
<p><a href="http://blog.csdn.net/myarrow/article/details/14223493" target="_blank" rel="external">ActivityThread简介</a></p>
<p>贴出ActivityThread的main方法部分重要的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div></pre></td><td class="code"><pre><div class="line">public final class ActivityThread &#123;  </div><div class="line"></div><div class="line">	static ContextImpl mSystemContext = null;  </div><div class="line">	</div><div class="line">    static IPackageManager sPackageManager;</div><div class="line">    </div><div class="line">	// 创建ApplicationThread实例，以接收AMS指令并执行  </div><div class="line">    final ApplicationThread mAppThread = new ApplicationThread();  </div><div class="line">  </div><div class="line">    final Looper mLooper = Looper.myLooper();  </div><div class="line">    </div><div class="line">	final HashMap&lt;IBinder, ActivityClientRecord&gt; mActivities  </div><div class="line">            = new HashMap&lt;IBinder, ActivityClientRecord&gt;();  </div><div class="line">            </div><div class="line">	final HashMap&lt;IBinder, Service&gt; mServices  </div><div class="line">            = new HashMap&lt;IBinder, Service&gt;();  </div><div class="line">            </div><div class="line">    final H mH = new H();  </div><div class="line"></div><div class="line">	Application mInitialApplication;  </div><div class="line">  </div><div class="line">    final ArrayList&lt;Application&gt; mAllApplications  </div><div class="line">            = new ArrayList&lt;Application&gt;();  </div><div class="line">  </div><div class="line">    static final ThreadLocal&lt;ActivityThread&gt; sThreadLocal = new ThreadLocal&lt;ActivityThread&gt;();  </div><div class="line">    </div><div class="line">    Instrumentation mInstrumentation;  </div><div class="line">  </div><div class="line">    static Handler sMainThreadHandler;  // set once in main()  </div><div class="line"></div><div class="line">    private class H extends Handler &#123;  </div><div class="line">  </div><div class="line">        public void handleMessage(Message msg) &#123;  </div><div class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));  </div><div class="line">            switch (msg.what) &#123;  </div><div class="line">                case LAUNCH_ACTIVITY: &#123;  </div><div class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);  </div><div class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;  </div><div class="line">  </div><div class="line">                    r.packageInfo = getPackageInfoNoCheck(  </div><div class="line">                            r.activityInfo.applicationInfo, r.compatInfo);  </div><div class="line">                    handleLaunchActivity(r, null);  </div><div class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </div><div class="line">                &#125; break;  </div><div class="line">                ...  </div><div class="line">            &#125;  </div><div class="line">            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what));  </div><div class="line">        &#125;  </div><div class="line">         </div><div class="line">        ...  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">	private class ApplicationThread extends ApplicationThreadNative &#123;  </div><div class="line">  </div><div class="line">        private void updatePendingConfiguration(Configuration config) &#123;  </div><div class="line">            synchronized (mPackages) &#123;  </div><div class="line">                if (mPendingConfiguration == null ||  </div><div class="line">                        mPendingConfiguration.isOtherSeqNewer(config)) &#123;  </div><div class="line">                    mPendingConfiguration = config;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        public final void schedulePauseActivity(IBinder token, boolean finished,  </div><div class="line">                boolean userLeaving, int configChanges) &#123;  </div><div class="line">            queueOrSendMessage(  </div><div class="line">                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,  </div><div class="line">                    token,  </div><div class="line">                    (userLeaving ? 1 : 0),  </div><div class="line">                    configChanges);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        // we use token to identify this activity without having to send the  </div><div class="line">        // activity itself back to the activity manager. (matters more with ipc)  </div><div class="line">        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,  </div><div class="line">                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,  </div><div class="line">                Bundle state, List&lt;ResultInfo&gt; pendingResults,  </div><div class="line">                List&lt;Intent&gt; pendingNewIntents, boolean notResumed, boolean isForward,  </div><div class="line">                String profileName, ParcelFileDescriptor profileFd, boolean autoStopProfiler) &#123;  </div><div class="line">            ActivityClientRecord r = new ActivityClientRecord();  </div><div class="line">  </div><div class="line">            r.token = token;  </div><div class="line">            r.ident = ident;  </div><div class="line">            r.intent = intent;  </div><div class="line">            r.activityInfo = info;  </div><div class="line">            r.compatInfo = compatInfo;  </div><div class="line">            r.state = state;  </div><div class="line">  </div><div class="line">            r.pendingResults = pendingResults;  </div><div class="line">            r.pendingIntents = pendingNewIntents;  </div><div class="line">  </div><div class="line">            r.startsNotResumed = notResumed;  </div><div class="line">            r.isForward = isForward;  </div><div class="line">  </div><div class="line">            r.profileFile = profileName;  </div><div class="line">            r.profileFd = profileFd;  </div><div class="line">            r.autoStopProfiler = autoStopProfiler;  </div><div class="line">  </div><div class="line">            updatePendingConfiguration(curConfig);  </div><div class="line">  </div><div class="line">            queueOrSendMessage(H.LAUNCH_ACTIVITY, r);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        ...  </div><div class="line">    &#125;</div><div class="line">	public static void main(String[] args) &#123;  </div><div class="line">        SamplingProfilerIntegration.start();  </div><div class="line">  </div><div class="line">        // CloseGuard defaults to true and can be quite spammy.  We  </div><div class="line">        // disable it here, but selectively enable it later (via  </div><div class="line">        // StrictMode) on debug builds, but using DropBox, not logs.  </div><div class="line">        CloseGuard.setEnabled(false);  </div><div class="line">  </div><div class="line">        Environment.initForCurrentUser();  </div><div class="line">  </div><div class="line">        // Set the reporter for event logging in libcore  </div><div class="line">        EventLogger.setReporter(new EventLoggingReporter());  </div><div class="line">  </div><div class="line">        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);  </div><div class="line">  </div><div class="line">        Looper.prepareMainLooper();  </div><div class="line">  </div><div class="line">        // 创建ActivityThread实例  </div><div class="line">        ActivityThread thread = new ActivityThread();  </div><div class="line">        thread.attach(false);  </div><div class="line">  </div><div class="line">        if (sMainThreadHandler == null) &#123;  </div><div class="line">            sMainThreadHandler = thread.getHandler();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        AsyncTask.init();  </div><div class="line">  </div><div class="line">        if (false) &#123;  </div><div class="line">            Looper.myLooper().setMessageLogging(new  </div><div class="line">                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        Looper.loop();  </div><div class="line">  </div><div class="line">        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);  </div><div class="line">    &#125; </div><div class="line">	public void handleMessage(Message msg) &#123;  </div><div class="line">	    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));  </div><div class="line">	    switch (msg.what) &#123;  </div><div class="line">	        case LAUNCH_ACTIVITY: &#123; // 创建Activity对象  </div><div class="line">	            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);  </div><div class="line">	            ActivityClientRecord r = (ActivityClientRecord)msg.obj;  </div><div class="line">  </div><div class="line">	            r.packageInfo = getPackageInfoNoCheck(  </div><div class="line">	                    r.activityInfo.applicationInfo, r.compatInfo);  </div><div class="line">	            handleLaunchActivity(r, null);  </div><div class="line">	            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </div><div class="line">	        &#125; break;  </div><div class="line">  </div><div class="line">	        case BIND_APPLICATION: // 创建Application对象  </div><div class="line">	            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);  </div><div class="line">	            AppBindData data = (AppBindData)msg.obj;  </div><div class="line">	            handleBindApplication(data);  </div><div class="line">	            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </div><div class="line">	            break;  </div><div class="line">  </div><div class="line">	        case CREATE_SERVICE: // 创建Service对象  </div><div class="line">	            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceCreate&quot;);  </div><div class="line">	            handleCreateService((CreateServiceData)msg.obj);  </div><div class="line">	            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </div><div class="line">	            break;  </div><div class="line">              </div><div class="line">	        case BIND_SERVICE:  // Bind Service对象  </div><div class="line">	            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;serviceBind&quot;);  </div><div class="line">	            handleBindService((BindServiceData)msg.obj);  </div><div class="line">	            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </div><div class="line">	            break;  </div><div class="line">	    &#125;  </div><div class="line">	&#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也许你不能完全看懂、理解这些代码，不过没关系，直接告诉你结论吧，ActivityThread的一个内部类H，里面定义了activity、service等启动、销毁等事件的响应，也就是说activity、service的启动、销毁都是在ActivityThread中进行的。</p>
<p>当然了，一个<strong>Activity</strong>或者<strong>Service</strong>的从创建到启动是相当复杂的，其中还涉及的<strong>Binder</strong>机制等等原理，推荐给大家两篇博文，去慢慢研读消化吧。</p>
<p><a href="http://blog.csdn.net/stonecao/article/details/6591847" target="_blank" rel="external">Activity启动原理详解</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6677029" target="_blank" rel="external">Service启动原理分析</a></p>
<p>准备工作不知不觉就做了这么多，差点忘了正事，我们还是要继续寻找<strong>Application</strong>、<strong>Activity</strong>、<strong>Service</strong>是何时与<strong>ContextImpl</strong>进行关联的。</p>
<ul>
<li><strong>Application</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// ActivityThread.java</div><div class="line">private void handleBindApplication(AppBindData data) &#123; </div><div class="line">   try &#123;</div><div class="line">         // If the app is being launched for full backup or restore, bring it up in</div><div class="line">         // a restricted environment with the base application class.</div><div class="line">         Application app = data.info.makeApplication(data.restrictedBackupMode, null);</div><div class="line">         mInitialApplication = app;</div><div class="line">         ...</div><div class="line">     &#125; finally &#123;</div><div class="line">         StrictMode.setThreadPolicy(savedPolicy);</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// LoadedApk.java</div><div class="line">public Application makeApplication(boolean forceDefaultAppClass,</div><div class="line">         Instrumentation instrumentation) &#123;</div><div class="line">     if (mApplication != null) &#123;</div><div class="line">         return mApplication;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Application app = null;</div><div class="line"></div><div class="line">     String appClass = mApplicationInfo.className;</div><div class="line">     if (forceDefaultAppClass || (appClass == null)) &#123;</div><div class="line">         appClass = &quot;android.app.Application&quot;;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     try &#123;</div><div class="line">         java.lang.ClassLoader cl = getClassLoader();</div><div class="line">         ContextImpl appContext = new ContextImpl(); // 创建ContextImpl实例</div><div class="line">         appContext.init(this, null, mActivityThread);</div><div class="line">         app = mActivityThread.mInstrumentation.newApplication(</div><div class="line">                 cl, appClass, appContext);</div><div class="line">         appContext.setOuterContext(app); // 将Application实例传递给Context实例</div><div class="line">     &#125; catch (Exception e) &#123;</div><div class="line">         ...</div><div class="line">     &#125;</div><div class="line">     mActivityThread.mAllApplications.add(app);</div><div class="line">     mApplication = app;</div><div class="line"></div><div class="line">     return app;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>每个应用程序在第一次启动时，都会首先创建一个Application对象。从startActivity流程可知，创建Application的时机在handleBindApplication()方法中，该函数位于 ActivityThread.java类</p>
<ul>
<li><strong>Activity</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">  private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    ...</div><div class="line">    Activity a = performLaunchActivity(r, customIntent); // 到下一步</div><div class="line"></div><div class="line">    if (a != null) &#123;</div><div class="line">        r.createdConfig = new Configuration(mConfiguration);</div><div class="line">        Bundle oldState = r.state;</div><div class="line">        handleResumeActivity(r.token, false, r.isForward,</div><div class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line"> &#125;</div><div class="line"></div><div class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</div><div class="line">    ...    </div><div class="line">    Activity activity = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</div><div class="line">        activity = mInstrumentation.newActivity(</div><div class="line">                cl, component.getClassName(), r.intent);</div><div class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</div><div class="line">        r.intent.setExtrasClassLoader(cl);</div><div class="line">        if (r.state != null) &#123;</div><div class="line">            r.state.setClassLoader(cl);</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        Application app = r.packageInfo.makeApplication(false, mInstrumentation);</div><div class="line"></div><div class="line">        if (activity != null) &#123;</div><div class="line">            Context appContext = createBaseContextForActivity(r, activity); // 创建Context</div><div class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</div><div class="line">            Configuration config = new Configuration(mCompatConfiguration);</div><div class="line">            if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot;</div><div class="line">                    + r.activityInfo.name + &quot; with config &quot; + config);</div><div class="line">            activity.attach(appContext, this, getInstrumentation(), r.token,</div><div class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</div><div class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config);</div><div class="line"></div><div class="line">            if (customIntent != null) &#123;</div><div class="line">                activity.mIntent = customIntent;</div><div class="line">            &#125;</div><div class="line">            r.lastNonConfigurationInstances = null;</div><div class="line">            activity.mStartedActivity = false;</div><div class="line">            int theme = r.activityInfo.getThemeResource();</div><div class="line">            if (theme != 0) &#123;</div><div class="line">                activity.setTheme(theme);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">        mActivities.put(r.token, r);</div><div class="line"></div><div class="line">    &#125; catch (SuperNotCalledException e) &#123;</div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return activity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private Context createBaseContextForActivity(ActivityClientRecord r,</div><div class="line">        final Activity activity) &#123;</div><div class="line">    ContextImpl appContext = new ContextImpl();  // 创建ContextImpl实例</div><div class="line">    appContext.init(r.packageInfo, r.token, this);</div><div class="line">    appContext.setOuterContext(activity);</div><div class="line"></div><div class="line">    // For debugging purposes, if the activity&apos;s package name contains the value of</div><div class="line">    // the &quot;debug.use-second-display&quot; system property as a substring, then show</div><div class="line">    // its content on a secondary display if there is one.</div><div class="line">    Context baseContext = appContext;</div><div class="line">    String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;);</div><div class="line">    if (pkgName != null &amp;&amp; !pkgName.isEmpty()</div><div class="line">            &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) &#123;</div><div class="line">        DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance();</div><div class="line">        for (int displayId : dm.getDisplayIds()) &#123;</div><div class="line">            if (displayId != Display.DEFAULT_DISPLAY) &#123;</div><div class="line">                Display display = dm.getRealDisplay(displayId);</div><div class="line">                baseContext = appContext.createDisplayContext(display);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return baseContext;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过startActivity()或startActivityForResult()请求启动一个Activity时，如果系统检测需要新建一个Activity对象时，就会回调handleLaunchActivity()方法，该方法继而调用performLaunchActivity()方法，去创建一个Activity实例，并且回调onCreate()，onStart()方法等，函数位于 ActivityThread.java类。</p>
<ul>
<li><strong>Service</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">private void handleCreateService(CreateServiceData data) &#123;</div><div class="line">    // If we are getting ready to gc after going to the background, well</div><div class="line">    // we are back active so skip it.</div><div class="line">    unscheduleGcIdler();</div><div class="line"></div><div class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</div><div class="line">            data.info.applicationInfo, data.compatInfo);</div><div class="line">    Service service = null;</div><div class="line">    try &#123;</div><div class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</div><div class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(service, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                &quot;Unable to instantiate service &quot; + data.info.name</div><div class="line">                + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        if (localLOGV) Slog.v(TAG, &quot;Creating service &quot; + data.info.name);</div><div class="line"></div><div class="line">        ContextImpl context = new ContextImpl(); // 创建ContextImpl实例</div><div class="line">        context.init(packageInfo, null, this);</div><div class="line"></div><div class="line">        Application app = packageInfo.makeApplication(false, mInstrumentation);</div><div class="line">        context.setOuterContext(service);</div><div class="line">        service.attach(context, this, data.info.name, data.token, app,</div><div class="line">                ActivityManagerNative.getDefault());</div><div class="line">        service.onCreate();</div><div class="line">        mServices.put(data.token, service);</div><div class="line">        try &#123;</div><div class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</div><div class="line">                    data.token, 0, 0, 0);</div><div class="line">        &#125; catch (RemoteException e) &#123;</div><div class="line">            // nothing to do.</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        if (!mInstrumentation.onException(service, e)) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                &quot;Unable to create service &quot; + data.info.name</div><div class="line">                + &quot;: &quot; + e.toString(), e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过startService或者bindService时，如果系统检测到需要新创建一个Service实例，就会回调handleCreateService()方法，完成相关数据操作。handleCreateService()函数位于 ActivityThread.java类</p>
<blockquote>
<p>看到这里，相信你对Context的理解更进一步了，现在我们知道了Context是什么，它为Android提供了怎样的资源、功能、和服务，又在什么时候将Application、Activity、Service与ContextImpl相关联，但是所请求的资源是不是同一套资源呢？</p>
</blockquote>
<p>在这里你一定说：“当然不是，不同的Context对象明显是有区别的，用法也不同”</p>
<p>但是其实他们访问的，确确实实，是<strong>同一套</strong>资源。</p>
<h2 id="三：Context资源详解"><a href="#三：Context资源详解" class="headerlink" title="三：Context资源详解"></a>三：Context资源详解</h2><p>来吧，看看不同Context对象的区别和用法的不同，参见以下表格。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-c666a310a5737c5f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Context用法区别"></p>
<p>这张表格是不是又支持了你的观点(也就是一直认为的，Context资源对象是不同的)，但是还是要再次强调一次，它们所请求的，确确实实是同一块资源，看看上面进行关联的源码，都走进了Context实现类的<strong>init</strong>方法，拨云见日，我们去看看<strong>init</strong>方法吧。</p>
<p>查看ContextImpl类源码可以看到，<strong>getResources</strong>方法直接返回内部的<strong>mResources</strong>变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">final void init(LoadedApk packageInfo,  </div><div class="line">            IBinder activityToken, ActivityThread mainThread,  </div><div class="line">            Resources container) &#123;  </div><div class="line">    mPackageInfo = packageInfo;  </div><div class="line">    mResources = mPackageInfo.getResources(mainThread);  </div><div class="line">  </div><div class="line">    if (mResources != null &amp;&amp; container != null  </div><div class="line">            &amp;&amp; container.getCompatibilityInfo().applicationScale !=  </div><div class="line">                    mResources.getCompatibilityInfo().applicationScale) &#123;  </div><div class="line">        if (DEBUG) &#123;  </div><div class="line">            Log.d(TAG, &quot;loaded context has different scaling. Using container&apos;s&quot; +  </div><div class="line">                    &quot; compatiblity info:&quot; + container.getDisplayMetrics());  </div><div class="line">        &#125;  </div><div class="line">        mResources = mainThread.getTopLevelResources(  </div><div class="line">                mPackageInfo.getResDir(), container.getCompatibilityInfo().copy());  </div><div class="line">    &#125;  </div><div class="line">    mMainThread = mainThread;  </div><div class="line">    mContentResolver = new ApplicationContentResolver(this, mainThread);  </div><div class="line">  </div><div class="line">    setActivityToken(activityToken);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>mResources</strong>又是调用<strong>LoadedApk</strong>的<strong>getResources</strong>方法进行赋值。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Resources getResources(ActivityThread mainThread) &#123;  </div><div class="line">    if (mResources == null) &#123;  </div><div class="line">        mResources = mainThread.getTopLevelResources(mResDir, this);  </div><div class="line">    &#125;  </div><div class="line">    return mResources;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看到，最终<strong>mResources</strong>的赋值是由<strong>AcitivtyThread</strong>的<strong>getTopLevelResources</strong>方法返回。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">Resources getTopLevelResources(String resDir, CompatibilityInfo compInfo) &#123;  </div><div class="line">    ResourcesKey key = new ResourcesKey(resDir, compInfo.applicationScale);  </div><div class="line">    Resources r;  </div><div class="line">    synchronized (mPackages) &#123;  </div><div class="line">        // Resources is app scale dependent.  </div><div class="line">        if (false) &#123;  </div><div class="line">            Slog.w(TAG, &quot;getTopLevelResources: &quot; + resDir + &quot; / &quot;  </div><div class="line">                    + compInfo.applicationScale);  </div><div class="line">        &#125;  </div><div class="line">        WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);  </div><div class="line">        r = wr != null ? wr.get() : null;  </div><div class="line">          </div><div class="line">        if (r != null &amp;&amp; r.getAssets().isUpToDate()) &#123;  </div><div class="line">            if (false) &#123;  </div><div class="line">                Slog.w(TAG, &quot;Returning cached resources &quot; + r + &quot; &quot; + resDir  </div><div class="line">                        + &quot;: appScale=&quot; + r.getCompatibilityInfo().applicationScale);  </div><div class="line">            &#125;  </div><div class="line">            return r;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    AssetManager assets = new AssetManager();  </div><div class="line">    if (assets.addAssetPath(resDir) == 0) &#123;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    DisplayMetrics metrics = getDisplayMetricsLocked(false);  </div><div class="line">    r = new Resources(assets, metrics, getConfiguration(), compInfo);  </div><div class="line">    if (false) &#123;  </div><div class="line">        Slog.i(TAG, &quot;Created app resources &quot; + resDir + &quot; &quot; + r + &quot;: &quot;  </div><div class="line">                + r.getConfiguration() + &quot; appScale=&quot;  </div><div class="line">                + r.getCompatibilityInfo().applicationScale);  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    synchronized (mPackages) &#123;  </div><div class="line">        WeakReference&lt;Resources&gt; wr = mActiveResources.get(key);  </div><div class="line">        Resources existing = wr != null ? wr.get() : null;  </div><div class="line">        if (existing != null &amp;&amp; existing.getAssets().isUpToDate()) &#123;  </div><div class="line">            // Someone else already created the resources while we were  </div><div class="line">            // unlocked; go ahead and use theirs.  </div><div class="line">            r.getAssets().close();  </div><div class="line">            return existing;  </div><div class="line">        &#125;  </div><div class="line">        // XXX need to remove entries when weak references go away  </div><div class="line">        mActiveResources.put(key, new WeakReference&lt;Resources&gt;(r));  </div><div class="line">        return r;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码中，mActiveResources对象内部保存了该应用程序所使用到的所有Resources对象，其类型为<strong>WeakReference</strong>，所以当内存紧张时，可以释放<strong>Resources</strong>占用的资源，自然这不是我们探究的重点，ResourcesKey的构造需要resDir和compInfo.applicationScale。resdDir变量的含义是资源文件所在路径，实际指的是APK程序所在路径，比如可以是：/data/app/com.haii.android.xxx-1.apk，该apk会对应/data/dalvik-cache目录下的：data@app@com.haii.android.xxx-1.apk@classes.dex文件。</p>
<p><strong>所以结论来了：</strong></p>
<p>如果一个应用程序没有访问该程序以外的资源，那么mActiveResources变量中就仅有一个<strong>Resources</strong>对象。</p>
<p><strong>总结：</strong></p>
<p>当ActivityThread类中创建Application、Service、Activity的同时，完成了与ContextImpl的关联绑定，通过ContextImpl类中init方法，获得了一个唯一的<strong>Resources</strong>对象，根据上述代码中资源的请求机制，再加上ResourcesManager采用单例模式，这样就保证了不同的ContextImpl访问的是同一套资源。</p>
<p>如果这篇博客现在就结束了，你一定会杀了我 - -，现在我们就来分析下，是什么造成了唯一的这个<strong>Resources</strong>，却展现出了“<strong>不同</strong>”。</p>
<p>举个通俗易懂的例子，我和我老妈都拿到同一块<strong>土豆</strong>，但是因为我们处理这个土豆的方法有区别，导致这个土豆最后表现出来的也不一样，我想把它做成<strong>薯片</strong>，我妈妈把它炒成了<strong>土豆丝</strong>，:-D。</p>
<p>再具体一点，比如除了Activity可以创建一个Dialog，其它Context都不可以创建Dialog。比如在Application中创建Dialog会报错，还有Application和Service可以启动一个Activity，但是需要创建一个新的task。比如你在Application中调用startActivity（intent）时系统也会崩溃报错。</p>
<p>报错的原因并不是因为他们拿到的Context资源不同，拿到的都是一个Resoucres对象，但是在创建Dialog的时候会使用到Context对象去获取当前主题信息，但是我们知道Application和Service是继承自ContextWrapper，<strong>没有实现关于主题的功能</strong>，然而Activity是继承自ContextThemeWrapper，该类是实现了关于主题功能的，因此创建Dialog的时候必须依附于Activity的Context引用。</p>
<p><strong>结论：</strong></p>
<p><strong>Application、Service、Activity，它们本身对Resources资源处理方法的不同，造成了这个Resoucres最后表现出来的不一样</strong>，这么说大家就都懂了吧！</p>
<h2 id="四：Context内存泄漏"><a href="#四：Context内存泄漏" class="headerlink" title="四：Context内存泄漏"></a>四：Context内存泄漏</h2><p>关于Context的内存泄漏，找到一篇比较不错的文章分享给大家。</p>
<p><a href="http://spencer-dev.com/blog/2015/androidkai-fa-zhong-ke-neng-hui-dao-zhi-nei-cun-xie-lu-de-wen-ti.html/" target="_blank" rel="external">Android开发，中可能会导致内存泄露的问题</a></p>
<p><strong>写在最后：</strong></p>
<blockquote>
<p>Context可能还有更多深层次的知识需要我们去了解，比如Context这些封装类，是具体如何通过Binder跟ContextImpl进行关联的；资源对象都被存储在ArrayMap，为什么ArrayMap中会有可能存在多个资源对象，如何访问其他应用程序的Context资源等等，剩下的这些就靠大家慢慢发掘了~</p>
</blockquote>
<p>转载请注明出处。</p>
<p><strong>如果大家觉得喜欢有价值，就关注我，点下赞哈，你们的支持是我持续原创的动力。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;你足够了解Context吗？&quot;&gt;&lt;a href=&quot;#你足够了解Context吗？&quot; class=&quot;headerlink&quot; title=&quot;你足够了解Context吗？&quot;&gt;&lt;/a&gt;&lt;strong&gt;你足够了解Context吗？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;这里有关于Context的一切&lt;br&gt;-&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当我还是一个24K纯Android新手的时候（现在是也是个小Android萌新），拿着工具书对着电脑敲敲打打，那个时候我就有一个非常大的疑问：Context到底为何这么牛？show一个Dialog，启动一个Activity，Service，发送一个Broadcast，还有各种方法需要传入的参数。几乎在Android中，Context的身影处处可见，所以弄懂它，似乎是一件迫在眉睫的事，所以深呼吸，整理思路，来看看Context到底是什么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Context" scheme="http://yoursite.com/tags/Context/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android的性能优化总结</title>
    <link href="http://yoursite.com/2016/07/27/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/27/Android性能优化总结/</id>
    <published>2016-07-27T13:18:04.904Z</published>
    <updated>2016-07-27T13:34:31.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android的性能优化"><a href="#Android的性能优化" class="headerlink" title="Android的性能优化"></a>Android的性能优化</h2><p><strong>写在前面：</strong></p>
<pre><code>公司给了我一周的时间去学习Android性能的优化，参考了张明云老师的一片文章，并且用公司的实际项目进行测试（附有截图），还进行了一些知识点，注意事项以及很多网址链接的补充，希望这篇博文能让做性能测试的朋友们少走一些弯路。
文中没有贴出大段代码，但是几乎所有的知识点都有链接，点进去就能看你想看的。转载注明出处。
</code></pre><a id="more"></a>
<h2 id="零：性能指标"><a href="#零：性能指标" class="headerlink" title="零：性能指标"></a><strong>零：性能指标</strong></h2><ol>
<li><strong>布局复杂度</strong>：布局复杂会导致布局需要更长的时间，从而导致进入应用慢、页面切换慢；</li>
<li><strong>耗电量</strong>：耗电量大会导致机器发热、缩短机器的有效使用时长；</li>
<li><strong>内存</strong>：内存消耗大会导致频繁GC，GC时会暂停其它工作，导致页面卡顿；内存泄露会导致剩余可用内存越来越小；内存不足会导致应用异常；</li>
<li><strong>网络</strong>：频繁的网络访问会导致耗电和影响应用的性能；网络交互数据大小会影响网络传输的效率；</li>
<li><strong>程序执行效率</strong>：糟糕的代码会严重影响程序的运行效率，UI线程过多的任务会阻塞应用的正常运行，长时间持有某个对象会导致潜在的内存泄露，频繁的IO操作、网络操作而不用缓存会严重影响程序的运行效率。<br>####<strong>一：布局复杂度的优化</strong><br><strong>关于布局的优化，主要分两个大方向</strong><h5 id="1-实现相同界面效果并且层级结构相同时，选用何种Layout最好"><a href="#1-实现相同界面效果并且层级结构相同时，选用何种Layout最好" class="headerlink" title="1. 实现相同界面效果并且层级结构相同时，选用何种Layout最好"></a><strong>1. 实现相同界面效果并且层级结构相同时，选用何种Layout最好</strong></h5>在Android中单独的布局性能：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FrameLayout&gt;LinearLayout&gt;RelativeLayout</div></pre></td></tr></table></figure>
<p>可供参考的网址：<a href="http://www.jianshu.com/p/8a7d059da746" target="_blank" rel="external">LinearLayout与RelativeLayout的性能比较</a><br><strong>总结:</strong></p>
<ul>
<li><p>RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure;</p>
</li>
<li><p>RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin;</p>
</li>
<li><p>在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout;</p>
</li>
<li><p>使用组合控件性能要好于两个独立控件，比如一个文本旁边有一个图片，这中情况最好要用DrawableLeft的这种属性设置图片;</p>
</li>
</ul>
<h5 id="2-减少布局的层级结构"><a href="#2-减少布局的层级结构" class="headerlink" title="2. 减少布局的层级结构"></a><strong>2. 减少布局的层级结构</strong></h5><ul>
<li>HierarchyViewer—可查看布局层次结构，View绘制时耗时。<br><a href="http://blog.csdn.net/xyz_lmn/article/details/14222975" target="_blank" rel="external">HierarchyViewer的使用</a></li>
<li>无线UIViewer—强烈推荐App工具，可在手机端直接实现HierarchyViewer的功能，查看任意界面的UI布局。<br><a href="http://download.csdn.net/detail/duantihi/9448886" target="_blank" rel="external">无线UIViewer下载</a></li>
</ul>
<p><strong>测试图片如下：</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-8a608fd303dd4794?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用无线UIViewer测试出的结果"><br>当前界面的UI布局层级如上图所示</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>一些复用性很高的布局文件，比如一个App的标题栏，建议使用布局重用<strong>include</strong>标签，方便引入和共同管理。</p>
</li>
<li><p>观察上图第三个层级和第四个层级，无论是Layout类型，还是所覆盖的坐标点，都是重合的，因为父FrameLayout作为一个Container，子FrameLayout作为一个子View的跟布局，这种情况，可使用<strong>merge</strong>标签进行布局层级的优化。</p>
</li>
<li><p>有些在特定情况下才会出现的界面，比如联网之后，或者未必百分之百出现的界面，可用<strong>ViewStub</strong>标签进行懒加载，性能明显要优于加载出这个界面然后<strong>gone</strong>掉。</p>
</li>
</ul>
<p><strong>布局优化相关网址：</strong><br><a href="http://blog.csdn.net/xyz_lmn/article/details/14524567" target="_blank" rel="external">三种优化标签的使用情景和优势—张业兴</a><br><a href="http://www.it165.net/pro/html/201409/22192.html" target="_blank" rel="external">布局优化标签的源码分析</a></p>
<p>有关布局优化的一些基础知识准备(郭霖老师的两篇博客)：<br><a href="http://blog.csdn.net/guolin_blog/article/details/12921889" target="_blank" rel="external">Android LayoutInflater原理分析，带你一步步深入了解View(一)</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/16330267" target="_blank" rel="external"> Android视图绘制流程完全解析，带你一步步深入了解View(二)</a></p>
<h2 id="二：Android开发者模式—GPU过渡绘制"><a href="#二：Android开发者模式—GPU过渡绘制" class="headerlink" title="二：Android开发者模式—GPU过渡绘制"></a><strong>二：Android开发者模式—GPU过渡绘制</strong></h2><p><strong>GPU过度绘制定义：</strong></p>
<p>如果你粉刷过一个房间或一所房子，就会知道给墙壁涂上颜色需要做大量的工作。假如你还要重新粉刷一次的话，第二次粉刷的颜色会覆盖住第一次的颜色，第一次的颜色就永远不可见了，等于你第一次粉刷做的大量工作就完全被浪费掉。这太可怕了。</p>
<p>同样的道理，如果在你的应用程序中浪费精力去绘制一些东西同样会产生性能问题。过度绘制这个名词就是用来描述屏幕上一个像素在单个帧中被重绘了多少次。</p>
<p>GPU过度绘制就指的是在屏幕一个像素上绘制多次(超过一次)，GPU过度绘制或多或少对性能有些影响。</p>
<p><strong>GPU过度绘制分析：</strong></p>
<p>过度绘制其实是一个性能和设计的交叉点。我们在设计上追求很华丽的视觉效果，但一般来说这种视觉效果会采用非常多的层叠组件来实现，这时候就会带来过度绘制的问题。我们再来看看具体显示在Android界面层级关系：</p>
<p>当我们来绘制一个界面时，会有一个windows，然后是建立Activity，在Activity里可以建立多个view，或view group，view也可以嵌套view。这些组件从上到下分布，上面的组件是可以被用户看见的，而在下面的组件是不可见的，但是我们依然要花很多时间去绘制那些不可见的组件，因为在某些时候，它也可能会显示出来。</p>
<p><strong>检测过度绘制：</strong></p>
<p>设置-开发者选项-调试GPU过度绘制-显示过度绘制区域(过度渲染等，不同机器可能不同)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bf7ba57ad4a13785?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开过度绘制的流程图"></p>
<p><strong>测试的颜色标识含义：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-2d6386707155cca9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><strong>项目测试截图：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ac12fc0ef9ab361b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-7d0b5cec974ef972?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-3e54c1605d23c069?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>可以看到项目中并不存在太大问题，有关减少过度绘制的一些建议：</p>
<ol>
<li>太多重叠的背景</li>
</ol>
<pre><code>这个问题其实最容易解决，建议前期在设计时尽量保持整体背景统一，另外开发可以检查你在布局和代码中设置的背景，有些背景是被隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。
</code></pre><ol>
<li>太多重叠的view</li>
</ol>
<pre><code>第一个建议是：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认不可见的视图，可以动态的加载一个布局，只有你用到这个重叠着的view的时候才加载，推迟加载的时间。第二个建议是：如果使用了类似viewpager+Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态地Inflation view，它的性能要比SetVisiblity好。
</code></pre><ol>
<li><p>复杂的Layout层级</p>
<p>  这里的建议比较多一些，首先推荐用Android提供的布局工具Hierarchy</p>
<h2 id="三：Android中耗电量的测试"><a href="#三：Android中耗电量的测试" class="headerlink" title="三：Android中耗电量的测试"></a><strong>三：Android中耗电量的测试</strong></h2><p><a href="http://www.cnblogs.com/hyddd/p/4402621.html" target="_blank" rel="external">深入浅出Android App耗电量统计</a></p>
</li>
</ol>
<p>测试截图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b9ad7e49225531eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>本人认为这一点没有过多补充的，大多数App都不会消耗过多的电量。</p>
<h2 id="四：内存、CPU、GPU"><a href="#四：内存、CPU、GPU" class="headerlink" title="四：内存、CPU、GPU"></a><strong>四：内存、CPU、GPU</strong></h2><p>应用运行时内存使用情况查看：Android Studio—Memory/CPU/GPU</p>
<p>通常这种测试应该使用一个自动化工具（monkey）去不停的点击App，或者切换界面，来观察内存、cpu的情况。</p>
<ol>
<li><p><strong>内存</strong></p>
<p><strong>测试截图：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-61398ca5ea9cecbe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>在地图界面不断地刷新，正常的内存成锯齿状分布。</p>
<p>需要注意的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e9d03f898bcfcfdb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>出现了针状分布，说明内存发生了突变，如果内存峰值不能降下来，就说明出现了内存溢出，就值得引起我们的关注了。</p>
</li>
<li><p><strong>CPU</strong></p>
<p>测试图片：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4b31f6ced46442ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
</ol>
<ol>
<li><p><strong>GPU</strong></p>
<p>Android Studio 1.4增加一项新功能：分析GPU渲染功能。作者详细讲解这一新功能的分析方法。</p>
<p>在GPU选项卡下，可以在屏幕上看到图形化显示的渲染每帧所花费的时间。图形中每条都表示被渲染的一帧。颜色表示进程的不同周期：</p>
<p><strong>绘画（蓝色）</strong><br>表示View#onDraw()方法。那部分建立/更改DisplayList对象，然后转换成GPU能够理解的OpenGL命令。高的条形可能是视图复杂，而要求更多的时间绘制它们的显示列表，而许多视图在短时间内就失效了。</p>
<p><strong>准备（紫色）</strong><br>在Lollipop中，加入另一个线程，以帮助UI线程渲染更快。这个线程叫：RenderThread。它的责任是转换显示列表为OpenGL命令，再发送给GPU。这样在渲染过程中，UI线程可以开始处理下一个帧。这时UI线程将所有资源传送给RenderThread。如果有许多资源要传递（如许多/繁重显示列表），这一步可能需要较长时间。</p>
<p><strong>处理（红色）</strong><br>执行显示列表产生OpenGL命令。由于需要视图重绘，如果有许多/复杂显示列表要执行转换，这一步可能需要较长时间。当视图无效或是移动时，都要要重绘视图。</p>
<p><strong>执行（黄色）</strong><br>发送OpenGL命令到GPU。由于CPU发送这些缓存的命令到GPU，并期待收回干净缓存，这就阻塞调用了。缓存数量有限，并且GPU也很忙<br>——<br>CPU会发现自己必须先等待缓存释放。因此，如果在这一步我们见高的条形，就可能意味着GPU在绘制UI时非常忙，这个绘制在短时间内太复杂了。</p>
<p>测试截图：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-3c27ec3ed25d38bf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
</ol>
<p><strong>结论：</strong></p>
<p>可以通过切换界面，看图形的峰值和颜色去判断绘制View每个阶段所花费的时间，然后根据你的需求进行优化。</p>
<h2 id="五：程序的执行效率"><a href="#五：程序的执行效率" class="headerlink" title="五：程序的执行效率"></a><strong>五：程序的执行效率</strong></h2><ol>
<li><p>静态代码检查工具：Android studio—Analyze—Inspect Code…/Code cleanup… ，用于检测代码中潜在的问题、存在效率问题的代码段并提供改善方案；</p>
</li>
<li><p>DDMS—TraceView，用于查找程序运行时具体耗时在哪；</p>
</li>
<li><p>StrictMode：用于查找程序运行时具体耗时在哪，需要集成到代码中；</p>
</li>
</ol>
<p>####<strong>六：知名的三方性能优化工具</strong></p>
<ol>
<li><p><strong>LeakCanary</strong><br>LeakCanary是一个检测内存泄露的开源类库。你可以在 debug<br>包种轻松检测内存泄露。强烈推荐LeakCanary，大多数公司都在使用它进行内存泄漏的测试。</p>
<p>以下是我找到的学习资料，写的非常棒： </p>
<p><a href="http://www.liaohuqiu.net/cn/posts/leak-canary/" target="_blank" rel="external">LeakCanary:<br>让内存泄露无所遁形</a></p>
<p><a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/" target="_blank" rel="external">LeakCanary<br>中文使用说明</a></p>
<p>具体使用请参考以上两个链接，下面给出一个测试截图，供大家直观感受其便捷和强大的功能。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9eac174d478347f7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e01c35d7c95a01eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><strong>结论：</strong> LeakCanary非常直观的展现了MainActivity出现了内存泄漏，并且指出引用路径中的哪个引用是不该有的，然后修复问题。总而言之非常好用，处理内存泄漏首选的工具。</p>
</li>
<li><p><strong>GT</strong> GT是腾讯开发的一款APP的随身调测平台，利用GT，可以对CPU、内存、流量、点亮、帧率/流畅度进行测试，还可以查看开发日志、crash日志、抓取网络数据包、APP内部参数调试、真机代码耗时统计等等，需要说明的是，应用需要集成GT的sdk后，GT这个apk才能在应用运行时对各个性能进行检测。</p>
<p><a href="http://gt.qq.com/" target="_blank" rel="external">GT官方网址</a></p>
<p>下面是使用GT测试项目的截图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-3a9f005484fdfaa5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8292f2b33b7532c5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-fa051d42cda87d9b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-deba30db8bba7cac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4d539ff1d892e076?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>具体图片是什么含义，大家去点击官网去了解学习就可以，GT还是很全面好用的，慢慢发掘吧。</p>
</li>
</ol>
<blockquote>
<p>第一次写技术博客，并没有贴出大量代码，如果大家需要了解原理，点进链接去看就好了，如果有什么建议和问题大家可以给我留言。有什么好的工具和方法可以同大家一起分享。</p>
</blockquote>
<p><strong>如果对大家喜欢请点赞收藏哈，你们的认可是我写作的动力O(∩_∩)O</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android的性能优化&quot;&gt;&lt;a href=&quot;#Android的性能优化&quot; class=&quot;headerlink&quot; title=&quot;Android的性能优化&quot;&gt;&lt;/a&gt;Android的性能优化&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;公司给了我一周的时间去学习Android性能的优化，参考了张明云老师的一片文章，并且用公司的实际项目进行测试（附有截图），还进行了一些知识点，注意事项以及很多网址链接的补充，希望这篇博文能让做性能测试的朋友们少走一些弯路。
文中没有贴出大段代码，但是几乎所有的知识点都有链接，点进去就能看你想看的。转载注明出处。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
</feed>

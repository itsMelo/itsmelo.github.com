<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Melo&#39;s Blog</title>
  <subtitle>耐心的偏执狂，浪漫的现实主义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-19T14:31:22.082Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melo</name>
    <email>MeloAndroid@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity 中不得不谈的 setContentView</title>
    <link href="http://yoursite.com/2016/08/19/Android%20%E4%B8%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%B0%88%E7%9A%84%20setContentView/"/>
    <id>http://yoursite.com/2016/08/19/Android 中不得不谈的 setContentView/</id>
    <published>2016-08-19T14:24:34.071Z</published>
    <updated>2016-08-19T14:31:22.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href="">暂无</a><br><strong>写在前面：</strong><br>几个月之前在做项目的布局优化时，使用 <strong>Hierarchy Viewer</strong> 查看项目的层级结构，然后发现顶层的布局并不是在XML中我写的根布局，而是嵌套了多层 Layout ，简单查阅了一些资料之后明白这是系统为我们加上的。把这个知识点写在了印象笔记中的 TODO list（里面还有好多知识想研究，一直在拖延T.T），搁置了好久最近重新拿出来好好研究了一下，争取做到温故知新，融会贯通嘛。<a id="more"></a>
也许有的同学没看过 Hierarchy Viewer 下项目的界面布局，没关系，我现在带大家了解下。<br>新建一个 module ，打开 sdk tool 文件夹下的 Hierarchy Viewer ，布局结构展示如下：</li>
</ul>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-cec85b655a857ea2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MainActivity界面层级"></p>
<p>先别着急找放大镜，想想我们新建项目的默认布局，按理说根布局应该是 RelativeLayout ，并且子 View 是一个 TextView 写着 “Hello World”才对啊~ <strong>多出来的这些布局层级是什么</strong>？</p>
<p>既然陌生又看不懂，那就先从我们熟悉的入手，找一下我们自己写的布局：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-972bcb0f5f20225a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RelativeLayout"></p>
<p>原来 RelativeLayout 和它的子 View TextView 在这里，看一下左下角的位置标识，红框部分指明 RelativeLayout 是 Toolbar 以下的部分。</p>
<p>再想想，我们是通过什么方法将这个布局填充到 Activity 上的呢？</p>
<p>没错是 <strong>setContentView</strong> </p>
<p>那就在 setContentView 中寻找蛛丝马迹吧</p>
<p>因为在 Android Studio 中 MainActivity 默认继承于v7包下的 AppCompatActivity ，目的是为了提供控件的向下兼容或者新控件，AppCompatActivity 也是层层继承于 Activity ，所以我们直接去看 <strong>Activity</strong> 的 <strong>setContentView</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Set the activity content from a layout resource.  The resource will be</div><div class="line"> * inflated, adding all top-level views to the activity.</div><div class="line"> *</div><div class="line"> * @param layoutResID Resource ID to be inflated.</div><div class="line"> *</div><div class="line"> * @see #setContentView(android.view.View)</div><div class="line"> * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</div><div class="line"> */</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getWindow 拿到了 Activity 的成员变量 <strong>mWindow</strong> ，进而调用了 setContentView 方法，mWindow 是 <strong>Window</strong> 类，继续跟进，看看 <strong>Window</strong>类 是什么</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8437b107b9f42a95?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Window类"></p>
<p>注释中的描述翻译过来就是，Window 是 视觉和行为表现的顶层抽象基类，它的实例会当作顶层视图添加进 <strong>WindowManager</strong> ， 它有一个唯一的实现类是 <strong>PhoneWindow</strong>。<br>本文我们不会去剖析 WindowManager 有哪些作用和行为，我默默地把它加入了我的 TODO list 中，拖延到什么时候就不一定了哈T.T。</p>
<p>为了防止你忘了我们在做什么和我们即将做什么，先来一个<strong>中场回顾</strong>：<br>首先我们查看布局时发现有很多“超出我们预料和理解范畴”的布局出现，跟进 setContentView 方法，发现 Acitvity 中是 Window 调用了 setContentView ，而抽象基类 Window 有一个唯一的实现类 PhoneWindow。不多说，来看看实现类 PhoneWindow 中的 setContentView 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">    // before this happens.</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        //初始化 DectorView 和 mContentParent</div><div class="line">        installDecor();</div><div class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        mContentParent.removeAllViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                getContext());</div><div class="line">        transitionTo(newScene);</div><div class="line">    &#125; else &#123;</div><div class="line">        //首次 setContentView 走到这里</div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">    &#125;</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们没有调用 setContentView 时，mContentParent （是ViewGroup） 是 null ，所以有两行代码值得我们关注 installDecor() 和 mLayoutInflater.inflate(layoutResID, mContentParent)<br>首先 mContentParent 作为第二个参数传入了 inflate 方法中， 也就是说 我的布局中的 RelativeLayout 被层层解析之后的 <strong>View 视图树</strong> 作为了 mContentParent 的<strong>子 View</strong> 插入。</p>
<p>现在不知道 mContentParent 是什么没关系，继续跟进 <strong>installDecor()</strong> 方法。</p>
<p>(随着API level的升高，源码发生了很多有关 Feature 、 style 和 Wiget 的细微变化，还是蛮有意思的)<br>(这里我还想说一句，相信在 Android 设计之初 PhoneWindow 这个类就存在了，显然现在的这个命名有些问题，毕竟目前的设备不仅仅是 phone 了，也许改成 DeviceWindow 会比较合适)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void installDecor() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">        // new 一个 DecorView</div><div class="line">        mDecor = generateDecor();</div><div class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class="line">    &#125;</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        //初始化 mContentParent </div><div class="line">        mContentParent = generateLayout(mDecor);</div><div class="line">        // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</div><div class="line">        mDecor.makeOptionalFitsSystemWindows();</div><div class="line">        // 找到一个带ActionBar属性的布局容器 decorContentParent </div><div class="line">        final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</div><div class="line">                R.id.decor_content_parent);</div><div class="line"></div><div class="line">        if (decorContentParent != null) &#123;</div><div class="line">            mDecorContentParent = decorContentParent;</div><div class="line">            mDecorContentParent.setWindowCallback(getCallback());             </div><div class="line">            //配置UI设置</div><div class="line">            mDecorContentParent.setUiOptions(mUiOptions);</div><div class="line">        &#125;</div><div class="line">     &#125; else &#123;</div><div class="line">      if (mContentParent instanceof FrameLayout) &#123;</div><div class="line">              ((FrameLayout)mContentParent).setForeground(null);</div><div class="line">            &#125;</div><div class="line">     &#125;                   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>省略了与分析无关的代码，其中很多是对 Feature 和 style 属性的一些判断和设置，首先 installDecor() 方法从字面意思看，很有可能是初始化加载 DecorView 的，首先看看 PhoneWindow 中两个成员变量 <strong>mDecor</strong>  和 <strong>mContentParent</strong> 分别是什么：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e0fed131805b5bf1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mDector 和 mContentParent"></p>
<p>描述的信息可以概括为 mDector 是 窗体的顶级视图，mContentParent 是放置窗体内容的容器，也就是我们 setContentView 时，所加入的 View 视图树。</p>
<p>当二者为 null 时，有两行代码值得关注，分别为 mDecor = generateDecor() 和 mContentParent = generateLayout(mDecor)</p>
<p>不过在此之前，先来看看这行寻找decorContentParent布局的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</div><div class="line">                    R.id.decor_content_parent);</div></pre></td></tr></table></figure>
<p>decor_content_parent 看起来很眼熟的样子，点击它进入布局来看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-eef0d0f81e680d95?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screen_toolbar.xml"></p>
<p>为什么说 <strong>decor_content_parent</strong> 眼熟呢？打开布局查看器来看看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-64e0059923c01faf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>在 <strong>Hierarchy Viewer</strong> 中可以看到 ActionBarOverlayLayout 的布局文件的 id 正是 <strong>decor_content_parent</strong> 不光如此 布局文件中的每个 View 节点的名称和 id 都与 <strong>Hierarchy Viewer</strong> 视图中的一一对应。再看其中的 FrameLayout 的 id 为 content ， 我们自然而然的猜测它就是我们根布局 RelativeLayout 的<strong>父布局</strong>，心里一下有了底，继续研究~</p>
<p>跟进 generateDecor() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">    return new DecorView(getContext(), -1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个没什么可多说的，就是为我们的窗体 new 了 一个 DecorView 。</p>
<p>再来看 generateLayout(mDecor) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">  protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">      // Apply data from current theme.</div><div class="line">      // 获得窗体的 style 样式</div><div class="line">      TypedArray a = getWindowStyle();</div><div class="line">         </div><div class="line">      // 省略大量无关代码</div><div class="line">                          </div><div class="line">      // Inflate the window decor.</div><div class="line">      int layoutResource;</div><div class="line">      int features = getLocalFeatures();</div><div class="line"></div><div class="line">      //填充带有 style 和 feature 属性的 layoutResource (是一个layout id)</div><div class="line"></div><div class="line">      View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">      // 插入的顶层布局 DecorView 中</div><div class="line"></div><div class="line">      decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">      mContentRoot = (ViewGroup) in;</div><div class="line"></div><div class="line">      // 找到我们XML文件的父布局 contentParent </div><div class="line"></div><div class="line">      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">      if (contentParent == null) &#123;</div><div class="line">          throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">      &#125;</div><div class="line">// 省略无关代码</div><div class="line">      mDecor.finishChanging();</div><div class="line">      // 返回 contentParent 并赋值给成员变量 mContentParent</div><div class="line">      return contentParent;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个方法的代码有300多行，剔除了很多无关代码，我们分模块来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line">    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">    mContentRoot = (ViewGroup) in;</div></pre></td></tr></table></figure>
<p>首先 layoutResource 是系统的xml布局文件的id，里面有我们设置窗体的 features 和 style 属性，然后通过decor.addView 添加进 mDector 视图。这里也是我们要在 setContentView() 之前执行requestWindowFeature()才可以的原因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">    if (contentParent == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Remaining setup -- of background and title -- that only applies</div><div class="line">    // to top-level windows.</div><div class="line">   </div><div class="line">    mDecor.finishChanging();</div><div class="line"></div><div class="line">    return contentParent;</div></pre></td></tr></table></figure>
<p>关键点来了， ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);<br>通过 findViewById 找到系统修饰布局文件中 id 为：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-81b5ec907ab9dbf5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>这个 id 是不是非常眼熟，与我们上文的猜测不谋而合，这就是我们一直在寻找的作为 <strong>activity_main</strong> 的父布局的 <strong>FrameLayout</strong> </p>
<p>我们在布局文件查看器中再找一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9a830d14a65e0fda?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容器 FrameLayout id = content"></p>
<p>return contentParent 这一步就返回了我们的成员变量 <strong>mContentParent</strong> </p>
<p>到现在为止其实整个知识点主干的逻辑已经走完了，为大家花了一张简单的思维导图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-87182e07c37ac78e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用逻辑"></p>
<p>并不复杂，线性逻辑调用还是蛮清晰的。</p>
<p>不过相信你也许会问，上文你仅仅提到了两个布局呀，一个顶层的 <strong>DecorView</strong> 和 我们布局文件的父布局 <strong>FrameLayout</strong> ，而查看布局层级时，为什么有这么多其他这么多额外的布局呢？</p>
<p>因为随着 Android API level 的不断变化，组件也在随之增多，比如ActionBar Toolbar等等，这些组件相关的布局是否加载与你的 <strong>feature</strong> 设置设备的特性相关联，而且版本不同，布局文件的<strong>层级结构</strong>也在不断变化着丰富着，我这个是 API22 的源码，我做了一些对比，有许多代码细节是不一样的，比如在这里的 <strong>Feature</strong> 就新增了 Toolbar ，但是大体上的逻辑框架肯定不会变<br>比如我们目前的 MainActivity 的视图主要有两大分支，一条设置 Toolbar 的相关配置，一条就是我们的 RelativeLayout 了。</p>
<p><strong>写在后面：</strong><br>写这篇博客的原因一是我自己要研究梳理总结这个知识点，二是想让大家明白，Android版本之间的迭代很快，一年前的博客阐述的观点到今天可能就再不适用了，但是 PhoneWindow 管理布局视图的这套逻辑框架，却一直没怎么改变。通过阅读源码，可以学习 Google 工程师们良好的代码风格，汲取他们搭建框架的思想，让我们自己写的代码也能如此健壮。</p>
<p><strong>PS： PhoneWindow 什么时候能改个名字啊！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;itsCoder主页：&lt;a href=&quot;http://itscoder.com/&quot;&gt;http://itscoder.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://itsmelo.github.io/&quot;&gt;Melo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;审阅者：&lt;a href=&quot;&quot;&gt;暂无&lt;/a&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;几个月之前在做项目的布局优化时，使用 &lt;strong&gt;Hierarchy Viewer&lt;/strong&gt; 查看项目的层级结构，然后发现顶层的布局并不是在XML中我写的根布局，而是嵌套了多层 Layout ，简单查阅了一些资料之后明白这是系统为我们加上的。把这个知识点写在了印象笔记中的 TODO list（里面还有好多知识想研究，一直在拖延T.T），搁置了好久最近重新拿出来好好研究了一下，争取做到温故知新，融会贯通嘛。
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="setContentView" scheme="http://yoursite.com/tags/setContentView/"/>
    
  </entry>
  
  <entry>
    <title>开发一个Android应用之前，应该考虑点什么？</title>
    <link href="http://yoursite.com/2016/08/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid%E5%BA%94%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E7%82%B9%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2016/08/12/开发一个Android应用之前，应该考虑点什么/</id>
    <published>2016-08-12T08:33:18.120Z</published>
    <updated>2016-08-12T08:33:18.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发一个Android应用之前，应该考虑点什么？"><a href="#开发一个Android应用之前，应该考虑点什么？" class="headerlink" title="开发一个Android应用之前，应该考虑点什么？"></a>开发一个Android应用之前，应该考虑点什么？</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-e22b0058b534ace3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><a id="more"></a><br><strong>写在前面：</strong><br>昨天参加了秋百万大大组织的北京<strong>GDG</strong>活动，收获颇丰。又跟几个有写作习惯的朋友建立了一个“神秘组织”，每两周为一个周期，每人都会产出一篇原创的文章，互相校验和探讨，意在督促组员之间学习和分享开源技术。而简书上的平台就交给我维护了，不出意外，几天之内大家就可以看到我们的主页和第一期成员的文章啦，<strong>敬请期待~</strong></p>
<p>前几天接手了一个老员工遗留下来的代码，别提多痛苦了，甚至有了让我推倒重写的冲动，很多地方的设计问题颇多，老大也快无法忍受了。。。上学的时候写一篇作文，要想好主题立意和分段，解数学题的时候也得在草稿纸上梳理清楚逻辑之后再下笔。其实开发一个Android也应是如此，不做准备，埋头苦写，最后会导致问题颇多。所以本文会<strong>根据网络上优秀内容和我实际的开发经验</strong>讨论总结一下，<strong>开发一个Android应用之前，都应该做哪些准备</strong>。</p>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a><strong>编码规范</strong></h2><p><strong>编码规范</strong>的问题是我最先想强调的，因为我接手的项目命名就极其混乱，甚至在一个类中的命名都没有统一化（生无可恋脸）。代码可能不是你自己一个人写，<strong>保证代码可读性</strong>是非常必要的。而规范存在的意义就是淡化每个人的习惯而达到统一。不多说，下面就介绍<strong>Android的编码规范</strong>。</p>
<ul>
<li>除了注释，代码中不出现中文</li>
<li>每个类写上必要的注释，类的说明，作者，联系方式</li>
<li>方法加上必要的注释说明，方便以后维护</li>
</ul>
<p><strong>包管理</strong></p>
<ul>
<li>base:存放基础类的包，里面的类以Base为前缀，例如BaseActivity；</li>
<li>activity:存放activity的包，每个activity命名以Activity结尾，例如MainActivity;</li>
<li>fragment:存放fragment的包，每个fragment命名以Fragment结尾，例如ChatFragment;</li>
<li>receiver:存放receiver的包；</li>
<li>service:存放service的包；</li>
<li>adapter:存放adapter的包，每个adapter命名以Adapter结尾，例如EventItemAdapter;</li>
<li>common:存放一些公共常量，例如后端接口、SharedPreferenceKey、IntentExtra等;</li>
<li>utils:存放工具类的包，比如常见的工具类：LogUtils、DateUtils；</li>
<li>entity:存放实体类的包；</li>
<li>widget:存放自定义View的包；</li>
</ul>
<p>以上是一些常见的包，但不局限于此，视项目的具体情况而定。</p>
<p><strong>命名</strong></p>
<p><strong>大驼峰命名(UpperCamelCase)：每个单词的第一个字母都大写。</strong></p>
<p><strong>小驼峰命名(lowerCamelCase)：除第一个单词以外，每一个单词的第一个字母大写。</strong></p>
<p><strong>命名的基本原则:</strong></p>
<ul>
<li>尽可能地使用统一的命名规范；</li>
<li>不使用汉语拼音；</li>
<li>除了常见的英文缩写，尽量少地使用缩写；</li>
</ul>
<p><strong>包命名</strong></p>
<ul>
<li>小写字母，参见上文包管理；</li>
<li>连续的单词直接连接起来，不使用下划线；</li>
</ul>
<p><strong>Java类命名</strong></p>
<ul>
<li>大驼峰命名 UserListAdapter；</li>
<li>除常见的缩写单词以外，不使用缩写，缩写的单词每个字母都大写 RequesURLList；</li>
<li>公共的工具类建议以Utils、Manager为后缀，如LogUtils；</li>
<li>接口命名遵循以上原则，以able或ible为后缀；</li>
</ul>
<p><strong>变量命名</strong></p>
<ul>
<li>成员变量命名<ul>
<li>小驼峰命名；</li>
<li>不推荐使用谷歌的前面加m的编码风格（如果使用团队中使用m，则统一使用）；</li>
</ul>
</li>
<li>常量命名<ul>
<li>单词每个字母均大写；</li>
<li>单词之间下划线连接；</li>
</ul>
</li>
<li>控件变量命名<ul>
<li>小驼峰命名；</li>
<li>建议使用 控件缩写+逻辑名称 格式，例如 tvPostTitle、etUserName；</li>
<li>对应的控件的id的命名控件缩写_逻辑名称，单词均小写，用下划线连接，例如：tv_post_title、</li>
<li>et_user_name；</li>
</ul>
</li>
<li>常见的控件缩写如下：<br>控件 缩写<br>Linearlayout    ll<br>RelativeLayout    rl<br>TextView    tv<br>EditText    et<br>Button    btn<br>ImageView    iv<br>CheckBox    chb<br>ListView    lv<br>GridView    gv<br>RadioButton    rb</li>
</ul>
<p><strong>方法命名</strong></p>
<ul>
<li>小驼峰命名；</li>
<li>Getter和Setter方法，推荐使用自动生成的，写起来也很方便。注意，bool类型的变量Getter方法写成isTrue这种；</li>
<li>方法名应当保证见名知义的原则，尽量不使用or或者and，遵循“do one thing”原则；</li>
</ul>
<p><strong>布局文件命名</strong></p>
<ul>
<li>activity、fragment布局文件名以对应的类别名称为前缀，逻辑名称放在其后，以下划线连接，例如activity_home、fragment_chat_list，方便查找；</li>
<li>ListView、GridView的item布局文件建议以list_item、gird_item为前缀，加上对应的逻辑名称，例如<br>list_item_post、grid_item_photo；</li>
<li>Dialog的布局文件以dialog为前缀，逻辑名称放在其后，下划线连接，例如dialog_warnning;<br>包含项布局命名以include开头，在加上对应的逻辑名称，例如include_foot</li>
<li>控件的id命名参见控件变量命名；</li>
</ul>
<p><strong>资源命名</strong></p>
<ul>
<li>图标资源以ic为前缀，例如ic_chat，指聊天图标；</li>
<li>背景图片以bg为前缀，例如bg_login，指的是登录页的背景图；</li>
<li>按钮图片以btn为前缀，例如btn_login，指的是登录按钮的图片，不过这只有一种状态，需要加上状态的可以在后面添加，例如btn_login_pressed，表示登录按钮按下的图片；</li>
<li>当使用shape和selector文件为背景或者按钮时，命名参照以上说明；</li>
</ul>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a><strong>项目架构</strong></h2><p><strong>项目框架</strong><br>一个好的项目架构可以降低项目的复杂性，并且易扩展、易维护，耦合低，结构清晰，功能内聚。<br><strong>MVC</strong>，<strong>MVP</strong>，<strong>MVVM</strong>还有一些设计模式，结合你app的业务，自行选择一个最合适的一条路走到黑，建议不要“混搭”。</p>
<p><strong>开源框架</strong></p>
<p>开源框架的选择分两大类，一是权威性毫无争议，放心选择的这类帮助我们快速开发的，比如：</p>
<ul>
<li>网络 Retrofit + OkHttp+ RxJava、Volley、android-async-http</li>
<li>依赖注入 Dagger2、ButterKnife、RoboGuice</li>
<li>事件总线 otto、EventBus</li>
<li>图片加载 Fresco、Glide、Picasso</li>
<li>数据库 GreenDao、Ormlite、LitePal</li>
<li>日志输出 logger、LogUtils</li>
<li>当然不能忘了Google提供的兼容support全家桶</li>
</ul>
<p>还有一类框架虽然不是毫无争议，但是也能极大节省我们的时间，提升开发效率，对于这类项目，要在Github上长期<strong>淘宝</strong>了。找那种star很多，issues解决很快，长期维护的项目，这种坑会比较少。</p>
<h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a><strong>代码细节</strong></h2><p><strong>抽取基类</strong><br>即使目前你没有需要，也一定要抽取一个BaseActivity和BaseFragment，因为早晚会用到，切记！<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseActivity extends Activity&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123;</div><div class="line">        super.onCreate(savedInstanceState, persistentState);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        initView();</div><div class="line">        initData();</div><div class="line">        initListener();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化布局</div><div class="line">     */</div><div class="line">    protected abstract void initView();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化数据</div><div class="line">     */</div><div class="line">    protected  abstract void initData();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化侦听</div><div class="line">     */</div><div class="line">    protected abstract void initListener();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseFragment也同理，随着业务的增加和抽象，基类会继续扩展。其实不仅仅是<strong>BaseActivity</strong>和<strong>BaseFragment</strong>，如果你一个业务模块中有很多相似和相同的逻辑，也可以抽取一个<strong>BaseXXX</strong>这是非常好的一个习惯。</p>
<p>还有一些建议，不做展开，大家请自行搜索：</p>
<ul>
<li>Android Studio上好用的插件</li>
<li>selector</li>
<li>图片的.9处理</li>
<li>Resources xml文件中，记得用注释分割每个类用到的资源，建议不共用</li>
<li>慎用static关键字</li>
<li>定期code review，不断代码重构</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>推荐一个我曾经写过的总结：</p>
<p><a href="http://www.jianshu.com/p/be05874965d4" target="_blank" rel="external">Android性能优化总结</a></p>
<p><strong>写在后面：</strong></p>
<p>本文做了一个初步总结，未来会慢慢扩展和完善，如果有遗漏，大家可以补充~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发一个Android应用之前，应该考虑点什么？&quot;&gt;&lt;a href=&quot;#开发一个Android应用之前，应该考虑点什么？&quot; class=&quot;headerlink&quot; title=&quot;开发一个Android应用之前，应该考虑点什么？&quot;&gt;&lt;/a&gt;开发一个Android应用之前，应该考虑点什么？&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-e22b0058b534ace3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="开源库" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Activity的生命周期，你足够了解吗？</title>
    <link href="http://yoursite.com/2016/08/01/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BD%A0%E8%B6%B3%E5%A4%9F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/08/01/Activity的生命周期，你足够了解吗？/</id>
    <published>2016-08-01T09:51:11.192Z</published>
    <updated>2016-08-01T09:52:46.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity的生命周期，你足够了解吗？"><a href="#Activity的生命周期，你足够了解吗？" class="headerlink" title="Activity的生命周期，你足够了解吗？"></a>Activity的生命周期，你足够了解吗？</h1><p><strong>写在前面：</strong><br>对于Activity的生命周期，相信只要已经接触过Android的同学，一定可以说出个大概，因为Activity的生命周期真的是太重要的机制了。不过在开发中，我们在每个生命周期方法应该做些什么，还有一些比较关键的知识细节也许你还不清楚，所以本文会带着大家再来探寻一次Activity的生命周期。<br><img src="http://upload-images.jianshu.io/upload_images/1915184-ce9b7e9c5b9796ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><a id="more"></a><br>最近又到了校招的季节，假设你在面试的时候遇到了一个<strong>穿着拖鞋、衣衫褴褛</strong>的Android面试官，拿着你的简历，眉头深锁，对着简历上面<strong>“精通Activity的生命周期和启动模式”</strong>的这句话，问了你以下几个问题：</p>
<ul>
<li><p>onSaveInstanceState方法在Activity的哪两个生命周期方法之间调用？</p>
</li>
<li><p>弹出一个Dialog时，onPause会调用吗？什么情况下会，什么情况下不会？</p>
</li>
<li><p>横竖屏切换的时候，生命周期方法是如何调用的？如何进行配置呢？</p>
</li>
<li><p>Activity调用了onDestory方法，就会在Activity的任务栈消失吗？</p>
</li>
<li><p>永久性质的数据，应该在哪个生命周期方法中保存？</p>
</li>
<li><p>在onCreate或者onRestoreInstance方法中恢复数据时，有什么区别？</p>
</li>
</ul>
<p>如何这些问题你都能回答出来并且懂得原理的话，好吧，你可以点击浏览器的右上角了~如果并没有<strong>完完全全理解Activity的生命周期</strong>，那么继续往下看。</p>
<h2 id="Activity生命周期的回调意义"><a href="#Activity生命周期的回调意义" class="headerlink" title="Activity生命周期的回调意义"></a>Activity生命周期的回调意义</h2><p><strong>直接上图：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-eb9b1e13d3636e78?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的生命周期方法"></p>
<p>相信找张图你百分百看过，我来简略的介绍一下Activity的生命周期：</p>
<ol>
<li><p><strong>onCreate和onDestory</strong><br>分别代表了一个Activity的<strong>创建和销毁</strong>、第一个生命周期和最后一个生命周期回调，期间包裹了一个<strong>完整</strong>(entire lifetime)的Activity生命周期。</p>
</li>
<li><p><strong>onStart和onStop</strong><br>分别代表了Activity已经处于<strong>可见状态和不可见状态</strong>，此时的Activity未处在前台，<strong>不可以与用户交互</strong>，可多次被调用，期间Activity处于可见(visable lifetime)状态。</p>
</li>
<li><p><strong>onResume和onPause</strong><br>分别代表了Activity已经进入前台获得焦点和退出前台失去焦点，此时的Activity是可以和<strong>用户交互的</strong>，可多次被调用，期间的Activity处于前台(foreground lifetime)状态。</p>
</li>
<li><p><strong>onRestart</strong><br>表示Activity正在重新启动，正常状态下，Acitivty调用了onPause–onStop但是并没有被销毁，重新显示此Activity时，onRestory会被调用。</p>
</li>
</ol>
<p>好了在毫无新鲜感的痛苦中，上面人尽皆知的Acitivty生命周期方法终于被我介绍完了~本文不再去写Demo来分析比如A和B相互启动，或者点击Back或者Home键时，Activity生命周期方法的调用，因为我相信你如果<strong>真正理解了上面的Activity的生命周期方法的含义</strong>，这些都可以分析出来。</p>
<h2 id="每个生命周期方法都应该干点啥？"><a href="#每个生命周期方法都应该干点啥？" class="headerlink" title="每个生命周期方法都应该干点啥？"></a>每个生命周期方法都应该干点啥？</h2><ol>
<li><p><strong>onCreate</strong><br>这个方法是在Activity的此生中第一次也会是唯一一次调用，所以在这个方法中，我们应该去初始化一些总体资源比如<strong>setContentView</strong>或者加载一些关于这个Activity的<strong>全局数据</strong>。</p>
</li>
<li><p><strong>onStart</strong><br>这个生命周期方法会被重复调用中，也可以加载一些当Activity可见时，才需要加载的数据，或者注册一个广播，监听UI的变化来刷新界面。</p>
</li>
<li><p><strong>onResume</strong><br>当Activity获取焦点时，这个方法会被回调，<strong>十分轻量级</strong>，最好做一些轻量级的数据加载和布置，这些数据的变动应该是处在onResume—onPause这个生命圈之内的。</p>
</li>
</ol>
<ol>
<li><p><strong>onPause</strong> onPause方法是我绝对想跟大家强调的一个方法，首先onPause方法绝对不可以进行<strong>太耗时的操作</strong>，或者一些<strong>重量级的释放操作</strong>，因为这会影响下一个Activity进入前台与用户交互。也就是说，只有onPause方法调用完毕，下一个Activity的onStart才会调用。<br>在一些永久数据保存上，找到了这样的一段描述：</p>
<blockquote>
<p>onPause(), onStop(), onDestroy() are “killable after” lifecycle methods. This indicates whether or not the system can kill the<br>process hosting the activity at any time after the method returns,<br>without executing another line of the activity’s code. Because<br>onPause() is the first of the three, once the activity is created,<br>onPause() is the last method that’s guaranteed to be called before<br>the process can be killed—if the system must recover memory in an<br>emergency, then onStop() and onDestroy() might not be called.<br>Therefore, you should use onPause() to write crucial persistent data<br>(such as user edits) to storage. However, you should be selective<br>about what information must be retained during onPause(), because<br>any blocking procedures in this method block the transition to the<br>next activity and slow the user experience.</p>
</blockquote>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得onPause是<strong>持久化相关数据</strong>的最后的可靠时机。</p>
<p>所以比如你要写入数据库的数据，就可以放到onPause保存，关于一些其他细节，推荐大家看一看我以前总结的一篇文章：</p>
</li>
</ol>
<ol>
<li><strong>onStop和onDestory</strong><br>在onStop和onDestory我们通常都会做一些<strong>释放资源相关</strong>的操作，当然这个资源的释放是与onStart和onCreate相匹配的，毕竟他们是成对出现的。</li>
</ol>
<p>画一张简单的图来表达含义：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-f3a075db34bdaf6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用法解析"></p>
<p>PS：Activity被翻译成活动，其实不如翻译成<strong>“界面”</strong>更容易贴切，所以与界面展示相关资源的初始化，可以放到Activity中进行。而有些<strong>重量级</strong>的资源，与<strong>界面无关的</strong>，并且与<strong>进程同生共死</strong>，可以考虑放在<strong>Application中的onCreate</strong>方法中进行初始化。</p>
<h2 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h2><p>觉得大家应该比较容易理解以上的内容，那么就开始把文章开头问题的坑给填上吧~</p>
<p><strong>onSaveInstanceState方法在Activity的哪两个生命周期方法之间调用？</strong></p>
<p>其实onSaveInstanceState方法与onPause方法的调用顺序没有先后之分，你需要记住的是，onSaveInstanceState一定在<strong>onStop方法之前</strong>调用。</p>
<p><strong>弹出一个Dialog时，onPause会调用吗？什么情况下会，什么情况下不会？</strong></p>
<p>首先，如果你弹出的是本Activity的Dialog，并不会有任何生命周期方法调用。你肯定不服并且说：应该是onPause方法调用，明明Activity不可点击了嘛！<br>我想说的是，Dialog是一个<strong>View</strong>，它本身就<strong>依附在Acitivty</strong>上，可以理解为是<strong>属于</strong>本Activity的，<strong>所以它的焦点也自然是本Activity的焦点</strong>，自然不会有什么生命周期方法调用了。<br>如果<strong>其他Activity</strong>的Dialog弹出了，onPause才会调用。</p>
<p><strong>横竖屏切换的时候，生命周期方法是如何调用的？如何进行配置呢？</strong></p>
<p>横竖屏切换时，如果不做任何配置，生命周期方法的回调顺序为：</p>
<blockquote>
<p>onPause–onSaveInstanceState–onStop–onDestory–onCreate–onStart–onResume</p>
</blockquote>
<p>也就是说Activity被销毁并重建了。如果不想这样可以在清单文件中的Activity添加一行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</div></pre></td></tr></table></figure>
<p>此时再切换横竖屏，就不会销毁并再次创建了。</p>
<p><strong>在onCreate或者onRestoreInstance方法中恢复数据时，有什么区别？</strong></p>
<p>当onRestoreInstance调用时，其中的bundle参数必然不为空，而使用onCreate恢复数据时，bundle也许是空的，所以要进行一下非空判断。</p>
<p><strong>Activity调用了onDestory方法，就会在Activity的任务栈消失吗？</strong></p>
<p>什么时候onDestory会被调用呢？</p>
<p>可以分为两大类嘛：1.点击了back键 2.Activity被意外销毁</p>
<p>点击back键相当于调用了finish()方法，通常来说finish<br>方法会至少有两个目的，一是将Activity从返回栈中退出，二是调用onDestory方法（未必是及时调用）<br>而直接调用onDestory，是不会将Activity在任务栈中清除的。</p>
<p><strong>写在后面：</strong><br>不知不觉本文就要结束了，Android是一个<strong>复杂而有机的整体</strong>，关于Activity 的生命周期方法，可继续研究的知识非常多，在未来会给大家从源码上分析Activity 的创建流程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Activity的生命周期，你足够了解吗？&quot;&gt;&lt;a href=&quot;#Activity的生命周期，你足够了解吗？&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期，你足够了解吗？&quot;&gt;&lt;/a&gt;Activity的生命周期，你足够了解吗？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;对于Activity的生命周期，相信只要已经接触过Android的同学，一定可以说出个大概，因为Activity的生命周期真的是太重要的机制了。不过在开发中，我们在每个生命周期方法应该做些什么，还有一些比较关键的知识细节也许你还不清楚，所以本文会带着大家再来探寻一次Activity的生命周期。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-ce9b7e9c5b9796ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>ActivityThread的main方法究竟做了什么？</title>
    <link href="http://yoursite.com/2016/07/28/ActivityThread%E7%9A%84main%E6%96%B9%E6%B3%95%E7%A9%B6%E7%AB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/07/28/ActivityThread的main方法究竟做了什么？/</id>
    <published>2016-07-28T02:38:32.727Z</published>
    <updated>2016-07-28T02:39:14.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ActivityThread的main方法究竟做了什么？"><a href="#ActivityThread的main方法究竟做了什么？" class="headerlink" title="ActivityThread的main方法究竟做了什么？"></a>ActivityThread的main方法究竟做了什么？</h1><p><strong>写在前面：</strong><br>在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-0dd4fc7c8f275bd3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="轻松一下"></p>
<p><strong>问大家一个问题：</strong></p>
<p>Android中一个应用程序的<strong>真正入口</strong>是什么？</p>
<p><strong>无论你知道不知道，别着急回答，再问大家一个问题：</strong></p>
<p>Android不能像java一样直接跑在<strong>main方法</strong>的原因是什么？</p>
<p>Android应用程序的载体是APK文件，它本质上，是一个<strong>资源和组件的容器</strong>，APK文件和我们常见的<strong>可执行文件</strong>的区别在何处？</p>
<p>每个可执行文件运行在一个进程中，但是APK文件可能运行在一个单独的进程，也可以和其他APK运行在同一进程中，结合上面，我想表达的是：</p>
<p><strong>Android系统的设计理念就是弱化进程，取而代之是组件的概念。</strong></p>
<p>但是我们都知道，Android系统基于<strong>Linux</strong>系统之上，而Linux系统的运行环境恰恰就是由<strong>进程</strong>组成。所有的Android应用进程都是有Zygote进程fork出来的，因此构成进程的地层系统、虚拟机、动态库等，都是相同的。</p>
<p>当然Android除了继承从Zygote中得到的某些基础的“家当”之外，Android还需要在应用的Java层建立一套框架来管理运行的组件。由于每个应用的配置都不相同，因此不能再Zygote中完全建立好再继承，只能在应用启动时创建。</p>
<p><strong>这套框架就构成了Android应用的基础。</strong></p>
<p>而这套框架有很多核心类，比如：</p>
<p><strong>ActivityThread</strong>、<strong>ApplicationThread</strong>、<strong>Context</strong>、<strong>ActivityManagerService</strong>等等。这里我先给自己挖一个坑，将来慢慢填上，争取清晰简洁的给大家讲明白<strong>Android的组件管理</strong>。</p>
<p>而今天，我们现在聊聊<strong>ActivityThread</strong>的<strong>main</strong>方法</p>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><p>好像忘了点什么。。。</p>
<p>对对，回头看看，我们还有两个问题没解答呢，整个Android应用进程的体系非常复杂，而ActivityThread是真正的核心类，它的<strong>main方法</strong>，是<strong>整个应用进程的入口</strong>。</p>
<p>所以当有人问你应用进程的真正入口是什么，你回答“Activity 的 onCreate 方法”显然就没理解这个问题的意思。</p>
<p>而第二个问题，相信你心里肯定知道大概怎么回答，我们的一个Android应用程序可以是理解为是<strong>四大组件和各种资源的集合</strong>，它需要各种各样的环境资源，当然不能像Java直接跑在main方法里面。</p>
<p>而今天我们就来看看ActivityThread的main方法究竟做了些什么。</p>
<p>在此之前，安利一个看源码的网站，非常不错</p>
<p><a href="http://grepcode.com/" target="_blank" rel="external">http://grepcode.com/</a></p>
<p>点击进去类名就可以查看源码了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a143e41ffdd1b71a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成员变量"></p>
<p>ActivityThread的源码有5000多行，显然我没能力弄懂它每一行代码的意思，不过我们只要知道它大体上负责着什么功能和职责，就可以了。</p>
<p>看看上图中的成员变量，在给大家上一个图，就能理解<strong>ActivityThread管理着</strong>什么。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b76be1a1e19381df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityThread类的对象的关联图"></p>
<p>从图中可以知道，<strong>mActivities</strong>、<strong>mServices</strong>和<strong>mProviderMap</strong> 这三个变量都被保存在<strong>ArrayMap</strong>之中，他们分别保存了应用中所有的<strong>Activity</strong>对象、<strong>Services</strong>对象、和<strong>ContentProvider</strong>对象。 咦？同为四大组件的BroadcastReceive去哪里了？注意，BroadcastReceiver对象没有必要用任何数据结构来保存，因为BroadcastReceiver对象的生命周期很短暂，属于我调用它时，再创建运行，因此不需要保存<strong>BroadcastReceiver</strong>的对象。</p>
<p>我们都知道应用中Applicaiton对象是唯一的，而<strong>mInitialApplication</strong>变量是恰恰是Application对象。当你的应用自定义一个派生Applicaiton类，则它就是mInitialApplication了。</p>
<p><strong>ApplicationThread</strong>类型变量mAppThread是一个<strong>Binder</strong>实体对象，<strong>ActivityManagerService</strong>作为Client端调用ApplicationThread的接口，目的是用来调度管理Activity，这个我们未来会细说。</p>
<p>变量<strong>mResourcesManager</strong>管理着应用中的资源。</p>
<p>一口气说了这么多，怎么样，ActivityThread是不是相当于一个CEO，管理调度着几乎所有的<strong>Android应用进程的资源和四大组件</strong></p>
<p>上面非常多的问题我未来会给大家慢慢解答，因为篇幅太长反而会影响阅读和知识的吸收，话不多说，<strong>来看看入口方法main都做了些什么</strong>？</p>
<h2 id="ActivityThread的main方法"><a href="#ActivityThread的main方法" class="headerlink" title="ActivityThread的main方法"></a>ActivityThread的main方法</h2><p>感兴趣的同学去刚才给出的网站上搜搜ActivityThread的类，大致浏览一下，这里先贴出<strong>main方法</strong>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static void More ...main(String[] args) &#123;</div><div class="line">5220        SamplingProfilerIntegration.start();</div><div class="line">5221</div><div class="line">5222        // CloseGuard defaults to true and can be quite spammy.  We</div><div class="line">5223        // disable it here, but selectively enable it later (via</div><div class="line">5224        // StrictMode) on debug builds, but using DropBox, not logs.</div><div class="line">5225        CloseGuard.setEnabled(false);</div><div class="line">5226		// 初始化应用中需要使用的系统路径</div><div class="line">5227        Environment.initForCurrentUser();</div><div class="line">5228</div><div class="line">5229        // Set the reporter for event logging in libcore</div><div class="line">5230        EventLogger.setReporter(new EventLoggingReporter());</div><div class="line">5231		//增加一个保存key的provider</div><div class="line">5232        Security.addProvider(new AndroidKeyStoreProvider());</div><div class="line">5233</div><div class="line">5234        // Make sure TrustedCertificateStore looks in the right place for CA certificates</div><div class="line">			//为应用设置当前用户的CA证书保存的位置</div><div class="line">5235        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">5236        TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line">5237		//设置进程的名称</div><div class="line">5238        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</div><div class="line">5239</div><div class="line">5240        Looper.prepareMainLooper();</div><div class="line">5241		//创建ActivityThread 对象</div><div class="line">5242        ActivityThread thread = new ActivityThread();</div><div class="line">5243        thread.attach(false);</div><div class="line">5244</div><div class="line">5245        if (sMainThreadHandler == null) &#123;</div><div class="line">5246            sMainThreadHandler = thread.getHandler();</div><div class="line">5247        &#125;</div><div class="line">5248</div><div class="line">5249        if (false) &#123;</div><div class="line">5250            Looper.myLooper().setMessageLogging(new</div><div class="line">5251                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">5252        &#125;</div><div class="line">5253</div><div class="line">5254        Looper.loop();</div><div class="line">5255</div><div class="line">5256        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">5257    &#125;</div></pre></td></tr></table></figure>
<p>代码并不多，但是条条关键，这些操作我都为大家写了注释，看一下就知道程序在做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Looper.prepareMainLooper();</div><div class="line">//创建ActivityThread 对象</div><div class="line">      ActivityThread thread = new ActivityThread();</div><div class="line">      thread.attach(false);</div><div class="line">      </div><div class="line">      if (sMainThreadHandler == null) &#123;</div><div class="line">           sMainThreadHandler =thread.getHandler();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (false) &#123;</div><div class="line">          Looper.myLooper().setMessageLogging(new</div><div class="line">                  LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">      &#125;</div><div class="line">	</div><div class="line">      Looper.loop();</div><div class="line">	</div><div class="line">      throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这几行代码拿出来单独讲解一下，首先Looper.prepareMainLooper();是为主线程创建了Looper，然后thread.getHandler();是保存了主线程的Handler，最后Looper.loop();进入消息循环。</p>
<p>如果不了解Android的消息机制，大家可以来看看以前我写的文章来了解一下：</p>
<p><a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">Android消息机制详解</a></p>
<p>马上就要大功告成了，最后还剩下一行代码还没解释：</p>
<p>thread.attach(false);</p>
<p>继续跟进attach方法，一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">			if (!system) &#123;</div><div class="line">5080            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</div><div class="line">5081                @Override</div><div class="line">5082                public void More ...run() &#123;</div><div class="line">5083                    ensureJitEnabled();</div><div class="line">5084                &#125;</div><div class="line">5085            &#125;);</div><div class="line">5086            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</div><div class="line">5087                                                    UserHandle.myUserId());</div><div class="line">//将mAppThread放到RuntimeInit类中的静态变量</div><div class="line">5088            RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class="line">5089            final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">5090            try &#123;</div><div class="line">					//将mAppThread传入ActivityThreadManager中</div><div class="line">5091                mgr.attachApplication(mAppThread);</div><div class="line">5092            &#125; catch (RemoteException ex) &#123;</div><div class="line">5093                // Ignore</div><div class="line">5094            &#125;</div><div class="line">5095            // Watch for getting close to heap limit.</div><div class="line">5096            BinderInternal.addGcWatcher(new Runnable() &#123;</div><div class="line">5097                @Override public void More ...run() &#123;</div><div class="line">5098                    if (!mSomeActivitiesChanged) &#123;</div><div class="line">5099                        return;</div><div class="line">5100                    &#125;</div><div class="line">5101                    Runtime runtime = Runtime.getRuntime();</div><div class="line">5102                    long dalvikMax = runtime.maxMemory();</div><div class="line">5103                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</div><div class="line">5104                    if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123;</div><div class="line">5105                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024)</div><div class="line">5106                                + &quot; total=&quot; + (runtime.totalMemory()/1024)</div><div class="line">5107                                + &quot; used=&quot; + (dalvikUsed/1024));</div><div class="line">5108                        mSomeActivitiesChanged = false;</div><div class="line">5109                        try &#123;</div><div class="line">5110                            mgr.releaseSomeActivities(mAppThread);</div><div class="line">5111                        &#125; catch (RemoteException e) &#123;</div><div class="line">5112                        &#125;</div><div class="line">5113                    &#125;</div><div class="line">5114                &#125;</div><div class="line">5115            &#125;);</div><div class="line">5116        &#125;</div></pre></td></tr></table></figure>
<p>当传入的参数为false时，就走到了如上面贴出的代码中：</p>
<p>此时主要完成两件事</p>
<p>1.调用 RuntimeInit.setApplicationObject() 方法，把对象mAppThread（Binder）放到了RuntimeInit类中的静态变量mApplicationObject中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	public static final void More ...setApplicationObject(IBinder app) &#123;</div><div class="line">360        mApplicationObject = app;</div><div class="line">361    &#125;</div></pre></td></tr></table></figure>
<p>mAppThread的类型是<strong>ApplicationThread</strong>，它是ActivityThread的成员变量，定义和初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final ApplicationThread mAppThread = new ApplicationThread();</div></pre></td></tr></table></figure>
<p>第二件事比较关键了，就是调用<strong>ActivityManagerService</strong>的attachApplication()方法，将mAppThread 作为参数传入ActivityManagerService，这样ActivityManagerService就可以调用<strong>ApplicaitonThread</strong>的接口了。这与我们刚才说的，ActivityManagerService作为Client端调用ApplicaitonThread的接口管理Activity，就不谋而合了。</p>
<p><strong>写在后面：</strong><br>本文我们明白了ActiivtyThread作为进程的核心类它都管理着哪些对象，并且解释了程序真正入口ActivityThread的main方法都完成了哪些重要的操作，之后会继续带大家了解相关共同组成Android应用进程的核心类，如果有问题和疑问可以多交流，毕竟我也是边学习变整理总结嘛~</p>
<p>如果有需要，推荐你了解一下Context，对你会很有帮助哦~</p>
<p><a href="http://www.jianshu.com/p/46c35c5079b4" target="_blank" rel="external">你足够了解Context吗？</a></p>
<p>最后PS：<br><strong>注意保护电脑不要被水淹！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ActivityThread的main方法究竟做了什么？&quot;&gt;&lt;a href=&quot;#ActivityThread的main方法究竟做了什么？&quot; class=&quot;headerlink&quot; title=&quot;ActivityThread的main方法究竟做了什么？&quot;&gt;&lt;/a&gt;ActivityThread的main方法究竟做了什么？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ActivityThread" scheme="http://yoursite.com/tags/ActivityThread/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android微信自动回复功能</title>
    <link href="http://yoursite.com/2016/07/28/Android%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/28/Android微信自动回复功能/</id>
    <published>2016-07-28T02:35:00.055Z</published>
    <updated>2016-07-28T02:35:48.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android微信自动回复功能"><a href="#Android微信自动回复功能" class="headerlink" title="Android微信自动回复功能"></a>Android微信自动回复功能</h1><p><strong>写在前面：</strong><br>最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。<br><a id="more"></a><br>老大还提示我需要用<strong>AccessibilityService</strong>去实现它，当然在此之前我并不知道<strong>AccessibilityService</strong>是什么鬼，不过没关系，                             <strong>just do IT</strong> ！</p>
<h2 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h2><p><a href="https://developer.android.com/reference/android/accessibilityservice/AccessibilityService.html" target="_blank" rel="external">AccessibilityService官方文档（需翻墙）</a></p>
<p>上面这个链接是AccessibilityService的官方文档，可以翻墙点进去了解下，我再给大家总结一下：</p>
<p>AccessibilityService是Android系统框架提供给安装在设备上应用的一个可选的导航反馈特性。AccessibilityService 可以替代应用与用户交流反馈，比如将文本转化为语音提示，或是用户的手指悬停在屏幕上一个较重要的区域时的触摸反馈等。</p>
<p>如果感觉上面的描述比较抽象，没关系，也许你见过下面这张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4e0ed17ecddf2329?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="辅助功能中的服务"></p>
<p>打开你手机的设置–辅助功能中，有很多APP提供的服务，他们都是基于AccessibilityService编写的，AccessibilityService可以侦听你的点击，长按，手势，通知栏的变化等。并且你可以通过很多种方式找到窗体中的EditText，Button等组件，去填充他们，去点击他们来帮你实现自动化的功能。</p>
<p>像360助手的自动安装功能，它就是侦听着系统安装的APP，然后找到“安装”按钮，实现了自动点击。微信自动抢红包功能，实现方式都是如此。</p>
<h2 id="配置AccessibilityService"><a href="#配置AccessibilityService" class="headerlink" title="配置AccessibilityService"></a>配置AccessibilityService</h2><p>首先我们在res文件夹下创建xml文件夹，然后创建一个名为auto_reply_service_config的文件，一会我们会在清单文件中引用它。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8480a79d9d81a235?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AccessibilityService配置文件"></p>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;accessibility-service 	          xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;     android:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged&quot;</div><div class="line">    android:accessibilityFeedbackType=&quot;feedbackGeneric&quot;</div><div class="line">    android:accessibilityFlags=&quot;flagDefault&quot;</div><div class="line">    android:canRetrieveWindowContent=&quot;true&quot;</div><div class="line">    android:description=&quot;@string/accessibility_description&quot;</div><div class="line">    android:notificationTimeout=&quot;100&quot;</div><div class="line">    android:packageNames=&quot;com.tencent.mm&quot; /&gt;</div></pre></td></tr></table></figure>
<p>这个文件表示我们对AccessibilityService服务未来侦听的行为做了一些配置，比如 <strong>typeNotificationStateChanged</strong> 和 <strong>typeWindowStateChanged</strong> 表示我们需要侦听通知栏的状态变化和窗体状态改变。<br>android:packageNames=”com.tencent.mm” 这是微信的包名，表示我们只关心微信这一个应用。</p>
<p>代码不打算带着大家一行一行看了，如果有不明白的，去看看文档，或者下面回复我，我给大家解答~</p>
<h2 id="创建AccessibilityService"><a href="#创建AccessibilityService" class="headerlink" title="创建AccessibilityService"></a>创建AccessibilityService</h2><p>下面贴出AccessibilityService类的全部代码，注释还算详尽，如有疑问，下方回复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div></pre></td><td class="code"><pre><div class="line">package com.ileja.autoreply;</div><div class="line"></div><div class="line">import android.accessibilityservice.AccessibilityService;</div><div class="line">import android.annotation.SuppressLint;</div><div class="line">import android.app.ActivityManager;</div><div class="line">import android.app.KeyguardManager;</div><div class="line">import android.app.Notification;</div><div class="line">import android.app.PendingIntent;</div><div class="line">import android.content.ClipData;</div><div class="line">import android.content.ClipboardManager;</div><div class="line">import android.content.ComponentName;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.PowerManager;</div><div class="line">import android.text.TextUtils;</div><div class="line">import android.view.KeyEvent;</div><div class="line">import android.view.accessibility.AccessibilityEvent;</div><div class="line">import android.view.accessibility.AccessibilityNodeInfo;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AutoReplyService extends AccessibilityService &#123;</div><div class="line">    private final static String MM_PNAME = &quot;com.tencent.mm&quot;;</div><div class="line">    boolean hasAction = false;</div><div class="line">    boolean locked = false;</div><div class="line">    boolean background = false;</div><div class="line">    private String name;</div><div class="line">    private String scontent;</div><div class="line">    AccessibilityNodeInfo itemNodeinfo;</div><div class="line">    private KeyguardManager.KeyguardLock kl;</div><div class="line">    private Handler handler = new Handler();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 必须重写的方法，响应各种事件。</div><div class="line">     * @param event</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onAccessibilityEvent(final AccessibilityEvent event) &#123;</div><div class="line">        int eventType = event.getEventType();</div><div class="line">        android.util.Log.d(&quot;maptrix&quot;, &quot;get event = &quot; + eventType);</div><div class="line">        switch (eventType) &#123;</div><div class="line">            case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:// 通知栏事件</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;get notification event&quot;);</div><div class="line">                List&lt;CharSequence&gt; texts = event.getText();</div><div class="line">                if (!texts.isEmpty()) &#123;</div><div class="line">                    for (CharSequence text : texts) &#123;</div><div class="line">                        String content = text.toString();</div><div class="line">                        if (!TextUtils.isEmpty(content)) &#123;</div><div class="line">                            if (isScreenLocked()) &#123;</div><div class="line">                                locked = true;</div><div class="line">                                wakeAndUnlock();</div><div class="line">                                android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is locked&quot;);</div><div class="line">                                if (isAppForeground(MM_PNAME)) &#123;</div><div class="line">                                    background = false;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                    handler.postDelayed(new Runnable() &#123;</div><div class="line">                                        @Override</div><div class="line">                                        public void run() &#123;</div><div class="line">                                            sendNotifacationReply(event);</div><div class="line">                                            if (fill()) &#123;</div><div class="line">                                                send();</div><div class="line">                                            &#125;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;, 1000);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    background = true;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                locked = false;</div><div class="line">                                android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is unlocked&quot;);</div><div class="line">                                // 监听到微信红包的notification，打开通知</div><div class="line">                                if (isAppForeground(MM_PNAME)) &#123;</div><div class="line">                                    background = false;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                    handler.postDelayed(new Runnable() &#123;</div><div class="line">                                        @Override</div><div class="line">                                        public void run() &#123;</div><div class="line">                                            if (fill()) &#123;</div><div class="line">                                                send();</div><div class="line">                                            &#125;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;, 1000);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    background = true;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;get type window down event&quot;);</div><div class="line">                if (!hasAction) break;</div><div class="line">                itemNodeinfo = null;</div><div class="line">                String className = event.getClassName().toString();</div><div class="line">                if (className.equals(&quot;com.tencent.mm.ui.LauncherUI&quot;)) &#123;</div><div class="line">                    if (fill()) &#123;</div><div class="line">                        send();</div><div class="line">                    &#125;else &#123;</div><div class="line">                        if(itemNodeinfo != null)&#123;</div><div class="line">                            itemNodeinfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);</div><div class="line">                            handler.postDelayed(new Runnable() &#123;</div><div class="line">                                @Override</div><div class="line">                                public void run() &#123;</div><div class="line">                                    if (fill()) &#123;</div><div class="line">                                        send();</div><div class="line">                                    &#125;</div><div class="line">                                    back2Home();</div><div class="line">                                    release();</div><div class="line">                                    hasAction = false;</div><div class="line">                                &#125;</div><div class="line">                            &#125;, 1000);</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //bring2Front();</div><div class="line">                back2Home();</div><div class="line">                release();</div><div class="line">                hasAction = false;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 寻找窗体中的“发送”按钮，并且点击。</div><div class="line">     */</div><div class="line">    @SuppressLint(&quot;NewApi&quot;)</div><div class="line">    private void send() &#123;</div><div class="line">        AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();</div><div class="line">        if (nodeInfo != null) &#123;</div><div class="line">            List&lt;AccessibilityNodeInfo&gt; list = nodeInfo</div><div class="line">                    .findAccessibilityNodeInfosByText(&quot;发送&quot;);</div><div class="line">            if (list != null &amp;&amp; list.size() &gt; 0) &#123;</div><div class="line">                for (AccessibilityNodeInfo n : list) &#123;</div><div class="line">                    if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled())</div><div class="line">                    &#123;    </div><div class="line">                        n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">            &#125; else &#123;</div><div class="line">                List&lt;AccessibilityNodeInfo&gt; liste = nodeInfo</div><div class="line">                        .findAccessibilityNodeInfosByText(&quot;Send&quot;);</div><div class="line">                if (liste != null &amp;&amp; liste.size() &gt; 0) &#123;</div><div class="line">                    for (AccessibilityNodeInfo n : liste) &#123;</div><div class="line">                        if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled())</div><div class="line">                        &#123;    </div><div class="line">                             n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            pressBackButton();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 模拟back按键</div><div class="line">     */</div><div class="line">    private void pressBackButton()&#123;</div><div class="line">        Runtime runtime = Runtime.getRuntime();</div><div class="line">        try &#123;</div><div class="line">            runtime.exec(&quot;input keyevent &quot; + KeyEvent.KEYCODE_BACK);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @param event</div><div class="line">     */</div><div class="line">    private void sendNotifacationReply(AccessibilityEvent event) &#123;</div><div class="line">        hasAction = true;</div><div class="line">        if (event.getParcelableData() != null</div><div class="line">                &amp;&amp; event.getParcelableData() instanceof Notification) &#123;</div><div class="line">            Notification notification = (Notification) event</div><div class="line">                    .getParcelableData();</div><div class="line">            String content = notification.tickerText.toString();</div><div class="line">            String[] cc = content.split(&quot;:&quot;);</div><div class="line">            name = cc[0].trim();</div><div class="line">            scontent = cc[1].trim();</div><div class="line"></div><div class="line">            android.util.Log.i(&quot;maptrix&quot;, &quot;sender name =&quot; + name);</div><div class="line">            android.util.Log.i(&quot;maptrix&quot;, &quot;sender content =&quot; + scontent);</div><div class="line"></div><div class="line"></div><div class="line">            PendingIntent pendingIntent = notification.contentIntent;</div><div class="line">            try &#123;</div><div class="line">                pendingIntent.send();</div><div class="line">            &#125; catch (PendingIntent.CanceledException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressLint(&quot;NewApi&quot;)</div><div class="line">    private boolean fill() &#123;</div><div class="line">        AccessibilityNodeInfo rootNode = getRootInActiveWindow();</div><div class="line">        if (rootNode != null) &#123;</div><div class="line">            return findEditText(rootNode, &quot;正在忙,稍后回复你&quot;);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private boolean findEditText(AccessibilityNodeInfo rootNode, String content) &#123;</div><div class="line">        int count = rootNode.getChildCount();</div><div class="line"></div><div class="line">        android.util.Log.d(&quot;maptrix&quot;, &quot;root class=&quot; + rootNode.getClassName() + &quot;,&quot;+ rootNode.getText()+&quot;,&quot;+count);</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            AccessibilityNodeInfo nodeInfo = rootNode.getChild(i);</div><div class="line">            if (nodeInfo == null) &#123;</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;nodeinfo = null&quot;);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            android.util.Log.d(&quot;maptrix&quot;, &quot;class=&quot; + nodeInfo.getClassName());</div><div class="line">            android.util.Log.e(&quot;maptrix&quot;, &quot;ds=&quot; + nodeInfo.getContentDescription());</div><div class="line">            if(nodeInfo.getContentDescription() != null)&#123;</div><div class="line">                int nindex = nodeInfo.getContentDescription().toString().indexOf(name);</div><div class="line">                int cindex = nodeInfo.getContentDescription().toString().indexOf(scontent);</div><div class="line">                android.util.Log.e(&quot;maptrix&quot;, &quot;nindex=&quot; + nindex + &quot; cindex=&quot; +cindex);</div><div class="line">                if(nindex != -1)&#123;</div><div class="line">                    itemNodeinfo = nodeInfo;</div><div class="line">                    android.util.Log.i(&quot;maptrix&quot;, &quot;find node info&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (&quot;android.widget.EditText&quot;.equals(nodeInfo.getClassName())) &#123;</div><div class="line">                android.util.Log.i(&quot;maptrix&quot;, &quot;==================&quot;);</div><div class="line">                Bundle arguments = new Bundle();</div><div class="line">                arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,</div><div class="line">                        AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD);</div><div class="line">                arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,</div><div class="line">                        true);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY,</div><div class="line">                        arguments);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_FOCUS);</div><div class="line">                ClipData clip = ClipData.newPlainText(&quot;label&quot;, content);</div><div class="line">                ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);</div><div class="line">                clipboardManager.setPrimaryClip(clip);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PASTE);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (findEditText(nodeInfo, content)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onInterrupt() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断指定的应用是否在前台运行</div><div class="line">     *</div><div class="line">     * @param packageName</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isAppForeground(String packageName) &#123;</div><div class="line">        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        ComponentName cn = am.getRunningTasks(1).get(0).topActivity;</div><div class="line">        String currentPackageName = cn.getPackageName();</div><div class="line">        if (!TextUtils.isEmpty(currentPackageName) &amp;&amp; currentPackageName.equals(packageName)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将当前应用运行到前台</div><div class="line">     */</div><div class="line">    private void bring2Front() &#123;</div><div class="line">        ActivityManager activtyManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = activtyManager.getRunningTasks(3);</div><div class="line">        for (ActivityManager.RunningTaskInfo runningTaskInfo : runningTaskInfos) &#123;</div><div class="line">            if (this.getPackageName().equals(runningTaskInfo.topActivity.getPackageName())) &#123;</div><div class="line">                activtyManager.moveTaskToFront(runningTaskInfo.id, ActivityManager.MOVE_TASK_WITH_HOME);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 回到系统桌面</div><div class="line">     */</div><div class="line">    private void back2Home() &#123;</div><div class="line">        Intent home = new Intent(Intent.ACTION_MAIN);</div><div class="line"></div><div class="line">        home.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">        home.addCategory(Intent.CATEGORY_HOME);</div><div class="line"></div><div class="line">        startActivity(home);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 系统是否在锁屏状态</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isScreenLocked() &#123;</div><div class="line">        KeyguardManager keyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);</div><div class="line">        return keyguardManager.inKeyguardRestrictedInputMode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void wakeAndUnlock() &#123;</div><div class="line">        //获取电源管理器对象</div><div class="line">        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);</div><div class="line"></div><div class="line">        //获取PowerManager.WakeLock对象，后面的参数|表示同时传入两个值，最后的是调试用的Tag</div><div class="line">        PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_BRIGHT_WAKE_LOCK, &quot;bright&quot;);</div><div class="line"></div><div class="line">        //点亮屏幕</div><div class="line">        wl.acquire(1000);</div><div class="line"></div><div class="line">        //得到键盘锁管理器对象</div><div class="line">        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);</div><div class="line">        kl = km.newKeyguardLock(&quot;unLock&quot;);</div><div class="line"></div><div class="line">        //解锁</div><div class="line">        kl.disableKeyguard();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void release() &#123;</div><div class="line"></div><div class="line">        if (locked &amp;&amp; kl != null) &#123;</div><div class="line">            android.util.Log.d(&quot;maptrix&quot;, &quot;release the lock&quot;);</div><div class="line">            //得到键盘锁管理器对象</div><div class="line">            kl.reenableKeyguard();</div><div class="line">            locked = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着配置清单文件，权限和service的配置比较重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    package=&quot;com.ileja.autoreply&quot;&gt;</div><div class="line"></div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.REORDER_TASKS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=&quot;true&quot;</div><div class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">        android:label=&quot;@string/app_name&quot;</div><div class="line">        android:supportsRtl=&quot;true&quot;</div><div class="line">        android:theme=&quot;@style/AppTheme&quot;&gt;</div><div class="line">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line"></div><div class="line">        &lt;service</div><div class="line">            android:name=&quot;.AutoReplyService&quot;</div><div class="line">            android:enabled=&quot;true&quot;</div><div class="line">            android:exported=&quot;true&quot;</div><div class="line">            android:label=&quot;@string/app_name&quot;</div><div class="line">            android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line"></div><div class="line">            &lt;meta-data</div><div class="line">                android:name=&quot;android.accessibilityservice&quot;</div><div class="line">                android:resource=&quot;@xml/auto_reply_service_config&quot;/&gt;</div><div class="line">        &lt;/service&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure>
<p>为了使用某些必要的API，最低API level应该是18</p>
<p>运行程序，打开服务，看看效果如何把~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e94c54ef21781ad7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开辅助服务"></p>
<p>接着用其他手机试着发送给我几条微信</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9098668b06dd7e3d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动回复微信"></p>
<p>可以看到，自动回复功能就实现了。</p>
<p><strong>写在后面：</strong></p>
<p>代码没有给大家详细讲解，不过看注释应该可以看懂个大概。当微信程序切换到后台，或者锁屏（无锁屏密码）时，只要有通知出现，都可以实现自动回复。</p>
<p>关于<strong>AccessibilityService</strong>可以监控的行为非常多，所以我觉得可以实现各种各样炫酷的功能，不过我并不建议你打开某些流氓软件的AccessibilityService服务，因为很有可能造成一些安全问题，所以，自己动手写就安全多了嘛。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android微信自动回复功能&quot;&gt;&lt;a href=&quot;#Android微信自动回复功能&quot; class=&quot;headerlink&quot; title=&quot;Android微信自动回复功能&quot;&gt;&lt;/a&gt;Android微信自动回复功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>跳出手机的Dialog--Presentation</title>
    <link href="http://yoursite.com/2016/07/28/%E8%B7%B3%E5%87%BA%E6%89%8B%E6%9C%BA%E7%9A%84Dialog--Presentation/"/>
    <id>http://yoursite.com/2016/07/28/跳出手机的Dialog--Presentation/</id>
    <published>2016-07-28T02:33:09.556Z</published>
    <updated>2016-07-28T02:34:20.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳出手机的Dialog–Presentation"><a href="#跳出手机的Dialog–Presentation" class="headerlink" title="跳出手机的Dialog–Presentation"></a>跳出手机的Dialog–Presentation</h1><p><strong>写在前面：</strong><br><strong>Presentation 是 what？</strong><br>也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-7e831736d001e10a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容我想想"></p>
<p>Presentation是说明书？<br>Presentation是一个颁奖典礼？<br><strong>Presentation还是某卖药公司UE总监让所有IT人尴尬癌尽犯的PPT Presentation？</strong></p>
<p>公司做的是智能硬件方向，国内有关Presentation资料几乎是空白的，所以我的研究更多参考了Presentation官方文档和一些英文资料。<strong>如果各位看官有什么建议，一定要记得补充。</strong></p>
<h2 id="presentation的定义"><a href="#presentation的定义" class="headerlink" title="presentation的定义"></a>presentation的定义</h2><p>好吧，既然上面这些都不是，Presentation是一个类，我们翻过太平洋的墙，来看看Presentation的定义。</p>
<blockquote>
<p>A presentation is a special kind of dialog whose purpose is to present content on a secondary display.</p>
</blockquote>
<p>我们仅仅先来看这一句定义，因为当你对一个东西完全不了解时候，知道的越多，越会影响你的判断。</p>
<p>翻译下：presentation 是一种特殊的 <strong>dialog</strong> ，目的是为了在<strong>辅助屏幕</strong>上展示不同的内容。</p>
<p>在这句话上，我收集到了两个关键的信息：</p>
<ul>
<li><p><strong>presentation 是一个 dialog</strong><br>根据<strong>生物遗传学</strong>的角度，presentation 无论被描述成什么天花乱坠的模样，它也是一个dialog。</p>
</li>
<li><p><strong>presentation 目的是显示在辅助屏幕上</strong></p>
</li>
</ul>
<p>进一步思考下，也就是说：</p>
<p>我可以拿着我自己的手机，点击一个按钮，然后在你的电脑上或者手机上，弹出一个<strong>自定义的Dialog</strong>（<strong>脑补一下恶作剧场景O(∩_∩)O</strong>）？</p>
<p>这与我们之前，通过一些软件，将手机屏幕同步到电脑上，<strong>区别</strong>又在哪里呢？</p>
<p>相信很多人都能立刻想明白，区别在于：<strong>展示不同内容</strong></p>
<p>通过软件同步到电脑，展示的东西始终与我的手机屏幕相同。</p>
<p>而利用 presentation 我可以自由的展示我想展示的内容，因为它是一个Dialog，是局部可控的。</p>
<h2 id="寻找并投影到辅助屏幕"><a href="#寻找并投影到辅助屏幕" class="headerlink" title="寻找并投影到辅助屏幕"></a>寻找并投影到辅助屏幕</h2><p>产品经理找到我，向我提出了以下几个疑问：</p>
<p>现在手里有一部Android手机</p>
<p> 能否连接以下几种设备</p>
<ul>
<li><p>另一部Android手机</p>
</li>
<li><p>笔记本电脑</p>
</li>
<li><p>智能电视</p>
</li>
<li><p>小米盒子等</p>
</li>
</ul>
<p>并且连接之后，利用presentation展示不同内容。</p>
<p>我乍一看这几个设备，感觉都没问题呀。可是当我拿着手机挨个尝试，几次失败，并且耐心分析之后，发现了问题。</p>
<p>首先Presentation是Android 4.2引出的，与之同时Android 4.2 还支持 Miracast 影像传输协议。所以它俩一定是有联系的。</p>
<p><strong>Miracast</strong> </p>
<p><a href="http://www.360doc.com/content/15/0422/21/1204156_465287702.shtml" target="_blank" rel="external">Miracast简介</a></p>
<p>Miracast是一种基于WIFI的传输协议，Android 4.2以上的手机、Win8电脑、智能电视、盒子几乎都是支持它的。</p>
<p>不过Miracast它将设备分为发送端和接收端<br>发送端有手机、电脑。<br>接收端有智能电视、电视盒子。</p>
<p>所以，手机连手机或电脑展示Presentation，是行不通的。手机作为发射端，去寻找智能电视和盒子才是正解。</p>
<h2 id="Presentation"><a href="#Presentation" class="headerlink" title="Presentation"></a>Presentation</h2><p>终于弄明白了要寻找的设备是怎样的，建立连接之前，参考官方文档的样例，我们先把<strong>Presentation</strong>给搭建好。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9b65f51ad6fddc47?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Presentation类"></p>
<p>可以看到，和Activity一样，可以通过setContentView来给Presentation设置一个布局。自然布局里可以有各种各样的组件，还可以有像GLSurfaceView、SurfaceView 这种重量级的组件，来显示炫酷的动画。这里我们就仅仅写一个TextView，展示一行“show a Presentation”文字。</p>
<p>值得一提的是，在Presentation中的getContext得到的context与它依附的Activity的context是不同的，Presentation的context是目标屏幕属性的context，包含着辅助屏幕的属性信息。</p>
<h2 id="获取辅助屏幕"><a href="#获取辅助屏幕" class="headerlink" title="获取辅助屏幕"></a>获取辅助屏幕</h2><p>获取辅助屏幕有两种方式</p>
<ul>
<li><p><strong>MediaRouter</strong></p>
</li>
<li><p><strong>DisplayManager</strong></p>
</li>
</ul>
<p><strong>MediaRouter</strong></p>
<p>利用MediaRouter的API寻找周围设备是一种最简单的方式了，它会直接绑定周围最合适的设备。就相当于你用谷歌搜索直接点击“<strong>手气不错</strong>”</p>
<p>代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a732a40ac5b0917c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击按钮，展示Presentation"></p>
<p>可以看到在Presentation的构造中，传入了一个display，这就是搜索到的那个设备</p>
<p>先来测试一下，Android 4.2的手机在开发中选项中，都有模拟辅助屏幕的功能，我们选择一个分辨率，打开它，模拟一个外部的屏幕。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ac89976cb382208d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开模拟辅助屏幕"></p>
<p>默认辅助屏幕是同步手机屏幕的，打开之后，进入测试app，点击按钮：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bf37642c0f80de9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>注意这可不是一个Dialog，而是我们把内容展示在了一个模拟的辅助屏幕上，回头看看标题，是不是就实现了呢？</p>
<p><strong>DisplayManager</strong></p>
<p>第二种搜索设备的方法是DisplayManager，他可以搜索周围所有可用的display，产生一个display数组，然后你就可以选择合适的设备进行展示了。</p>
<p>代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-64ae611bb26eb676?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayManager"></p>
<p>代码还是挺简单的，搜索到周围所有可用设备之后，展示到ListView上，点击条目，在APP上和Presentataion上分别跑一个秒表，看看延时性如何，截图如下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-3eaea827329729f0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayManager"></p>
<p>可以看到，搜索到的设备名称是  <strong>叠加视图#1</strong> ，点击条目之后两个秒表也分别跑了起来。</p>
<p><strong>总结：</strong></p>
<p>上面对Presentation进行了一个简略的介绍，因为相信大家如果做的不是智能硬件方向，基本上不会遇到这个需求。关于Activity对Presentation的管理方式，官方文档的有两个Demo可以参考，需要时可以去查看。</p>
<p><strong>写在后面：</strong></p>
<p>周末在连接智能电视测试时，发现延时很小，完全可以投入使用。<br>关于Presentation资料比较少，欢迎大家一同交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跳出手机的Dialog–Presentation&quot;&gt;&lt;a href=&quot;#跳出手机的Dialog–Presentation&quot; class=&quot;headerlink&quot; title=&quot;跳出手机的Dialog–Presentation&quot;&gt;&lt;/a&gt;跳出手机的Dialog–Presentation&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Presentation 是 what？&lt;/strong&gt;&lt;br&gt;也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Presentation" scheme="http://yoursite.com/tags/Presentation/"/>
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>3分钟傻瓜式反编译一个APP</title>
    <link href="http://yoursite.com/2016/07/28/3%E5%88%86%E9%92%9F%E5%82%BB%E7%93%9C%E5%BC%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AAAPP/"/>
    <id>http://yoursite.com/2016/07/28/3分钟傻瓜式反编译一个APP/</id>
    <published>2016-07-28T02:32:03.731Z</published>
    <updated>2016-07-28T02:32:41.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3分钟傻瓜式反编译一个APP"><a href="#3分钟傻瓜式反编译一个APP" class="headerlink" title="3分钟傻瓜式反编译一个APP"></a>3分钟傻瓜式反编译一个APP</h1><p><strong>写在前面：</strong><br>最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~<br>前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。<br><a id="more"></a></p>
<h2 id="反编译是为了啥？"><a href="#反编译是为了啥？" class="headerlink" title="反编译是为了啥？"></a>反编译是为了啥？</h2><p>我们什么时候需要反编译呢？</p>
<ul>
<li><p>想获得目标APP的资源（图片等）</p>
</li>
<li><p>有功能不会写了，参考（copy）一下同类APP</p>
</li>
<li><p>某些“羞羞”的事情</p>
</li>
</ul>
<p>前两条需求还是蛮常见的，最后一条是开个玩笑，别做<strong>坏事</strong>就~</p>
<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul>
<li><p>onekey decompile apk （一键反编译APK工具）</p>
</li>
<li><p>目标APK</p>
<p> <a href="http://download.csdn.net/download/g_bird0622/7145155" target="_blank" rel="external">onekey decompile apk下载链接</a></p>
</li>
</ul>
<h2 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h2><p>下载工具压缩包</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-7095016c09c79e8b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载压缩包"></p>
<p>多说一句，这个工具集成了三个反编译的工具的功能，一步到位。如果你对这三个工具各自的功能使用感兴趣，<strong>自行搜索学习</strong>一下。</p>
<p>解压到C盘根目录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-203b3fb4209cf8dd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压到C盘根目录"></p>
<p>这里强调一下，最好是放在C盘根目录下，放到别的盘反编译可能会失败。我就失败过一次，具体原因是什么不得而知~</p>
<p><strong>得到以下文件：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e3b98a03c4269c2d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到以下文件"></p>
<p>将要反编译的APK放到这个目录下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-0b0cdfd317a1af22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="放APK到目录下"></p>
<p>将apk文件<strong>拖拽</strong>到<code>_onekey-decompile-apk.bat</code>上</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d84f2f1dae7043a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拖拽"></p>
<p><strong>然后耐心等待十几秒……</strong></p>
<p><strong>源代码弹出，反编译完成！</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-378d927bd2257158?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译完成"></p>
<ul>
<li>会在<code>onekey-decompile-apk</code>目录下生成和apk同名的目录(放置了apktools反编译出来的东西)</li>
<li>会在<code>onekey-decompile-apk</code>目录下生成和apk同名的jar文件(dex2jar反编译出来的class)</li>
</ul>
<p>图片资源会很完整，有些代码被混淆了，不过还是能看懂个大概的~</p>
<p><strong>写在后面：</strong></p>
<p>这个工具的作用不止于此，有需要再慢慢研究吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3分钟傻瓜式反编译一个APP&quot;&gt;&lt;a href=&quot;#3分钟傻瓜式反编译一个APP&quot; class=&quot;headerlink&quot; title=&quot;3分钟傻瓜式反编译一个APP&quot;&gt;&lt;/a&gt;3分钟傻瓜式反编译一个APP&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~&lt;br&gt;前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Handler可能造成内存泄漏（四）</title>
    <link href="http://yoursite.com/2016/07/28/Handler%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Handler可能造成内存泄漏（四）/</id>
    <published>2016-07-28T02:18:57.129Z</published>
    <updated>2016-07-28T02:19:58.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler可能造成内存泄漏（四）"><a href="#Handler可能造成内存泄漏（四）" class="headerlink" title="Handler可能造成内存泄漏（四）"></a>Handler可能造成内存泄漏（四）</h1><p><strong>写在前面：</strong><br>不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：<br><a id="more"></a><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">子线程为何不能更新UI（一）</a></p>
<p>第一篇中我们探究了，在Android设计之时，为何子线程允许更新UI。官方给出的解释是由于<strong>线程安全</strong>（Thread Safe）问题。（当然也有一些其他方面的猜想）</p>
<p><a href="http://www.jianshu.com/p/8501d3b0c359" target="_blank" rel="external">解决在子线程更新UI崩溃问题（二）</a></p>
<p>第二篇中，我们总结了三种崩溃解决的办法。</p>
<ul>
<li><p>Activity.runOnUIThread();</p>
</li>
<li><p>View.post();</p>
</li>
<li><p>Handler;</p>
</li>
</ul>
<p>我们本着寻找最优解的思路比较了三种解决办法，发现代码的实现方式都为Handler，从而真正引出了Android消息机制，Handler。</p>
<p><a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">带着这篇去通关所有Handler的提问（三）</a></p>
<p>第三篇文章是我们这个系列的重头戏，我用一个还算生动的故事，为大家解释了Handler和相关核心类的关系，推荐阅读。</p>
<p>OK，回顾之后，我们正式来开始本篇文章。</p>
<h2 id="内存泄漏是怎么一回事？"><a href="#内存泄漏是怎么一回事？" class="headerlink" title="内存泄漏是怎么一回事？"></a>内存泄漏是怎么一回事？</h2><p>可以看到，标题中有一个显眼的名词，就是<strong>内存泄漏</strong>，我想有必要给初学的朋友们讲讲何为内存泄漏。</p>
<p>在讨论内存泄漏之前，先简单的说说Android中<strong>内存的回收</strong></p>
<p><strong>Dalivik</strong>虚拟机扮演了常规的垃圾回收角色，为了<strong>GC</strong>能够从App中及时回收内存，我们需要时时刻刻在适当的时机来释放<strong>引用对象</strong>，Dalvik的GC会自动把离开<strong>活动线程</strong>的对象进行回收。</p>
<p>什么是<strong>Android内存泄漏</strong>：</p>
<p>虽然Android是一个<strong>自动管理内存</strong>的开发环境，但是垃圾回收器只会移除那些已经失去引用的、不可达的对象，在十几万、几十万行代码中，由于你的失误使得一个本应该被<strong>销毁的对象仍然被错误的持有</strong>，那么该对象就永远不会被释放掉，这些已经没有任何价值的对象，仍然占据<strong>聚集在你的堆内存中</strong>，GC就会被频繁触发，多说几句，如果手机不错，一次GC的时间70毫秒，不会对应用的性能产生什么影响，但是如果一个手机的性能不是那么出色，一次GC时间120毫秒，出现大量的GC操作，我相信用户就能感觉到了吧。这些无用的引用堆积在堆内存中，越积越多最终导致Crash。</p>
<p>有关一些性能优化推荐给大家一个我总结的博客。</p>
<p><a href="http://www.jianshu.com/p/be05874965d4" target="_blank" rel="external">Android性能优化总结</a></p>
<p>扯得好像远了一点，既然明白了内存泄漏是怎么回事，那与<strong>Handler</strong>又有什么关系呢？</p>
<h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><p>参考一篇外文：</p>
<p><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html" target="_blank" rel="external">inner-class-handler-memory-leak</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-cdcc17e0dcd66c8c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Handler时，给出的warnning"></p>
<p>当我们正常使用Handler时，会给出一个<strong>warning</strong>提示。翻译过来就是，这个Handler类应该是静态的，否则可能造成内存泄漏。</p>
<p>当我们简单的使用Handler的时候，并不会踩到内存泄漏这个坑，不过当Handler作为一个<strong>内部类或者匿名类</strong>时，这个问题就可能发生。</p>
<p>在上篇中，我们知道，当Android启动之时，<strong>ActivityThread</strong>类中，会创建<strong>UI</strong>线程的<strong>Looper</strong>和<strong>MessageQueue</strong></p>
<p>MessageQueue中的消息会被一个接一个处理。应用的所有事件(比如<strong>Activity生命周期</strong>回调方法，<strong>按钮点击</strong>等等)都会被当做一个消息对象放入到Looper的消息队列中，然后再被逐一执行。UI线程的Looper存在于整个应用的<strong>生命周期</strong>内。</p>
<p>当在UI线程中创建Handler对象时，它就会和UI线程中Looper的消息队列进行关联。发送到这个消息队列中的消息会持有这个Handler的<strong>引用</strong>，这样当Looper最终处理这个消息的时候framework就会调用Handler#handleMessage(Message)方法来处理具体的逻辑。</p>
<p><strong>在Java中，非静态的内部类或者匿名类会隐式的持有其外部类的引用，而静态的内部类则不会。</strong></p>
<p>那么，内存到底是在哪里泄露的呢？其实泄漏发生的还是比较隐晦的，但是再看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SampleActivity extends Activity &#123;</div><div class="line"></div><div class="line">  private final Handler mLeakyHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">      // ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    // Post a message and delay its execution for 10 minutes.</div><div class="line">    mLeakyHandler.postDelayed(new Runnable() &#123;</div><div class="line">      @Override</div><div class="line">      public void run() &#123; /* ... */ &#125;</div><div class="line">    &#125;, 1000 * 60 * 10);</div><div class="line"></div><div class="line">    // Go back to the previous Activity.</div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当activity被finish的时候，延迟发送的消息仍然会存活在UI线程的消息队列中，直到10分钟后它被处理掉。这个消息持有activity的Handler的引用，Handler又隐式的持有它的外部类(这里就是SampleActivity)的引用。这个引用会一直存在直到这个消息被处理，所以垃圾回收机制就没法回收这个activity，内存泄露就发生了。需要注意的是：15行的匿名Runnable子类也会导致内存泄露。非静态的匿名类会隐式的持有外部类的引用，所以context会被泄露掉。</p>
<p>解决这个问题也很简单：在新的类文件中实现Handler的子类或者使用static修饰内部类。静态的内部类不会持有外部类的引用，所以activity不会被泄露。如果你要在Handler内调用外部activity类的方法的话，可以让Handler持有外部activity类的弱引用，这样也不会有泄露activity的风险。关于匿名类造成的泄露问题，我们可以用static修饰这个匿名类对象解决这个问题，因为静态的匿名类也不会持有它外部类的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SampleActivity extends Activity &#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Instances of static inner classes do not hold an implicit</div><div class="line">   * reference to their outer class.</div><div class="line">   */</div><div class="line">  private static class MyHandler extends Handler &#123;</div><div class="line">    private final WeakReference&lt;SampleActivity&gt; mActivity;</div><div class="line"></div><div class="line">    public MyHandler(SampleActivity activity) &#123;</div><div class="line">      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">      SampleActivity activity = mActivity.get();</div><div class="line">      if (activity != null) &#123;</div><div class="line">        // ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private final MyHandler mHandler = new MyHandler(this);</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Instances of anonymous classes do not hold an implicit</div><div class="line">   * reference to their outer class when they are &quot;static&quot;.</div><div class="line">   */</div><div class="line">  private static final Runnable sRunnable = new Runnable() &#123;</div><div class="line">      @Override</div><div class="line">      public void run() &#123; /* ... */ &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    // Post a message and delay its execution for 10 minutes.</div><div class="line">    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);</div><div class="line"></div><div class="line">    // Go back to the previous Activity.</div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态和非静态内部类的区别是非常微妙的，但这个区别是每个Android开发者应该清楚的。那么底线是什么？如果要实例化一个超出activity生命周期的内部类对象，避免使用非静态的内部类。建议使用静态内部类并且在内部类中持有外部类的弱引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Handler可能造成内存泄漏（四）&quot;&gt;&lt;a href=&quot;#Handler可能造成内存泄漏（四）&quot; class=&quot;headerlink&quot; title=&quot;Handler可能造成内存泄漏（四）&quot;&gt;&lt;/a&gt;Handler可能造成内存泄漏（四）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>带着这篇去通关所有Handler的提问（三）</title>
    <link href="http://yoursite.com/2016/07/28/%E5%B8%A6%E7%9D%80%E8%BF%99%E7%AF%87%E5%8E%BB%E9%80%9A%E5%85%B3%E6%89%80%E6%9C%89Handler%E7%9A%84%E6%8F%90%E9%97%AE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/带着这篇去通关所有Handler的提问（三）/</id>
    <published>2016-07-28T02:17:44.984Z</published>
    <updated>2016-07-28T02:18:29.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="带着这篇去通关所有Handler的提问（三）"><a href="#带着这篇去通关所有Handler的提问（三）" class="headerlink" title="带着这篇去通关所有Handler的提问（三）"></a>带着这篇去通关所有Handler的提问（三）</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-5b46d5a0584720ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br>大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的<strong>思路</strong>和<strong>知识点</strong>：<br><a id="more"></a><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">Android消息机制字典型探究（一）</a></p>
<p>在第一篇文章中，我们总结了Android系统不允许在子线程更新UI的原因，本质上是<strong>线程安全问题</strong>，从而引出了Handler。</p>
<p><a href="http://www.jianshu.com/p/8501d3b0c359" target="_blank" rel="external">Android消息机制字典型探究（二）</a></p>
<p>在第二篇文章中，我们又分析了三种在子线程更新UI的方法，分别是：<strong>View.post(param); Activity.runOnUIThread(param); Handler</strong>，当我们对这三种方法的源码进一步分析发现，其实都是对Handler做了一些封装，所以本文我们就来正式全面探究有关<strong>Handler</strong>的知识点。</p>
<p>当时我去面试的四家公司，都问到了Handler的相关知识，有深有浅，所以重要程度<strong>不言而喻</strong>。面试官拿起你的简历，让你谈谈Handler，你仅仅在表象上回答了Android线程通信的机理，然后面试官紧接着问了你如下的几个问题：</p>
<ul>
<li><p>Handler是属于哪个类的？</p>
</li>
<li><p>Handler、Looper、MessageQueue何时建立的相互关系？</p>
</li>
<li><p>主线程的Looper和MessageQueue是何时创建的？</p>
</li>
<li><p>在同一线程中，Looper和MessageQueue是怎样的数量对应关系，与Handler又是怎样的数量对应关系？</p>
</li>
<li><p>MessageQueue中消息为空，线程阻塞挂起等待，为什么不会造成ANR？</p>
</li>
<li><p>有关Handler的内存泄漏是怎么一回事？</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-7a0d4ec7091a39fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一脸萌比"></p>
<p>so…光知道表象很可能是不够的，而且还给自己挖了一个坑，所以我们对于一个知识点的探寻要全面充分一点。下面正式开始本文。</p>
<h2 id="Windows和Android消息机制的区别"><a href="#Windows和Android消息机制的区别" class="headerlink" title="Windows和Android消息机制的区别"></a>Windows和Android消息机制的区别</h2><p>现在的操作系统普遍采用消息驱动模式。Windows操作系统就是典型的<strong>消息驱动模型</strong>。但是，Android的消息处理机制和Windows的消息处理机制又不太相同。我给大家画了图，看看二者的区别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-989ad8fda07a2608?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Windows进程消息模型"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d41410cd42ed3d8d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android进程消息模型"></p>
<p>通过消息机制图的对比，Windows消息处理模型中，存在一个系统的消息队列，这个队列是整个进程的核心，几乎所有的动作都要转换成消息，然后放到这个队列中，由主线程统一处理。</p>
<p>而Android没有全局的消息队列，消息队列是和某个线程相关联在一起的。每个线程最多有一个消息队列，消息的取出和处理，也在这个线程本身中完成。</p>
<p>也就是说，Android中，如果你想在当前线程使用消息模型，则必须构建一个消息队列，而消息机制的相关主要类是：<strong>Looper、Handler、MessageQueue、Message。</strong></p>
<p>我们并不着急去翻看这些类的源码，理清楚底层实现的逻辑，而且先在宏观表象上看看，Android消息机制是如何运行的？</p>
<h2 id="Android消息机制的宏观原理"><a href="#Android消息机制的宏观原理" class="headerlink" title="Android消息机制的宏观原理"></a>Android消息机制的宏观原理</h2><p>先来看一张<strong>Android消息处理类之间的关系图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-514571cad65f7171?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android消息处理机制"></p>
<p>我们从表象上解释一下原理，Handler负责将Message发送至当前线程的MessageQueue中，Looper时时刻刻监视着MessageQueue，将符合时间要求的Message取出，再带给发送消息的那个Handler通过HandleMessage处理。</p>
<p>对于消息机制的理解不能仅仅停留在这一步，下面我们从源码的角度分析一下具体的逻辑细节。</p>
<h2 id="Android消息机制相关类的源码分析"><a href="#Android消息机制相关类的源码分析" class="headerlink" title="Android消息机制相关类的源码分析"></a>Android消息机制相关类的源码分析</h2><p>其实写这篇文章之前，我就一直在思考，站在什么角度展开这个机制的描述，更容易让大家理解接受。思来想去，我觉得还是以一个Message游历的形式去描写，会显着有趣和清晰一点。</p>
<p><strong>Message：</strong></p>
<p>人在边境X（<strong>子线程</strong>）服役的士兵Message慵懒得躺在一个人数为50（池中最大数量）的军营（Message池）中。不料这时突然接到了上司的obtain()命令（据说obtain命令更加节省军费），让他去首都（<strong>主线程</strong>）告诉中央领导一些神秘代码。小Message慌乱地整理了下衣角和帽子，带上信封，准备出发。</p>
<p>上司让士兵Message收拾完毕之后等待一个神秘人的电话，并且嘱咐他：到了首都之后，0是这次任务的暗号。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-080d1ddd6f3223a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Message的创建和携带信息"></p>
<p>Message是消息的载体，Message设计成为<strong>Parcelable</strong>类的派生类，这表明Message可以通过<strong>binder</strong>来跨进程发送。<br>通常我们都会用<strong>obtain()</strong>方法去创建Message，如果消息池中有Message有，则取出，没有，再重新创建。这样可以防止对象的重复创建，节省资源。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8982fddc999074a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="obtain方法源码"></p>
<p>“铃铃铃…”小Message接到了一个陌生男子的电话。<br>“我叫handler，来自activity大本营，是你这次任务的接受者，一会我带你去首都的消息中心去报道。”</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>来自Activity大本营Handler部门是整个消息机制系统的核心部门，当然部门下有<strong>很多个</strong> Handler，这次协助小Message任务的叫mHandler。Handler部门下的员工都有一个特点，就是只关心自己的message。</p>
<p>Handler属于Activity，创建任何一个Handler都属于重写了Activity中的Handler。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-39a9617e0ae54894?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity中定义了Handler"></p>
<p>在Handler的构造中，默认完成了对当前线程Looper的绑定，至于Looper是谁，一会再谈。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-52c8a9bd457f43b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler的构造方法"></p>
<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过mLooper.mQueue获取了Looper中的MessageQueue实例。在此时，mhandler实例与looper和messageQueue实例，关联上了。</p>
<p>mHandler神情骄傲得对小Message说：我已经跟首都的消息中心打好了招呼，准备接收你了，现在有两种车，一种车名叫“<strong>send</strong>”，一种叫“<strong>post</strong>”，你想坐哪辆去首都都可以，不过要根据你上司的命令，选择车种类下对应的型号哦~</p>
<ul>
<li><p><strong>send</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-304ec3faab1a3176?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
<li><p><strong>post</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-0b9ad4781e0b1861?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
</ul>
<p>从代码的实现上来看，post方法也是在使用send类的方法在发送消息，只是他们的参数要求是Runnable对象。</p>
<p>通过对Handler源码的分析，发现除了sendMessageAtFrontOfQueue方法之外，其余任何send的相关方法，都经过层层包装走到了sendMessageAtTime方法中，我们来看看源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-fd684532b5c792e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime源码"></p>
<p>这时小Message和mHandler一同上了车牌号为“sendMessage”的车，行驶在一条叫“enqueueMessage”的高速公路上，mHandler向一无所知的小Message介绍说，每个像他一样的Message都是通过<strong>enqueueMessage</strong>路进入MessageQueue的。我们是要去首都的MessageQueue中心，其实你的消息到时候也是我处理的，不过现在还不是时候哦，因为我很忙。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-12ec385d2ec1164f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage源码"></p>
<p>enqueueMessage是MessageQueue的方法，用来将Message根据时间排序，放入到MessageQueue中。其中msg.target = this，<strong>是保证每个发送Message的Handler也能处理这个Message。</strong></p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>路上的时间不短不长，mHandler依然为小Message热心介绍着MessageQueue和Looper<br>“在每个驻扎地（线程）中，只有一个MessageQueue和一个Looper，他们两个是相杀相爱，同生共死的好基友，Looper是个跑不死的邮差，一直负责取出MessageQueue中的Message”<br>“不过通常只有首都（主线程）的Looper和MessageQueue是创建好的，其他地方需要我们人为地创建哦~”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bed816d7d28d1c87?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepare方法"></p>
<p>Looper类提供了prepare方法来创建Looper。可以看到，当重复创建Looper时，会抛出异常，也就是说，每个线程只有一个Looper。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9fe5b7b2e249c771?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Looper构造"></p>
<p>紧接着在Looper的构造方法中，又创建了与它一一对应的MessageQueue，既然Looper在一个线程中是唯一的，所以MessageQueue也是唯一的。</p>
<p>在Android中，ActivityThread的main方法是程序的入口，主线程的Looper和MessageQueue就是在此时创建的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-2a78bc7e32ab5990?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityThread的main方法"></p>
<p>可以看到，在main方法中，既创建了Looper，也调用了<strong>Looper.loop()</strong>方法。</p>
<p>mHandler和小Message通过enqueueMessage路来到了MessageQueue中，进入之前，门卫仔仔细细地给小Message贴上了以下标签：<br>“mHandler负责带入”<br>“处理时间为0ms”<br>并且告诉小Message，一定要按照时间顺序排队。<br>进入队伍中，Looper大哥正在不辞辛劳的将一个又一个跟小Message一样的士兵带走。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-663c57da42f084c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loop方法"></p>
<p>分析一下loop方法，有一个for的死循环，不断地调用queue.next方法，在消息队列中取Message。并且在Message中取出target，这个target其实就是发送消息的handler，调用它的dispatchMessage方法。</p>
<p>首都的MessageQueue中心虽然人很多，但是大家都井井有条的排着队伍，Looper老哥看了一眼手里的名单，叫到了小Message的名字，看了一眼小Message身上的标签，对他说：“喔，又是mHandler带来的人啊，那把你交给他处理了”</p>
<p>忐忑不安的小Message看到了一个熟悉的身影，mHandler就在面前，显然mHandler有些健忘，可能是接触了太多跟小Message一样的人，为了让mHandler想起自己，小Message说出了上司交给他的暗号0.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b6daebfefccb8e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchMessage方法"></p>
<p>可以看见dispatchMessage方法中的逻辑比较简单，具体就是如果mCallback不为空，则调用mCallback的handleMessage()方法，否则直接调用Handler的handleMessage()方法，并将消息对象作为参数传递过去。</p>
<p>在handlerMessage()方法中，小Message出色的完成了自己的任务。</p>
<p><strong>写在后面：</strong></p>
<p>下一篇中，我们会探讨一下为什么loop方法中for死循环不会造成ANR，有一些有关Handler的使用技巧，以及可能造成的内存泄漏，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;带着这篇去通关所有Handler的提问（三）&quot;&gt;&lt;a href=&quot;#带着这篇去通关所有Handler的提问（三）&quot; class=&quot;headerlink&quot; title=&quot;带着这篇去通关所有Handler的提问（三）&quot;&gt;&lt;/a&gt;带着这篇去通关所有Handler的提问（三）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-5b46d5a0584720ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的&lt;strong&gt;思路&lt;/strong&gt;和&lt;strong&gt;知识点&lt;/strong&gt;：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>5分钟实现Android中更换头像功能</title>
    <link href="http://yoursite.com/2016/07/28/5%E5%88%86%E9%92%9F%E5%AE%9E%E7%8E%B0Android%E4%B8%AD%E6%9B%B4%E6%8D%A2%E5%A4%B4%E5%83%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/28/5分钟实现Android中更换头像功能/</id>
    <published>2016-07-28T02:16:11.761Z</published>
    <updated>2016-07-28T02:17:14.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5分钟实现Android中更换头像功能"><a href="#5分钟实现Android中更换头像功能" class="headerlink" title="5分钟实现Android中更换头像功能"></a>5分钟实现Android中更换头像功能</h1><p><strong>写在前面：</strong><br>更换头像这个功能在用户界面几乎是<strong>100%</strong>出现的。通过<strong>拍摄照片</strong>或者<strong>调用图库中的图片</strong>，并且进行剪裁，来进行头像的设置。<br>功能相关<strong>截图</strong>如下：<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-1326e6af0cd65974?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户界面，头像未设置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-5d3ecb18b3ee4220?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击头像，弹出Dialog"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-22349a556aec7417?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择照片，进行剪裁"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bb2445cf910509af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头像设置成功"></p>
<p>下面我们直接看看<strong>完整代码</strong>吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class UserActivity extends BaseActivity implements OnClickListener &#123;</div><div class="line"></div><div class="line">	private ImageView iv_photo;</div><div class="line">	private Bitmap head;// 头像Bitmap</div><div class="line">	private static String path = &quot;/sdcard/myHead/&quot;;// sd路径</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		initView();</div><div class="line">		initListener();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void initView() &#123;</div><div class="line">		setContentView(R.layout.activity_user);</div><div class="line">		iv_photo = (ImageView) findViewById(R.id.iv_photo);</div><div class="line">		Bitmap bt = BitmapFactory.decodeFile(path + &quot;head.jpg&quot;);// 从SD卡中找头像，转换成Bitmap</div><div class="line">		if (bt != null) &#123;</div><div class="line">			@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">			Drawable drawable = new BitmapDrawable(bt);// 转换成drawable</div><div class="line">			iv_photo.setImageDrawable(drawable);</div><div class="line">		&#125; else &#123;</div><div class="line">			/**</div><div class="line">			 * 如果SD里面没有则需要从服务器取头像，取回来的头像再保存在SD中</div><div class="line">			 * </div><div class="line">			 */</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void initListener() &#123;</div><div class="line">		iv_photo.setOnClickListener(this);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		switch (v.getId()) &#123;</div><div class="line">		case R.id.iv_photo:// 更换头像</div><div class="line">			showTypeDialog();</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void showTypeDialog() &#123;</div><div class="line">		AlertDialog.Builder builder = new AlertDialog.Builder(this);</div><div class="line">		final AlertDialog dialog = builder.create();</div><div class="line">		View view = View.inflate(this, R.layout.dialog_select_photo, null);</div><div class="line">		TextView tv_select_gallery = (TextView) view.findViewById(R.id.tv_select_gallery);</div><div class="line">		TextView tv_select_camera = (TextView) view.findViewById(R.id.tv_select_camera);</div><div class="line">		tv_select_gallery.setOnClickListener(new OnClickListener() &#123;// 在相册中选取</div><div class="line">			@Override</div><div class="line">			public void onClick(View v) &#123;</div><div class="line">				Intent intent1 = new Intent(Intent.ACTION_PICK, null);</div><div class="line">				intent1.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);</div><div class="line">				startActivityForResult(intent1, 1);</div><div class="line">				dialog.dismiss();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		tv_select_camera.setOnClickListener(new OnClickListener() &#123;// 调用照相机</div><div class="line">			@Override</div><div class="line">			public void onClick(View v) &#123;</div><div class="line">				Intent intent2 = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">				intent2.putExtra(MediaStore.EXTRA_OUTPUT,</div><div class="line">						Uri.fromFile(new File(Environment.getExternalStorageDirectory(), &quot;head.jpg&quot;)));</div><div class="line">				startActivityForResult(intent2, 2);// 采用ForResult打开</div><div class="line">				dialog.dismiss();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		dialog.setView(view);</div><div class="line">		dialog.show();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">		switch (requestCode) &#123;</div><div class="line">		case 1:</div><div class="line">			if (resultCode == RESULT_OK) &#123;</div><div class="line">				cropPhoto(data.getData());// 裁剪图片</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			break;</div><div class="line">		case 2:</div><div class="line">			if (resultCode == RESULT_OK) &#123;</div><div class="line">				File temp = new File(Environment.getExternalStorageDirectory() + &quot;/head.jpg&quot;);</div><div class="line">				cropPhoto(Uri.fromFile(temp));// 裁剪图片</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			break;</div><div class="line">		case 3:</div><div class="line">			if (data != null) &#123;</div><div class="line">				Bundle extras = data.getExtras();</div><div class="line">				head = extras.getParcelable(&quot;data&quot;);</div><div class="line">				if (head != null) &#123;</div><div class="line">					/**</div><div class="line">					 * 上传服务器代码</div><div class="line">					 */</div><div class="line">					setPicToView(head);// 保存在SD卡中</div><div class="line">					iv_photo.setImageBitmap(head);// 用ImageView显示出来</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			break;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		super.onActivityResult(requestCode, resultCode, data);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 调用系统的裁剪功能</div><div class="line">	 * </div><div class="line">	 * @param uri</div><div class="line">	 */</div><div class="line">	public void cropPhoto(Uri uri) &#123;</div><div class="line">		Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</div><div class="line">		intent.setDataAndType(uri, &quot;image/*&quot;);</div><div class="line">		intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</div><div class="line">		// aspectX aspectY 是宽高的比例</div><div class="line">		intent.putExtra(&quot;aspectX&quot;, 1);</div><div class="line">		intent.putExtra(&quot;aspectY&quot;, 1);</div><div class="line">		// outputX outputY 是裁剪图片宽高</div><div class="line">		intent.putExtra(&quot;outputX&quot;, 150);</div><div class="line">		intent.putExtra(&quot;outputY&quot;, 150);</div><div class="line">		intent.putExtra(&quot;return-data&quot;, true);</div><div class="line">		startActivityForResult(intent, 3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void setPicToView(Bitmap mBitmap) &#123;</div><div class="line">		String sdStatus = Environment.getExternalStorageState();</div><div class="line">		if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) &#123; // 检测sd是否可用</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		FileOutputStream b = null;</div><div class="line">		File file = new File(path);</div><div class="line">		file.mkdirs();// 创建文件夹</div><div class="line">		String fileName = path + &quot;head.jpg&quot;;// 图片名字</div><div class="line">		try &#123;</div><div class="line">			b = new FileOutputStream(fileName);</div><div class="line">			mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, b);// 把数据写入文件</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; finally &#123;</div><div class="line">			try &#123;</div><div class="line">				// 关闭流</div><div class="line">				b.flush();</div><div class="line">				b.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再添加以下权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure>
<p>Dialog的xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; &gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_select_gallery&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:gravity=&quot;center_horizontal&quot;</div><div class="line">        android:padding=&quot;20dp&quot;</div><div class="line">        android:text=&quot;从图库中选取&quot;</div><div class="line">        android:textColor=&quot;#000&quot;</div><div class="line">        android:textSize=&quot;20sp&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;View</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;1dp&quot;</div><div class="line">        android:layout_marginLeft=&quot;10dp&quot;</div><div class="line">        android:layout_marginRight=&quot;10dp&quot;</div><div class="line">        android:background=&quot;#000&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_select_camera&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:gravity=&quot;center_horizontal&quot;</div><div class="line">        android:padding=&quot;20dp&quot;</div><div class="line">        android:text=&quot;拍摄照片&quot;</div><div class="line">        android:textColor=&quot;#000&quot;</div><div class="line">        android:textSize=&quot;20sp&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>代码的注释还算全面，仔细阅读一定能看懂，大家可以试试这个demo~这样一个更换头像的功能就实现了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5分钟实现Android中更换头像功能&quot;&gt;&lt;a href=&quot;#5分钟实现Android中更换头像功能&quot; class=&quot;headerlink&quot; title=&quot;5分钟实现Android中更换头像功能&quot;&gt;&lt;/a&gt;5分钟实现Android中更换头像功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;更换头像这个功能在用户界面几乎是&lt;strong&gt;100%&lt;/strong&gt;出现的。通过&lt;strong&gt;拍摄照片&lt;/strong&gt;或者&lt;strong&gt;调用图库中的图片&lt;/strong&gt;，并且进行剪裁，来进行头像的设置。&lt;br&gt;功能相关&lt;strong&gt;截图&lt;/strong&gt;如下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制字典型探究（二）</title>
    <link href="http://yoursite.com/2016/07/28/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AD%97%E5%85%B8%E5%9E%8B%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Android消息机制字典型探究（二）/</id>
    <published>2016-07-28T02:14:33.902Z</published>
    <updated>2016-07-28T02:15:31.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android消息机制字典型探究（二）"><a href="#Android消息机制字典型探究（二）" class="headerlink" title="Android消息机制字典型探究（二）"></a>Android消息机制字典型探究（二）</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-8d34278385fceccd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">Android消息机制字典型探究（一）</a><br>为了完成整个<strong>Android消息机制的探究</strong>，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中<strong>不允许子线程更新UI</strong>的原因，是由于<strong>线程安全</strong>的问题。<br>当然我们<strong>目前</strong>分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：<strong>实践去发现问题，全面的理解问题，寻找最优解</strong>。Android本身就是一个复杂而有机的整体，<strong>由一个知识点可以牵出一条知识线。从而构成相关的知识体系</strong>。<br><a id="more"></a><br><strong>这种学习方式会让你知道的越来越多，也能站在一定的高度上体会Android在设计之时的巧妙，全局的理解Android，做到融会贯通。也能在你的代码中，收获很多有益的启发。</strong></p>
<p>说完以上这些，就可以正式开始本文的话题了。既然在我们只可以在主线程更新UI，那解决这个问题，一共有几种方式呢？我就来直接告诉大家，解决子线程更新UI问题的方式，<strong>一共有三种。</strong></p>
<ol>
<li><p><strong>runOnUiThread</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ee3a4f5a9a294b01?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runOnUiThread的使用"></p>
<p>简单讲解一下代码，点击crash按钮，开启一个子线程，显然我们在子线程中直接给 <strong>iv_handler</strong><br>设置一张图片，是肯定崩溃的。当我们调用<strong>runOnUiThread</strong>方法，并且传入一个<strong>Runnable</strong>对象，并且在其中设置<strong>更新UI</strong>的逻辑，问题就解决了。相信你也和我一样对此非常好奇，那就赶紧点进去看看，源码中是如何实现的吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-215bb46aaa0df885?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runOnUiThread实现原理"></p>
<p>先来翻译一下这段注释：</p>
<blockquote>
<p>在UI线程中执行该Runnable.  <em> 如果当前线程是UI线程,那么该Runnable会立即执行.  </em> 如果当前的线程不是UI线程则调用UI线程handler的post()方法将其放入UI线程的消息队列中.  *<br>注意:勿在runOnUiThread(Runnable runnable)中做耗时操作</p>
</blockquote>
<p>首先我想说明的是，runOnUiThread方法是属于<strong>Activity</strong>的，也就是说我们能拿到Activity才能使用该方法。我们本文的这个例子，明显是执行了<strong>mHandler.post(action)</strong>方法。我们目前不去研究<strong>handler.post</strong>方法，因为一会你就知道为什么了。再来看看第二种解决问题的办法。</p>
</li>
<li><p><strong>view.post</strong> <img src="http://upload-images.jianshu.io/upload_images/1915184-80f462b718e89b2a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view.post方法使用"></p>
<p>代码跟上一个解决办法如出一辙，我们还是来看看源码，分析一下这个方法的实现方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-40b751ac6dcb8c73?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view.post源码"></p>
<p>先来翻译一下注释的意思：</p>
<blockquote>
<p>将Runnable对象添加到message queue中，并且这个runnable对象会跑在UI线程中。</p>
</blockquote>
<p>翻译完注释再来看代码，当View和Activity完成attach操作时，会产生一个<strong>attachInfo</strong>参数，在attachInfo参数中取出来了属于activity的mHandler，仍然去调用了mHandler.post(action)方法。也就是说无论我们是选择第一种方法还是第二种方法去解决这个崩溃问题，都是<strong>殊途同归</strong>的，最后经过层层封装，都走到了<strong>handler.post</strong>方法中。</p>
</li>
</ol>
<p><strong>handler.post</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-f35b59a4217f4ad7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送message到主线程"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e4f720124308ab1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler处理信息"></p>
<p>啊哈哈，我们连载通篇的主角<strong>Handler</strong>今天终于正式登场了，没错上面的代码就是将子线程的消息发送到主线程并处理的标准写法。等等，post方法在哪里？别着急，在本篇文章中，我并不打算给大家展开整个Handler知识体系的研究。我们先来看看post方法调用层级</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-2d101a24320abf9c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-2c64da2ca248d98a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageDelayed"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-5dc923d75bd384d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime"></p>
<p>可以看到，方法的调用顺序为post–sendMessageDelayed–sendMessageAtTime.</p>
<p>在本文中我们不再继续深究下去，未来我会对这些方法的调用层级、顺序、以及使用场景为大家进行一下完整地整理总结，本文不再赘述。</p>
<p><strong>想强调的是：</strong><br>其实在这篇博客的目的：<br>1.从解决问题并寻找方法的角度引出Handler，真正开启Handler的知识体系。</p>
<p>2.思考问题，解决问题的过程。回首第一篇文章中，我因为在子线程更新UI而造成了崩溃，然后：</p>
<ul>
<li><p>在寻找解决办法之前，带着强烈的好奇心，去寻找了为何不能在子线程更新UI原因。在这个过程中，我理解了什么<strong>线程安全</strong>，深入理解了<strong>Context</strong>。</p>
</li>
<li><p>去寻找解决问题的所有办法（三种），并且去探究了这几种方法的原理，试图选择在本例中的最优解（事实上这几种方法本质上没区别）。</p>
</li>
<li><p>将问题简单化，所有问题的解决办法都指向了Handler，所以我们只需要探究Handler即可。</p>
</li>
</ul>
<p><strong>写在最后：</strong></p>
<p>很多初学者认为Handler就是为了解决子线程更新UI的问题而存在的，事实上这种理解是<strong>错误</strong>的。Handler作为Android的线程间通信的机制，意义远不止此。下一篇中，Melo将带大家真正的理解Android的消息机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android消息机制字典型探究（二）&quot;&gt;&lt;a href=&quot;#Android消息机制字典型探究（二）&quot; class=&quot;headerlink&quot; title=&quot;Android消息机制字典型探究（二）&quot;&gt;&lt;/a&gt;Android消息机制字典型探究（二）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-8d34278385fceccd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/8c06b1d7ca68&quot;&gt;Android消息机制字典型探究（一）&lt;/a&gt;&lt;br&gt;为了完成整个&lt;strong&gt;Android消息机制的探究&lt;/strong&gt;，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中&lt;strong&gt;不允许子线程更新UI&lt;/strong&gt;的原因，是由于&lt;strong&gt;线程安全&lt;/strong&gt;的问题。&lt;br&gt;当然我们&lt;strong&gt;目前&lt;/strong&gt;分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：&lt;strong&gt;实践去发现问题，全面的理解问题，寻找最优解&lt;/strong&gt;。Android本身就是一个复杂而有机的整体，&lt;strong&gt;由一个知识点可以牵出一条知识线。从而构成相关的知识体系&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制字典型探究（一）</title>
    <link href="http://yoursite.com/2016/07/28/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AD%97%E5%85%B8%E5%9E%8B%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Android消息机制字典型探究（一）/</id>
    <published>2016-07-28T02:12:46.236Z</published>
    <updated>2016-07-28T02:13:51.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android消息机制字典型探究（一）"><a href="#Android消息机制字典型探究（一）" class="headerlink" title="Android消息机制字典型探究（一）"></a>Android消息机制字典型探究（一）</h1><h2 id="子线程为啥不能更新UI？"><a href="#子线程为啥不能更新UI？" class="headerlink" title="子线程为啥不能更新UI？"></a>子线程为啥不能更新UI？</h2><p><img src="http://upload-images.jianshu.io/upload_images/1915184-96038570640d0e76?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br>看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了<strong>Handler</strong>这个单词，关于这个知识点，几乎是<strong>面试必问的问题，重要程度不言而喻</strong>。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚<strong>Android的消息机制</strong>。<br><a id="more"></a><br>既然没有了篇幅限制，自然可以全面的去讲一讲有关Handler的一切，我先来说说当时是怎么接触到<strong>Handler</strong>这个类的。</p>
<p>在我自学Android过程中，写了一个<strong>访问网络请求图片并显示</strong>的Demo，在子线程中我直接给<strong>ImageView</strong>设置了图片，造成了崩溃。崩溃信息如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b562b658369b0d8c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃信息"></p>
<blockquote>
<p>Only the original thread that created a view hierarchy can touch its views.</p>
</blockquote>
<p>这个错误信息在字面上翻译过来就是：<strong>只有创建视图层级的原始线程，有权利处理它的视图</strong>。说白了，就是我们经常说的“子线程不能更新UI”。这句话体现了主线程在处理视图上具有唯一权力，<strong>这也就是为什么主线程也可以称为UI线程</strong>。</p>
<p>在解决这个崩溃问题之前，我对<strong>Android中子线程不能更新UI</strong>产生了非常大的好奇心。</p>
<p><strong>Google</strong>如此设计的原因是什么呢？</p>
<ol>
<li>表象<br>我们先从表象上分析一下，假设可以在子线程更新UI，会产生那些后果呢？<br>如果不同的线程控制同一块UI，因为时间的延时性，网络的延迟性，很有可能界面图像会乱套，会花掉。而且出了问题也非常不容易排查问题出在了哪里。从硬件上考虑，每个手机只有一个显示芯片，根本上不可能同时处理多个绘制请求)，减少更新线程数，其实是提高了更新效率。</li>
<li>本质<br>如果可以并发的更新UI，事实上是 “is not thread safe”的，也就是线程不安全。我们都知道，线程安全问题其实就是，不同的线程对同一块资源的调用。在更新UI的同时，会涉及context资源的调用，所以产生了线程安全问题。</li>
</ol>
<p><strong>相关阅读：</strong></p>
<p><a href="http://www.jianshu.com/p/46c35c5079b4" target="_blank" rel="external">你足够了解Context吗？</a></p>
<p>所以在Android中是不允许在子线程更新UI的、</p>
<p>本文开了一个小头，在下一篇中，将讨论如何解决本文中的崩溃问题。<strong>卖个关子，一共有三种方式哦，敬请期待~</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android消息机制字典型探究（一）&quot;&gt;&lt;a href=&quot;#Android消息机制字典型探究（一）&quot; class=&quot;headerlink&quot; title=&quot;Android消息机制字典型探究（一）&quot;&gt;&lt;/a&gt;Android消息机制字典型探究（一）&lt;/h1&gt;&lt;h2 id=&quot;子线程为啥不能更新UI？&quot;&gt;&lt;a href=&quot;#子线程为啥不能更新UI？&quot; class=&quot;headerlink&quot; title=&quot;子线程为啥不能更新UI？&quot;&gt;&lt;/a&gt;子线程为啥不能更新UI？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-96038570640d0e76?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了&lt;strong&gt;Handler&lt;/strong&gt;这个单词，关于这个知识点，几乎是&lt;strong&gt;面试必问的问题，重要程度不言而喻&lt;/strong&gt;。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚&lt;strong&gt;Android的消息机制&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
      <category term="思路" scheme="http://yoursite.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Android中Fragment数据保存和恢复</title>
    <link href="http://yoursite.com/2016/07/27/Android%E4%B8%ADFragment%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2016/07/27/Android中Fragment数据保存和恢复/</id>
    <published>2016-07-27T14:13:44.702Z</published>
    <updated>2016-07-27T14:14:48.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中Fragment数据保存和恢复"><a href="#Android中Fragment数据保存和恢复" class="headerlink" title="Android中Fragment数据保存和恢复"></a>Android中Fragment数据保存和恢复</h1><p><strong>写在前面：</strong><br>上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：<br><a href="http://www.jianshu.com/p/6622434511f7" target="_blank" rel="external">Android中Activity数据的保存和恢复</a><br><a id="more"></a><br><strong>一句话总结：</strong></p>
<ul>
<li><p>临时数据<br>对于<strong>临时数据</strong>，我们使用<strong>onSaveInstanceState</strong>方法进行保存，并且在<strong>onCreate</strong>方法中恢复。</p>
</li>
<li><p>永久数据<br>对于<strong>持久性数据</strong>，我们要在onPause方法中进行存储，但是要注意，onPause方法中不能进行大量操作，会影响其他Activity进入任务栈栈顶。</p>
</li>
</ul>
<p>ps：在Activity中弹出一个当前Activity的<strong>Dialog</strong>并不会有任何生命周期方法调用（以前我曾以为会调用onPause方法）。因为Dialog作为一个View本身就是属于当前Activity的，Activity并没有<strong>失去焦点</strong>。</p>
<p>ok，完成了回顾，下面来开始本篇博客：</p>
<p><strong>Fragment</strong>在我们的项目中真的太实用和常见了，它的使用频率和数量甚至超过了Activity，所以本文目的是探究Fragment的数据保存和恢复。</p>
<p>在开始讲解之前，你应该对Fragment的<strong>生命周期方法</strong>有一定了解，推荐给大家一篇博客，我认为不错：</p>
<p><a href="http://blog.csdn.net/wanghao200906/article/details/45561385" target="_blank" rel="external">Fragment生命周期方法详解</a></p>
<p>准备工作做了这么多，下面我们正式开始吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-84f1eaec23de028d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试App截图"></p>
<p>本文直接选用了《第一行代码》中Fragment模块的讲解例子，点击下面的按钮<strong>分别跳转</strong>这四个Fragment。为了方便观察，我重写了Fragment所有<strong>生命周期方法</strong>和<strong>onSaveInstanceState</strong>方法，并打印了Log。</p>
<p>我们目的是探究Fragment数据的保存和恢复，在这里我把它分为两大类的情况：</p>
<ol>
<li><p>单个Fragment遭遇一些突发情况</p>
</li>
<li><p>Fragment之间相互的切换或覆盖</p>
</li>
</ol>
<p>在此之前，先引入一个<strong>返回栈</strong>的概念。<br>我想你应该知道返回栈是什么，并且你以前接触的应该是保存Activity的返回栈，类比Activity，Fragment返回栈其实是保存Fragment的栈结构。区别在于：<strong>Fragment的返回栈由Activity管理；而Activity的返回栈由系统管理。</strong></p>
<p>在未修改之前，本文添加并切换Fragment的方式都是在返回栈中<strong>仅有一个</strong> fragment：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-183cacefa4387d8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加切换fragment"></p>
<p>不要心急，过一会再说怎么去在返回栈中压入多个fragment，我们先来处理<strong>只有一个</strong>的情况</p>
<ol>
<li><p>单个Fragment遭遇突发情况</p>
<p>仍然是用以下<strong>突发情况</strong>进行测试：</p>
<ul>
<li><p>点击back键</p>
</li>
<li><p>点击锁屏键</p>
</li>
<li><p>点击home键</p>
</li>
<li><p>其他APP进入前台</p>
</li>
<li><p>启动了另一个Activity</p>
</li>
<li><p>屏幕方向旋转</p>
</li>
<li><p>APP被Kill</p>
</li>
</ul>
<p>不过与上篇博客不同的是，我们在清单文件中，给Activity做了如下配置：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-99af7b0a6ca0f2e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置configChange"></p>
<p>这么做的目的是当屏幕方向发生改变的时候，fragment所依附的Activity并不会重新销毁再创建，让<strong>情况相对简单一点</strong>。</p>
<p><strong>测试结果：</strong></p>
<p>当一个fragment孤零零地呆在返回栈时，它所处的情况与Activity如出一辙。类比Activity对数据的保存和恢复，我们可以对此得出结论：</p>
<ul>
<li><p>临时数据 对于<strong>临时数据</strong>，我们使用<strong>onSaveInstanceState</strong>方法进行保存，并且在<strong>onCreateView</strong>方法中恢复（请注意是onCreateView）。</p>
</li>
<li><p>永久数据 对于<strong>持久性数据</strong>，我们要在onPause方法中进行存储。</p>
</li>
</ul>
</li>
<li>Fragment之间的相互切换或覆盖<br>当返回栈中保证<strong>只有一个Fragment</strong>，相互切换时，生命周期方法的调用是怎样的呢？例如本例中，从fragment03切换到fragment04：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-6d89724ceff62e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fragment03切换fragment04"><br>　　可以看到，上述的这种情况，两个fragment从创建到销毁，经历了所有的生命周期方法。<br>　　如果返回栈中fragment的数量为多个呢？首先在切换时，加上以下代码，保证将fragment放入返回栈中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d8961dd8db6cf972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="addToBackStack"><br>　　使用addToBackStack方法，就能将fragment放入相应的返回栈中去了，从表象上来看区别在于进入其他fragment时，点击back键时，可以返回上一个fragment。这时候切换时，生命周期方法就是如何调用的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d0fdbf4ea4c1e944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回栈有多个fragment切换"></p>
<p>　　对比这两张生命周期方法的图，能得出两个结论。<br>　　1.无论任务栈中fragment数量为多少，onSaveInstanceState方法都没有调用<br>　　2.当fragment任务栈中有多个fragment时，进入下一个fragment时，并不会销毁<strong>fragment实例</strong>，而是仅仅<strong>销毁视图</strong>，最终调用的方法为onDestoryView。<br>　　所以此时我们要去保存临时数据，并不能仅保存在onSaveInstanceState中（因为它可能不会调用），还应该在onDestoryView方法中进行保存临时数据的操作，源码如下：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-dbd03c5a2f1419ea?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码截图"></p>
<p>因为没有了系统提供的bundle参数，我们选择把数据保存在Arguments中，代码就不带着大家一步一步的看了，因为逻辑并不复杂，挺好理解的。通过这种方式，我们就挺容易的将<strong>临时数据和fragment的一些状态</strong>保存进bundle中并在需要时恢复了。</p>
<p>不知不觉本篇文章就要结束了，感兴趣的可以尝试当调用<strong>ft.add()</strong>方式去添加fragment时，生命周期方法又是怎样调用的呢？</p>
<p><strong>结束之前我们来一句话总结下本文：</strong><br>Fragment对<strong>临时数据</strong>的保存，仅仅依靠<strong>onSaveInstanceState</strong>方法是不行的，还需要在<strong>onDestoryView</strong>中进行相应操作，具体参考上面的代码。</p>
<p>Fragment中对于一些持久性的数据，仍应在<strong>onPause</strong>中保存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中Fragment数据保存和恢复&quot;&gt;&lt;a href=&quot;#Android中Fragment数据保存和恢复&quot; class=&quot;headerlink&quot; title=&quot;Android中Fragment数据保存和恢复&quot;&gt;&lt;/a&gt;Android中Fragment数据保存和恢复&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/6622434511f7&quot;&gt;Android中Activity数据的保存和恢复&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>5分钟打造Android一键退出功能</title>
    <link href="http://yoursite.com/2016/07/27/5%E5%88%86%E9%92%9F%E6%89%93%E9%80%A0Android%E4%B8%80%E9%94%AE%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/27/5分钟打造Android一键退出功能/</id>
    <published>2016-07-27T14:11:36.057Z</published>
    <updated>2016-07-27T14:12:25.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5分钟打造Android一键退出功能"><a href="#5分钟打造Android一键退出功能" class="headerlink" title="5分钟打造Android一键退出功能"></a>5分钟打造Android一键退出功能</h1><p><strong>写在前面：</strong><br>当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个<strong>一键退出功能</strong>。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个<strong>BaseActivity</strong>管理所有启动的<strong>Activity</strong>。<br><a id="more"></a><br><strong>下面给出完整的BaseActivity代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedList;</div><div class="line">import java.util.List;</div><div class="line">import android.app.Activity;</div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">public abstract class BaseActivity extends Activity &#123;</div><div class="line">	// 管理运行的所有的activity</div><div class="line">	public final static List&lt;BaseActivity&gt; mActivities = new LinkedList&lt;BaseActivity&gt;();</div><div class="line">	public static BaseActivity activity;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			mActivities.add(this);</div><div class="line">		&#125;</div><div class="line">		init();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init() &#123;</div><div class="line">		initViews();</div><div class="line">		initData();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 初始化Views</div><div class="line">	 */</div><div class="line">	public abstract void initViews();</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 初始化数据</div><div class="line">	 */</div><div class="line">	public void initData() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onResume() &#123;</div><div class="line">		super.onResume();</div><div class="line">		activity = this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onPause() &#123;</div><div class="line">		super.onPause();</div><div class="line">		activity = null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onDestroy() &#123;</div><div class="line">		super.onDestroy();</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			mActivities.remove(this);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 一键退出的方法</div><div class="line">	 */</div><div class="line">	public void killAll() &#123;</div><div class="line">		// 复制了一份mActivities 集合</div><div class="line">		List&lt;BaseActivity&gt; copy;</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			copy = new LinkedList&lt;BaseActivity&gt;(mActivities);</div><div class="line">		&#125;</div><div class="line">		for (BaseActivity activity : copy) &#123;</div><div class="line">			activity.finish();</div><div class="line">		&#125;</div><div class="line">		// 杀死当前的进程</div><div class="line">		android.os.Process.killProcess(android.os.Process.myPid());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码分析：</strong><br>在项目中的所有的Activity，都<strong>继承于BaseActivity</strong>，在onCreate方法中，将这个Activity <strong>add</strong>进<strong>LinkedList</strong>中（这里选择用LinkedList是因为它增删快，适合于这个场景中），在onDestory方法中将这个Activity <strong>remove</strong>掉，这样就保证每一个启动了的Activity都存于集合LinkedList中。</p>
<p>然后我们写一个killAll方法，复制这个集合并且遍历退出，你可以在任何地方调用这个方法，这样我们的一键退出功能就完美实现了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5分钟打造Android一键退出功能&quot;&gt;&lt;a href=&quot;#5分钟打造Android一键退出功能&quot; class=&quot;headerlink&quot; title=&quot;5分钟打造Android一键退出功能&quot;&gt;&lt;/a&gt;5分钟打造Android一键退出功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个&lt;strong&gt;一键退出功能&lt;/strong&gt;。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个&lt;strong&gt;BaseActivity&lt;/strong&gt;管理所有启动的&lt;strong&gt;Activity&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="退出" scheme="http://yoursite.com/tags/%E9%80%80%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android中突发情况Activity数据的保存和恢复</title>
    <link href="http://yoursite.com/2016/07/27/Android%E4%B8%AD%E7%AA%81%E5%8F%91%E6%83%85%E5%86%B5Activity%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2016/07/27/Android中突发情况Activity数据的保存和恢复/</id>
    <published>2016-07-27T14:10:07.840Z</published>
    <updated>2016-07-27T14:11:04.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中突发情况Activity数据的保存和恢复"><a href="#Android中突发情况Activity数据的保存和恢复" class="headerlink" title="Android中突发情况Activity数据的保存和恢复"></a>Android中突发情况Activity数据的保存和恢复</h1><p><strong>写在前面：</strong><br>在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。<br><a id="more"></a></p>
<h2 id="突发情况都有哪些？"><a href="#突发情况都有哪些？" class="headerlink" title="突发情况都有哪些？"></a>突发情况都有哪些？</h2><p>因为本文讨论的是当一些突发情况的出现时，对数据的保存和恢复。所以现在总结一下<strong>突发情况</strong>应该都有哪些？</p>
<ul>
<li><p>点击back键</p>
</li>
<li><p>点击锁屏键</p>
</li>
<li><p>点击home键</p>
</li>
<li><p>其他APP进入前台</p>
</li>
<li><p>启动了另一个Activity</p>
</li>
<li><p>屏幕方向旋转</p>
</li>
<li><p>APP被Kill</p>
</li>
</ul>
<p>当这些<strong>突发情况</strong>发生的时候，有哪些关键的方法会被调用呢？</p>
<p>写了一个简单的demo，我用上述的突发情况进行测试，代码中我重写了<strong>所有Activity的生命周期方法</strong>和<strong>onSaveInstanceState方法</strong>，并打印对应的log在控制台，下面是demo图：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-35ac3a175abba667?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo图"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-f544616ba3090b78?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部分代码示例"></p>
<p>这里就不贴出测试的过程了，直接来告诉大家<strong>测试的结果</strong>吧：</p>
<p>当我的APP处在前台，能与用户交互的情况下，出现上述的<strong>突发事件</strong>时，只有点击<strong>back键</strong>，<strong>onSaveInstanceState</strong>方法不会调用。其余的情况下， 该方法一律都会调用，这又是为什么呢？并且<strong>onPause</strong>方法是必然会调用的，这又给我们保存数据提供了怎样的思路呢？</p>
<h2 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h2><p>好吧，相信当你看到本文标题的时候，你就应该想到了这个方法。因为当我们学习Android基础知识时，用onSaveInstanceState方法进行数据恢复是你必然学到过的。所以前面我营造出的一些悬念看似是失败了，不过对于onSaveInstanceState你理应知道更多知识：</p>
<ol>
<li><strong>何时调用：</strong></li>
</ol>
<pre><code>&gt; Android calls onSaveInstanceState() before the activity becomes vulnerable to being destroyed by the system, but does not bother
calling it when the instance is actually being destroyed by a user
action (such as pressing the BACK key)
</code></pre><p>找到了以上一段话，翻译过来就是当某个activity变得“<strong>容易</strong>”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户<strong>主动销毁</strong>的，例如当用户按BACK键的时候。</p>
<pre><code>结合我们以上的例子，其实都在说明一个词，就是**被动**。当Activity并不是由我主动点击back键而丧失焦点时，onSaveInstanceState方法就一定会调用。就例如我上述列举的那些除了点击back键的“**突发情况**”。
</code></pre><ol>
<li><p><strong>何地调用：</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-81e0043a524fd228?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="何地调用"></p>
<p>在我写的这个demo中，<strong>onSaveInstanceState</strong>的调用是处于<strong>onPause</strong>和<strong>onStop</strong>之间的，（下面关于Activity的生命周期方法，会讲解一些值得大家注意的），我查阅了一下资料，能保证的是onSaveInstanceState方法会在onStop之前调用，但是是否在onPause之前就不一定了。</p>
</li>
</ol>
<p><strong>结论：</strong> google工程师们对onSaveInstanceState如此设计就是让其完成对一些<strong>临时的、非永久数据</strong>存储并进行恢复。什么样的数据属于临时数据呢？举个例子，比如EditText中输入的内容，CheckBox是否勾选，ScrollView的滑动位置，目前视频的播放位置等等。</p>
<p>当我还没有自学Android时，玩着一些APP就会产生一个疑问，比如我在一个输入框中输入了大量文字没有提交或者保存。此时来了一个电话，如果退回的时候，输入框里面的文字消失了，那我可能会砸了电话，所以这个保存数据的操作，是Android开发者做的吗？</p>
<p>然而是不需要的，因为Android的View本身自己就实现了onSaveInstanceState方法，这些控件自己就具有保存临时数据和恢复临时数据的能力。</p>
<p>例如<strong>TextView</strong>中的部分源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8f86d2b28227cc2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TextView中的实现"></p>
<p>其他View控件都有相似的实现原理。值得一提的是，只有当你给这个wiget在xml中指定<strong>id</strong>时，它才具有保存数据并且恢复的能力，并且不同的wiget还不能共用这个id，否则会出现<strong>数据覆盖</strong>的情况。具体的源码有兴趣大家可以自己去看，这里因为篇幅的原因不再贴出，关于onSaveInstanceState我们先说这些，赶紧看看使用姿势。</p>
<h2 id="onSaveInstanceState的使用姿势"><a href="#onSaveInstanceState的使用姿势" class="headerlink" title="onSaveInstanceState的使用姿势"></a>onSaveInstanceState的使用姿势</h2><p>比如我们要保存当前视频的<strong>播放进度</strong>，这个显然控件没有帮我们实现onSaveInstanceState，所以就只能靠自己了，代码如下所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-65b77385f772bee6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="保存临时数据"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-3858067a294ecc4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="恢复临时数据"></p>
<p>当在onCreate取出临时数据时，记得加一个<strong>非空判断</strong>。</p>
<p>看到这里，也许你认为本文该就此结束了，不过在回过头看看，我们刚才一直强调的是<strong>临时数据</strong>，毕竟onSaveInstanceState本身就是为临时数据服务的，但是一些<strong>永久性质</strong>的数据，比如<strong>插入数据库的操作</strong>，我们应该在什么方法中对其进行保存呢？</p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h2><p>在介绍onPause方法之前，还是想聊聊Activity的生命周期方法，相信大家对它应该有了初步的了解，不过在相应的生命周期方法中，我们应该做什么操作呢？推荐给大家一篇文章，我觉得不错。</p>
<p><a href="http://blog.csdn.net/lonelyroamer/article/details/8927940" target="_blank" rel="external">Activity生命周期详解</a></p>
<p>关于onPause，我找到了一下关于它的特性：</p>
<blockquote>
<p>onPause(), onStop(), onDestroy() are “killable after” lifecycle methods. This indicates whether or not the system can kill the process hosting the activity at any time after the method returns, without executing another line of the activity’s code. Because onPause() is the first of the three, once the activity is created, onPause() is the last method that’s guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience.</p>
</blockquote>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得<strong>onPause是持久化相关数据的最后的可靠时机</strong>。当然onPause方法不能做大量的操作，这会影响下一个Activity入栈。</p>
<p>刚才我们的测试结果还说明了一个道理，onSaveInstanceState并不是<strong>百分百</strong>调用的（比如点击了back键），显然一些永久性的数据，我们并不能在此中保存。</p>
<p><strong>关于本文的结论就显而易见了，我们来一句话总结一下：</strong></p>
<p><strong>临时数据使用onSaveInstanceState保存恢复，永久性数据使用onPause方法保存。</strong></p>
<p>下一篇准备给大家总结一下<strong>Fragment</strong>的数据保存和恢复，敬请期待哈~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中突发情况Activity数据的保存和恢复&quot;&gt;&lt;a href=&quot;#Android中突发情况Activity数据的保存和恢复&quot; class=&quot;headerlink&quot; title=&quot;Android中突发情况Activity数据的保存和恢复&quot;&gt;&lt;/a&gt;Android中突发情况Activity数据的保存和恢复&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>程序员必备简捷开发辅助工具总结</title>
    <link href="http://yoursite.com/2016/07/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%AE%80%E6%8D%B7%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/27/程序员必备简捷开发辅助工具总结/</id>
    <published>2016-07-27T14:08:45.130Z</published>
    <updated>2016-07-27T14:09:43.507Z</updated>
    
    <content type="html"><![CDATA[<p>程序员必备简捷开发辅助工具总结<br>写在前面：<br>工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！<br><a id="more"></a><br>零：Notepad++<br>Notepad++ 程序员必备的文本编辑器，软件小巧高效，支持27种编程语言，通吃C,C++ ,Java ,C#, XML, HTML, PHP,JS 等，推荐各位下载使用。Notepad++ 可完美地取代微软的记事本。相信这是每个程序员必备的工具，神器不解释！</p>
<p>Notepad++<br>下载地址及使用说明：</p>
<p>Notepad++中文版下载</p>
<p>一：XML Marker(xml查看编辑工具)<br>XML Marker是国外的一款非常实用的xml查看编辑工具。软件功能强大，纯文本调试输出和日志文件，你可以有效增加修改你的程序才能产生XML格式他们的作用。你也可以使用XML标记的图形功能，以现场隐藏的趋势，并更快地解决你的错误。更多的功能包括表格排序，语法高亮编辑器和自动缩进，经常编辑XML文件的用户可以下载本软件使用。</p>
<p>XML Marker<br>下载地址及使用说明：</p>
<p>XML Marker(xml查看编辑工具) 下载</p>
<p>二：Everything<br>Everything是速度最快的文件搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具、Total Commander的搜索、Google 桌面搜索或百度硬盘搜索，如果正在使用或放弃了Locate32，都值得推荐这款体积小巧、免安装、免费、速度极快（比Locate32更快）的文件搜索工具Everything！</p>
<p>Everything<br>下载地址及使用说明：</p>
<p>Everything下载地址</p>
<p>三：MarkMan<br>既有爱又给力的长度标注神器！设计师、重构、前端工程师必备。马克鳗是基于AdobeAIR平台的方便高效的标注工具，可方便地为设计稿添加标记，极大节省设计师在设计稿上添加和修改标注的时间。马克鳗使用起来也是非常简单，双击添加测量，单击改变横纵方向等等功能，基本都是一键完成。</p>
<p>markman<br>下载地址及使用说明：</p>
<p>MarkMan下载地址</p>
<p>四：HiJson<br>使用HiJson工具并通过此工具快速查看JSON字符串、熟悉JSON的数据结构。针对程序员来说，如果了解了连续字符串对应的JSON的数据组成，便可以快速对JSON字符串进行数据处理。</p>
<p>Hijson<br>下载地址及使用说明：</p>
<p>HiJson64位下载地址</p>
<p>五：XMind<br>Xmind是一款全球领先的思维导图软件，除了可以轻松绘制基本逻辑图之外，还支持组织如结构图（竖直）、树状图（水平+竖直）、思维导图（辐射）、鱼骨图、二维图（表格）模型。在企业和教育领域都有很广泛的应用。Xmind Pro可以将您的图形显示给他人，或者将图形内容导出到MicrosoftPowerpoint、Word中，令复杂的思想和信息得到更快的交流。在企业中它可以用来进行会议管理、项目管理、信息管理、计划和时间管理、企业决策分析等，在教育领域，它通常被用于教师备课、课程规划、头脑风暴等。</p>
<p>Xmind<br>下载地址及使用说明：</p>
<p>XMind破解版下载</p>
<p>六：Beyond Compare<br>Beyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。在使用git提交代码时，可以比较两个文件的不同之处，处理冲突，非常实用。</p>
<p>Beyond Compare<br>下载地址及使用说明：</p>
<p>Beyond Compare</p>
<p>七：金山词霸<br>这个就不多解释了，类、变量的命名尽量不要使用拼音，遇到拿不准的单词，就使用金山词霸查询一下吧。</p>
<p>写在后面：</p>
<p>如果大家还有什么还用的辅助开发工具，请在下方留言哈，不断地补充分享~</p>
<p>评论朋友们的补充（感谢）</p>
<p>八：Sublime Text<br>程序员必备代码编辑器，几乎每位程序员提到Sublime Text都是赞不绝口!它体积小巧，无需安装，绿色便携;它可跨平台支持Windows/Mac/Linux;支持32与64位操作系统，它在支持语法高亮、代码补全、代码片段(Snippet)、代码折叠、行号显示、自定义皮肤、配色方案等所有其它代码编辑器所拥有的功能的同时，又保证了其飞快的速度!还有着自身独特的功能，比如代码地图、多种界面布局以及全屏免打扰模式等，这些优秀特性让Sublime Text 2成了所有程序员眼中的神!</p>
<p>Sublime Text<br>下载地址及使用说明：</p>
<p>Sublime text下载链接和使用教程</p>
<p>九：Listary<br>Listary 是一款非常优秀的 Windows 文件浏览和搜索增强工具，可以为你 Windows 的「文件浏览对话框」、「资源管理器」等增加非常方便的文件快速定位、实时全盘搜索、常用文件夹收藏、打开历史、快速切换到已打开的路径、快捷右键菜单等一系列非常非常实用和高效的功能。</p>
<p>Listary<br>下载地址及使用说明：</p>
<p>Listary</p>
<p>十：strokeplus<br>strokesplus是一个类似strokeit的鼠标手势软件。无须.net运行环境即可运行，只占用250-500kb内存。strokesplus支持脚本动作，提供了更为强大的可操控性。</p>
<p>下载地址及使用说明：</p>
<p>strokeplus<br>StrokesPlus下载</p>
<p>十一：source insight<br>Source Insight 实质上是一个支持多种开发语言（java,c ,c++等等）的编辑器，只不过由于其查找、定位、彩色显示等功能的强大，而被我们当成源代码阅读工具使用 。所以，为了有效的阅读源程序，首先必须选择功能菜单上的“Project”选项的子菜单“New Project” 新建一个项目，项目名称可以自由选定，当然也可以选择删除（Remove）一个项目。当删除一个项目的时候，并不删除原有的源代码文件,只是将该软件生成的那些工程辅助文件删除。设定之后，将会弹出一个对话框如图2，接受默认选择，如果，硬盘空间足够，可以将第一个复选框选上，该选项将会需要与源代码大致同等的空间来建立一个本地数据库以加快查找的速度。</p>
<p>source insight<br>Source Insight下载地址和使用说明</p>
<p>相关阅读：</p>
<p>Android开发者需要阅读的博客总结</p>
<p>移动开发必备书单</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序员必备简捷开发辅助工具总结&lt;br&gt;写在前面：&lt;br&gt;工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>3分钟教会你如何看eclipse中的崩溃信息</title>
    <link href="http://yoursite.com/2016/07/27/3%E5%88%86%E9%92%9F%E6%95%99%E4%BC%9A%E4%BD%A0%E5%A6%82%E4%BD%95%E7%9C%8Beclipse%E4%B8%AD%E7%9A%84%E5%B4%A9%E6%BA%83%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2016/07/27/3分钟教会你如何看eclipse中的崩溃信息/</id>
    <published>2016-07-27T14:07:01.801Z</published>
    <updated>2016-07-27T14:07:47.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3分钟教会你如何看eclipse中的崩溃信息"><a href="#3分钟教会你如何看eclipse中的崩溃信息" class="headerlink" title="3分钟教会你如何看eclipse中的崩溃信息"></a>3分钟教会你如何看eclipse中的崩溃信息</h1><blockquote>
<p>本文原创，转载请注明出处，坚持长期原创博客，喜欢请加关注哦，你们支持就是我动力的源泉~</p>
</blockquote>
<a id="more"></a>
<p><strong>写在前面：</strong></p>
<p>前一阵花了足足一周的时间去研究了Context的源码，发布出来一篇文章，我觉得写得已经OK了却反响平平。前天写了一个解析json的教程却得到很多朋友门点赞认可。说明还有相当一部分刚刚入行的朋友们希望得到一些相对初级的知识和技巧，话不多说，<strong>我来一点点的教大家看崩溃Log。</strong></p>
<blockquote>
<p>以后准备每周出一篇入门、一篇进阶博客~</p>
</blockquote>
<p>我相信很多初学者用的开发工具是Eclipse，并且很多初级书籍也不会教大家怎么去看崩溃日志，虽然不难，但是靠自己琢磨还是挺浪费时间的，我们就写一个Demo来看看吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-1b61f232e90373a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注释掉一行代码，让程序崩溃"></p>
<p><strong>注释掉创建ViewHolder对象的代码，让程序崩溃。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-3bcff3ce97214b64?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MainActivity中展示一个ListView"></p>
<p>这个Demo很简单，就是在MainActivity中展示一个ListView，《第一行代码》中的例子。<br>现在我们注释掉了创建ViewHolder对象的代码，连上手机，运行程序，看看崩溃信息吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ad7db11573d197f7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃信息"></p>
<p>看图片中黑色的箭头，左边的箭头指向自己的<strong>包名过滤器</strong>，表示只显示我这个应用的logcat，右边箭头把信息的等级过滤为<strong>error</strong>级别。</p>
<p>这时候我们进一步去<strong>缩小</strong>范围：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-1d014a2b4b6f139c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="黑框中的信息"></p>
<p>其实黑框中的信息就是我们最主要关心的，但是为什么要这两个地方的信息呢？</p>
<ul>
<li>java.lang.xxxException，这个标明你的错误类型，如果没见过，用搜索工具搜一下，就能明白，在我们这个例子里是空指针异常。</li>
</ul>
<ul>
<li>第二个黑框是我们<strong>自己应用</strong>的包名（第31行出了问题），说明这个错误就是我们自己的代码导致的，双击可以进入java代码中，后面那些android.widget开头的崩溃信息是一些牵连信息，也是可以提供参考的。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-be4177455837afaf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双击进入31行"></p>
<p>这行报了空指针异常，分析一下，说明我们的<strong>ViewHolder</strong>没有创建对象。</p>
<p><strong>写在后面：</strong></p>
<p>其实本文例子中的错误并不复杂，看错误日志也是一个经验活。遇到崩溃要理清头绪，寻找错误位置，分析可能造成的原因，看得多了，也就慢慢会看了。</p>
<blockquote>
<p>喜欢请加关注，最近应该会出产很多文章~</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3分钟教会你如何看eclipse中的崩溃信息&quot;&gt;&lt;a href=&quot;#3分钟教会你如何看eclipse中的崩溃信息&quot; class=&quot;headerlink&quot; title=&quot;3分钟教会你如何看eclipse中的崩溃信息&quot;&gt;&lt;/a&gt;3分钟教会你如何看eclipse中的崩溃信息&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文原创，转载请注明出处，坚持长期原创博客，喜欢请加关注哦，你们支持就是我动力的源泉~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="eclipse" scheme="http://yoursite.com/tags/eclipse/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>别让培训机构毁了你这一辈子</title>
    <link href="http://yoursite.com/2016/07/27/%E5%88%AB%E8%AE%A9%E5%9F%B9%E8%AE%AD%E6%9C%BA%E6%9E%84%E6%AF%81%E4%BA%86%E4%BD%A0%E8%BF%99%E4%B8%80%E8%BE%88%E5%AD%90/"/>
    <id>http://yoursite.com/2016/07/27/别让培训机构毁了你这一辈子/</id>
    <published>2016-07-27T14:03:58.812Z</published>
    <updated>2016-07-27T14:05:14.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文转载，个人感觉观点有些偏激，不过有些思路绝对是对我有启发的。作为一个零基础自学一路走来的程序员，等有机会写写自己自学的经历吧。</p>
</blockquote>
<a id="more"></a>
<p><strong>—-写给计算机专业的同学</strong></p>
<p>　　我在北京摸爬滚打这么多年，也算是IT界的老人了，最近，经常有老家的同学打来电话。有位同学说他侄子高中快毕业了，成绩不太理想，只能考上一所三流大学。他听说北京有很多IT培训机构，而且孩子对电脑这方面比较感兴趣，而且他听说培训出来的学生在北京挣钱也不少。<br>现在大学生找不到工作，所以想让孩子去培训机构学一门技术，早点挣钱。我回答他:如果你侄子是我侄子，那么我会坚决要让他考大学，上培训机构的话，孩子这一辈子就完了。另一位同学说他妹妹学计算机的，大学本科毕业，找不到工作，她们学校很多大专生去北京培训了4个月，找到了工作，而且工资还不低，所以他妹妹也想去培训机构，问我能不能给介绍一家好的。<br>　　我回答她：你家里条件不错的话，就让孩子继续学习，考个研究生。研究生毕业后会比较容易找工作。如果让你妹妹去培训机构，那么这大学4年就白读了，而且可能会毁了孩子。良药苦口忠言逆耳，我作为一个认真负责的人只能这么回答他们，我不想看到一个个活泼可爱，有理想，有追求，有感情的青少年被培训机构摧残，变成一只只痴呆、愚钝的人肉代码生成器，也就是我们所说的代码民工。因为我经历的、见过的太多了。<br>我经历过2000年前后的网络泡沫，2009年的经济危机。2009年的时候北京的软件公司很少招人，甚至有些公司裁人，这对09届大学毕业生来说简直是刚迈入社会遭到的当头一棒。当时我所在的公司在面试的时候，只挑底子特别好，计算机基础理论掌握特别牢的新人，就是这么残酷。可能就是这种就业形势带动了IT培训业的发展。<br>　　就是那一年，各个机构的培训广告，各种培训的视频铺天盖地而来。我表弟也是学计算机的，正是09年毕业，很不幸赶上了经济危机，家里不富裕，也没有钱供他继续考研，一直没工作，压力也不小，问我能不能帮忙找个工作，工资低点也行，先干着。我和表弟一致保持着联系，所以我对他是比较了解的，大学基本上没怎么学，打了4年的魔兽，考试靠作弊，最终混到了文凭。有很多大学生大学玩了4年，上网，玩游戏，喝酒，泡妞。学编程不求甚解，不求精，毕业找不到工作，抱怨社会不给大学生机会，抱怨中国教育的落后，抱怨大学知识体系与实践脱轨。老是怨这怨那，把责任推给社会。我觉着大学整天玩，不努力，到最后找不到工作是应该的！找到工作才叫不正常！我家里的意思是让我救济一下亲戚，于是我就想办法，想办法帮表弟“挽回败局”，我心里深知，很多知识的获得是要经过努力，经过刻苦地钻研，有时候遇到问题解决不了，需要熬通宵硬啃，这是很孤独的过程，是没有捷径的，因为我的大学就是这么过来的，我身边的高手也都是这么过来的。现在表弟需要的是一剂“速效药”，能在短时间内“补上”之前欠缺的，快速找到工作。<br>　　后来我在 csdn上看到一则广告，看了看他们的课堂录像视频，感觉虽然水平不是很高，但是还凑合，比有些纯粹糊弄人的培训机构要强。我抱着侥幸心理报了名。我帮表弟交了8000元送他去了这个培训班。现在回想一下，那真是个错误的决定，让我后悔不已。当时，培训机构是新生事物，大家都不懂，后来我慢慢地看清了它的真实面目。这个培训班一共4个月的课程，实际上只有3.5个月，教授的内容也很基础。一个月讲基础，一个月讲框架，剩下时间讲项目。吹嘘他们的老师都是一些年薪百万的大师级别的人物，实际上只不过是一些过早“退役”的普通程序员，被他们吹大的。过了30岁混不下去的程序员(工程师)大有人在，有些人过不下去了，为了混口饭吃就去了培训机构当老师。简单的课程体系，当初被包装成何等华丽，充满各种专业词汇的广告，我当时还以为课程会有多丰富。后来没想到竟然是这种。我这样一个老IT人竟然能被一个小小培训机构忽悠倒，更不用说涉世不深的学生了。有些学生被忽悠了还帮人家数钱，还要像别人宣传这个培训机构有多好。<br>我很佩服这些培训机构的忽悠功力真是深不可测，看来他们的主要精力都投入到了骗术的开发上而不是教学。而且这种骗是无懈可击的，你都没发去告他们。最后半个月的课程是面试辅导，后来我弄明白了，这个培训机构是教学生怎样去撒谎，怎样写假简历，怎样去边一些冠冕堂皇的说辞，怎样去骗用人单位，说白了就是教学生骗术！教学生怎样诈骗！我表弟告诉我以后，我立马让他退学了，剩下的学费我也没去要。因为我深知欺骗用人单位后果是多么严重，赶紧悬崖勒马。<br>　　后来我表弟给我一份他同学搞的课堂录屏，讲了一些OOA OOD UML 和设计模式的东西。偏重点就是一些很浮躁的东西，然后说出一些听上去很专业的话，来蒙骗用人单位。这些开发思想类的理念，没有个3年以上的开发经验，是搞不懂的，只能给初学者造成错误的认识。培训机构为了提高就业率，不惜用这种下三滥，不负责的方法教唆学生。要知道，简历造假一旦被公司查到，可以无条件即刻开除，至少我们公司是这样的，这是国家劳动法的规定。而且造假这段不光彩的经历会伴随着人一生，对以后工作可能都有影响。培训机构为了减轻学生的负罪感在课上公开鼓吹：”大不了查出来不干了就是了”，“你不这么干，别人也会这么干的”。给学生灌输错误的人生观。后来，我表弟按照我说的，用真实的简历，真实的经历，在一家外包公司找到了一份工作3000元。<br>他的同学通过造假，诈骗找到了5000多的工作，而且据我表弟说，这些学生还不以为耻反以为荣。向别人炫耀他们是怎样用假冒简历，假冒经历欺骗用人单位，并且得手的，而且互相交流自创的骗术。后来，在qq上，我表弟说，有几个同学因为造假被公司开除了，干了不到一星期，也没给工资。再后来，表弟告诉我他同班同学去<em>内培训的经历,</em>内学完后感觉什么都会了，也没有造假，就是没找到工作，即使没找到工作，他们也说*内培训质量有多好，老师水平有多高。我很悲哀现在的大学生思维判断力为什么如此低下，像牛羊一样供骗子宰割，为什么没有一点甄别真伪的能力？为什么甘愿自己冒着被开除、留下不良记录的风险也要拼命给培训机构提高就业率？为什么自己受了骗还要帮着别人数钱？还要帮骗子宣传，说骗子的好？<br>　　有一次，我面试一位初级IOS开发(IOS和Android实质就是写UI，这里提醒有追求，有理想的同学最好不要干这行，虽然工资不低)，他期望的工资比较高，我暗示他期望有点高，后来这哥们说了实话:他有一次在网上看到了一个IOS培训的广告，点了进去，为了得到一个视频教程，他留下了自己的手机号，后来一位工作人员联系上了他，在他的软磨硬泡下，这哥们决定去参加培训，后来得知培训费竟然要一万七，哥们家是农村，拿不出来，客服有说可以先学，学会了以后付款。只要签一个协议，他糊里糊涂签了字。后来才知道这实际上就相当于一个欠条。而且即使你找不到工作也必须还钱，培训机构不断催债，他只能东拼西借。一万七！用父母的血汗钱来参加培训！对一个面朝黄土背朝天的农民来说是一个不小的天文数字。他说工资太低的话，他每月还完债，剩下的钱在北京还不够交房租的。最后他没有被录用，期望工资太高，公司不可能为他的培训费买单。天底下竟然有如此之黑的培训机构！<br>　　我表弟学的那家虽然也是骗，不过和这家比，可以说是骗得合理，骗得仁义！骗得有分寸！小巫见大巫！过了这么多年，我表弟也是快奔30的人了，依然干着最低级的工作，虽然他的职称是软件工程师，虽然他工资上万了，但是他本质上还是一个代码民工，没变。每天写着重复的代码，仍然是当初在培训班学的那些，每天坐在电脑前10多个小时，每天加班到很晚，靠透支体力，透支生命来换钱。又一次他问我为什么一个频繁删减的集合类变量要用链表？用数组不是一样吗？我告诉他这种问题去看大学数据结构课本。他说最近在公司干得很累，干不下去了，想考研，又不想去啃课本太麻烦，脑力不如以前了。我开始反思，当年我的决定是不是错的，如果表弟参加了培训，虽然迈不过30岁这个坎，但是这10年间起码有个谋生的工作干着。实际上能迈过30这个坎的程序员能有几个？大多数都被拍死在沙滩上了。<br>　　像我这样的毕竟是少数，我不是吹，本科的时候能把《c++ primer》读透的能有几个，研究生时候把linux内核源码整体啃一遍的能有几个？培训只能教一些花拳绣腿，真正的内功还得需要自己慢慢修炼。我后悔，当时其实我可以给表弟更多一些钱，供他读研究生，继续深造，当时为了省钱送他去培训，现在看是害了他。兄弟，当哥的真是对不起你。去年，有一天中午吃晚饭，有个小伙向我问路，我正好跟他顺路，我看他拿着一个透明文件袋，问他是不是要去面试，他说是，他问我干软件测试有没有前途，我问他是学什么的，他说机械，后来参加了测试培训。我很诚实地说，干软件测试没前途，但是可以找到一份工作，吃饱饭。看他很失望，我又说，干好了可以干测试经理。<br>　　很多人都说干软件的都是吃青春饭，没错，这种短期培训出来的学生都是短期催熟的，没有经过大自然的历练，没有经过痛苦的涅槃，没有真正的内功，只玩一些花拳绣腿自然混不长远。<br>有人问我，培训的学生和自学成才的学生有什么区别？我问你，人工养殖的人参和野人参有什么区别？如果你现在刚毕业，没有工作。如果家里比较富裕，建议你读研，继续学习，把理论和技术学精。如果你家里不太富裕，揭不开锅了，可以选择去培训，或者找其他工作先挣钱。等找到工作后挣钱，有了钱可以选择继续深造，读研毕业后，找工作就相对比较容易，可以找个比较体面的工作。如果你大学4年没努力，想借培训这3、4个月来力挽狂澜那是不可能的，你首先要接受这个现实。“参加了我们的培训可以让你挽回败局，扭转乾坤。”这只是培训机构的宣传，就是为了随和你的这种心理，而且培训机构会极力鼓吹大学教育多么无用。<br>很多看起来高大上的培训机构，实际上都是败絮其中，专门玩弄专业术语欺骗像学生这种涉世不深的群体。我说的这些都是真话，可能会遭到培训机构的群体攻击，但是我还是要说。实际上我在工作中用到的技术很多重要的思想都是在大学学到的，你们可以看看有没有清华北大毕业的学生，毕业之后成群结队地去培训机构“补习”。你们可以看看，那些大学没有好好学习，基础理论不扎实，毕业后问父母要一万多元的血汗钱去培训机构“补习”的都是些什么样的学生。<br>　　有人说人这一辈子，有三件大事得做好:(1)考大学。(2)找工作。(3)结婚。只要这三件事做好了，一辈子一帆风顺。希望要去培训机构学习的同学能擦亮双眼，三思而行，在人生的重要的岔路口选对方向。分清什么是真正的内功，什么是花拳绣腿；什么是可以做一辈子的事业，什么是青春饭。不要被虚幻的假象和诱惑迷住了双眼。</p>
<blockquote>
<p>博主觉得无论是自学还是报名培训班，真正的去喜欢代码，热爱编写代码的过程才是最重要的，我是一名纯自学的野生程序员，等我整理整理思路，为大家写写我自学Android的经历。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载，个人感觉观点有些偏激，不过有些思路绝对是对我有启发的。作为一个零基础自学一路走来的程序员，等有机会写写自己自学的经历吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="心路" scheme="http://yoursite.com/categories/%E5%BF%83%E8%B7%AF/"/>
    
    
      <category term="培训" scheme="http://yoursite.com/tags/%E5%9F%B9%E8%AE%AD/"/>
    
      <category term="教训" scheme="http://yoursite.com/tags/%E6%95%99%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>5分钟让你学会用最高效的工具解析所有Json</title>
    <link href="http://yoursite.com/2016/07/27/5%E5%88%86%E9%92%9F%E8%AE%A9%E4%BD%A0%E5%AD%A6%E4%BC%9A%E7%94%A8%E6%9C%80%E9%AB%98%E6%95%88%E7%9A%84%E5%B7%A5%E5%85%B7%E8%A7%A3%E6%9E%90%E6%89%80%E6%9C%89Json/"/>
    <id>http://yoursite.com/2016/07/27/5分钟让你学会用最高效的工具解析所有Json/</id>
    <published>2016-07-27T14:02:25.426Z</published>
    <updated>2016-07-27T14:03:18.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5分钟让你学会用最高效的工具解析所有Json"><a href="#5分钟让你学会用最高效的工具解析所有Json" class="headerlink" title="5分钟让你学会用最高效的工具解析所有Json"></a>5分钟让你学会用最高效的工具解析所有Json</h1><blockquote>
<p>原创博客，转载请经过本人允许，你们的点赞和关注是我长期写作的动力~</p>
</blockquote>
<a id="more"></a>
<p>如果你是一个Android开发工程师，学会解析Json字符串是你的必修课，本篇文章主要以实例的方式手把手教你怎么做，花五分钟时间阅读本篇文章你就可以学会解析所有的Json字符串啦。</p>
<p><strong>准备：</strong></p>
<ul>
<li>json字符串</li>
<li>fastjson</li>
<li>HiJson格式化json工具</li>
</ul>
<p><strong>开始教程：</strong></p>
<ul>
<li><p><strong>fastjson：</strong></p>
<p>常用工作中解析json的工具类有谷歌的GSON，jackson，fastjson，这里就不做一一比较了，博主告诉大家，fastjson就是最高效最好用的，选它就没错了。FastJson出自阿里工程师之手，是一个Json处理工具包，包括“序列化”和“反序列化”两部分，它具备如下特征：</p>
<ul>
<li><p>速度最快，测试表明，fastjson具有极快的性能，超越任其他的Java Json parser。包括自称最快的JackJson，是GSON解析速度的6倍；</p>
</li>
<li><p>功能强大，完全支持Java Bean、集合、Map、日期、Enum，支持范型，支持自省；无依赖，能够直接运行在Java SE 5.0以上版本；支持Android；开源 (Apache 2.0)</p>
</li>
</ul>
<p><strong>下载地址：</strong></p>
<pre><code>[fastjson jar包下载地址](http://download.csdn.net/detail/pdsyzbaozi/8199419)
</code></pre></li>
<li><p><strong>HiJson：</strong></p>
<p>HiJson是一个将 json <strong>字符串格式化</strong>的工具，非常好用，让你的json字符串结构一目了然，并且可以直接复制键值，强烈推荐！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-37902f91956283a6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HiJson格式化json"></p>
<p><strong>下载地址：</strong></p>
<p><a href="http://download.csdn.net/download/u012017406/8195263" target="_blank" rel="external">HiJson下载地址</a></p>
</li>
</ul>
<p>Fastjson API入口类是com.alibaba.fastjson.JSON，常用的序列化操作都可以在JSON类上的静态方法直接完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray </div><div class="line">public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject    </div><div class="line">public static final  T parseObject(String text, Class clazz); // 把JSON文本parse为JavaBean </div><div class="line">public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray </div><div class="line">public static final  List parseArray(String text, Class clazz); //把JSON文本parse成JavaBean集合 </div><div class="line">public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本 </div><div class="line">public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 </div><div class="line">public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray。</div></pre></td></tr></table></figure>
<p>如果你从没解析过json，看不太明白没关系，现在我上面那个json字符串，手把手的教你怎么解析，学会解析这个较复杂的json串，相信其他的你也肯定也会解析了。</p>
<p><strong>json串提供给大家拿去练手</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;status&quot;: &quot;2000&quot;,</div><div class="line">	&quot;msg&quot;: &quot;Successful!&quot;,</div><div class="line">	&quot;data&quot;: [&#123;</div><div class="line">		&quot;details&quot;: [&#123;</div><div class="line">			&quot;distance&quot;: 2847,</div><div class="line">			&quot;nextLat&quot;: 39.994076,</div><div class="line">			&quot;nextLong&quot;: 116.47764,</div><div class="line">			&quot;nexti&quot;: &quot;MeloDev&quot;,</div><div class="line">			&quot;status&quot;: 4</div><div class="line">		&#125;],</div><div class="line">		&quot;distance&quot;: 2847,</div><div class="line">		&quot;imageUrl&quot;: &quot;&quot;,</div><div class="line">		&quot;overview&quot;: &quot;长期原创Android博客&quot;,</div><div class="line">		&quot;source&quot;: &quot;http://www.jianshu.com/users/f5909165c1e8/latest_articles&quot;,</div><div class="line">		&quot;status&quot;: &quot;SUCCESSFUL&quot;</div><div class="line">	&#125;, &#123;</div><div class="line">		&quot;details&quot;: [&#123;</div><div class="line">			&quot;distance&quot;: 2769,</div><div class="line">			&quot;nextLat&quot;: 39.97691,</div><div class="line">			&quot;nextLong&quot;: 116.46019,</div><div class="line">			&quot;nexti&quot;: &quot;MeloDev&quot;,</div><div class="line">			&quot;status&quot;: 4</div><div class="line">		&#125;],</div><div class="line">		&quot;distance&quot;: 2769,</div><div class="line">		&quot;imageUrl&quot;: &quot;&quot;,</div><div class="line">		&quot;overview&quot;: &quot;喜欢请加关注&quot;,</div><div class="line">		&quot;source&quot;: &quot;http://www.jianshu.com/users/f5909165c1e8/latest_articles&quot;,</div><div class="line">		&quot;status&quot;: &quot;SUCCESSFUL&quot;</div><div class="line">	&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好的万事俱备，马上就开始！</p>
<p>把下载的fastjson的两个jar包导入libs目录下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-c0e69c1f32a9b485?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入fastjson的jar包"></p>
<p>现在开始比较关键的一步，新建一个bean对象，去作为json解析之后的载体，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class QueryResultInfo &#123;</div><div class="line">	public String status;</div><div class="line">	public String msg;</div><div class="line">	public List&lt;DataList&gt; data;</div><div class="line"></div><div class="line">	public class DataList &#123;</div><div class="line">		public int distance;</div><div class="line">		public String imageUrl;</div><div class="line">		public String overview;</div><div class="line">		public String source;</div><div class="line">		public String status;</div><div class="line">		public List&lt;DetailsList&gt; details;</div><div class="line"></div><div class="line">		@Override</div><div class="line">		public String toString() &#123;</div><div class="line">			return &quot;DataList [distance=&quot; + distance + &quot;, imageUrl=&quot; + imageUrl + &quot;, overview=&quot; + overview + &quot;, source=&quot; + source + &quot;, status=&quot; + status + &quot;, details=&quot; + details.toString() + &quot;]&quot;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		public class DetailsList &#123;</div><div class="line">			public int distance;</div><div class="line">			public double nextLat;</div><div class="line">			public double nextLong;</div><div class="line">			public String nexti;</div><div class="line">			public int status;</div><div class="line"></div><div class="line">			@Override</div><div class="line">			public String toString() &#123;</div><div class="line">				return &quot;DetailsList [distance=&quot; + distance + &quot;, nextLat=&quot; + nextLat + &quot;, nextLong=&quot; + nextLong + &quot;, nexti=&quot; + nexti + &quot;, status=&quot; + status + &quot;]&quot;;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;QueryResultInfo [status=&quot; + status + &quot;, msg=&quot; + msg + &quot;, data=&quot; + data.toString() + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我来告诉大家，写一个解析json之后bean对象的技巧。首先观察json格式化的结果（HiJson工具右侧视图），java代码中：</p>
<ul>
<li><p><strong>数据的类型、键的名称都必须与json字符串保证一一对应</strong><br>也就是例子中，每个变量都是以json的<strong>键名称</strong>命名的，不能写错，而且数据类型也必须对应，String就是String，int就是int，float就是float</p>
</li>
<li><p>如果出现嵌套的数组，就写一个<strong>内部类</strong>，用同样的方式命名各个json字段，用List接收它，注意List的命名也得是用json中的<strong>键名</strong>。多层嵌套以此类推。</p>
</li>
<li><p>所有变量的访问域都是<strong>public</strong>的。</p>
</li>
</ul>
<p><strong>好了bean对象就完成了。</strong></p>
<p>我把json字符串存在了String.xml下，点击按钮之后，解析json字符串，layout文件很简单，这里就不放出了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-6142704e39e36afe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MainActivity"></p>
<p>可以看到，我们调用JSON.parseObject(myJson,AppInfo.class)这一行代码，我们就把json字符串的所有信息都解析到了appInfo对象中，想用什么就直接取出来就可以了。</p>
<p>这个json字符串相对还是复杂的，多层嵌套，所以这个你都会了，简单的你也肯定没问题了，当然fastjson的强大不止于此，如果有特殊需要，再慢慢发掘吧~！</p>
<blockquote>
<p>喜欢请关注哦，未来要写一篇有关线程消息机制Handler的字典型博客，正在深入研究中！</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5分钟让你学会用最高效的工具解析所有Json&quot;&gt;&lt;a href=&quot;#5分钟让你学会用最高效的工具解析所有Json&quot; class=&quot;headerlink&quot; title=&quot;5分钟让你学会用最高效的工具解析所有Json&quot;&gt;&lt;/a&gt;5分钟让你学会用最高效的工具解析所有Json&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原创博客，转载请经过本人允许，你们的点赞和关注是我长期写作的动力~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Json" scheme="http://yoursite.com/tags/Json/"/>
    
  </entry>
  
  <entry>
    <title>Android开发必读博客</title>
    <link href="http://yoursite.com/2016/07/27/Android%E5%BC%80%E5%8F%91%E5%BF%85%E8%AF%BB%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/07/27/Android开发必读博客/</id>
    <published>2016-07-27T14:00:40.817Z</published>
    <updated>2016-07-27T14:01:48.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android开发者必须阅读的博客"><a href="#Android开发者必须阅读的博客" class="headerlink" title="Android开发者必须阅读的博客"></a>Android开发者必须阅读的博客</h1><p><strong>周末闲暇在家，为大家整理了一下Android开发者需要关注的博客、公众号等优秀的学习资源~</strong></p>
<blockquote>
<p>博主长期坚持原创分享，喜欢请关注，转载请得到本人允许。</p>
</blockquote>
<a id="more"></a>
<h2 id="零：技术博客"><a href="#零：技术博客" class="headerlink" title="零：技术博客"></a>零：技术博客</h2><ul>
<li><p><strong>郭霖：</strong></p>
<p><a href="http://blog.csdn.net/guolin_blog/" target="_blank" rel="external">郭霖CSDN博客</a> </p>
<p>简介：圈内人称郭神，Android最好的入门书籍《第一行代码》的作者。博文行文流畅，条理清晰，内容实用，适合读完入门书籍之后阅读，超高人气博主。</p>
</li>
<li><p><strong>任玉刚：</strong></p>
<p><a href="http://blog.csdn.net/singwhatiwanna/" target="_blank" rel="external">任玉刚CSDN博客</a></p>
<p>简介：中科大硕士，百度Android资深工程师，进阶书籍《Android开发艺术探索》作者，博客极具深度广度，适合Android开发者的高阶学习。最近任玉刚老师推出了与书籍相配套的视频教程，感兴趣的同学可以关注下。</p>
</li>
<li><p><strong>张鸿洋：</strong></p>
<p><a href="http://blog.csdn.net/lmj623565791/" target="_blank" rel="external">张鸿洋CSDN博客</a></p>
<p>CSDN超人气博主，对Android中的源码，自定义View颇有研究。并且有很多值得借鉴的应用编写技巧，值得推荐！</p>
</li>
<li><p><strong>兰亭风雨：</strong></p>
<p><a href="http://blog.csdn.net/ns_code" target="_blank" rel="external">兰亭风雨CSDN博客</a></p>
<p>简介：圈内公认的Java大牛，对Java虚拟机有深度研究，出色的Java源码分析</p>
</li>
<li><p><strong>Mr.Simple：</strong></p>
<p><a href="http://blog.csdn.net/bboyfeiyu" target="_blank" rel="external">Mr.Simple CSDN博客</a></p>
<p>简介：开源框架专家，OOP等，《从小工到专家》、《Android设计模式》作者。博主手中就有一本从小工到专家，性能优化部分非常不错，热爱分享的技术大牛，值得推荐。</p>
</li>
<li><p><strong>爱哥：</strong></p>
<p><a href="http://blog.csdn.net/aigestudio/" target="_blank" rel="external">爱哥CSDN博客</a></p>
<p>简介：博主偶然间搜索到他自定义控件部分的博客，深入浅出，幽默诙谐，逼格满满，自定义View专家。</p>
</li>
<li><p><strong>胡凯：</strong></p>
<p><a href="http://hukai.me/" target="_blank" rel="external">胡凯个人博客</a></p>
<p>精通Android性能优化，长期坚持翻译国外先驱技术博客。</p>
</li>
<li><p><strong>张明云：</strong></p>
<p><a href="http://zmywly8866.github.io/" target="_blank" rel="external">张明云github博客</a></p>
<p>张明云老师长期活跃于知乎、简书等技术平台，对性能优化、各种坑的解决颇有研究并且乐于分享，简书上也有张明云老师的专栏，强烈推荐！</p>
</li>
</ul>
<h2 id="一：值得关注的微信公众号"><a href="#一：值得关注的微信公众号" class="headerlink" title="一：值得关注的微信公众号"></a>一：值得关注的微信公众号</h2><ul>
<li><p><strong>stormzhang：</strong></p>
<p>可能是最有影响力的Android公众号了，自学成才的张哥以他励志的经历，出色的行动力和人格魅力影响了一大批初学者，也包括博主在内，通过自学走上了Android开发者的道路，如果你刚刚接触Android，跟随张哥的脚步慢慢学习是最好的选择。</p>
<p><a href="http://stormzhang.com/" target="_blank" rel="external">stormzhang博客精华</a></p>
<p><strong>微信公众号：AndroidDeveloper</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9bf78ce7122af7d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stormzhang公众号"></p>
</li>
<li><p><strong>汤涛：</strong></p>
<p>如果你是一个中高级Android开发者，那汤涛哥的公众号你有必要关注一下了。汤涛哥的公众号每一篇都是精品，宁缺毋滥，专注于Android开发实战，汤涛哥人也非常好，热爱分享，专注技术深度挖掘。</p>
<p><strong>微信公众号：androidtrening</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8c1c982e415346a0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="汤涛老师公众号"></p>
</li>
<li><p><strong>移动开发前线：</strong></p>
<p>分享优质iOS、Android、前端技术精品文章</p>
<p><strong>微信公众号：bornmobile</strong></p>
</li>
</ul>
<h2 id="二：优秀学习网站"><a href="#二：优秀学习网站" class="headerlink" title="二：优秀学习网站"></a>二：优秀学习网站</h2><p>吐血推荐给大家几个学习网站，都非常不错</p>
<p><a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线</a></p>
<p><a href="https://xitu.io/gold-app" target="_blank" rel="external">稀土：掘金</a></p>
<p><a href="http://androidweekly.cn/" target="_blank" rel="external">AndroidWeekly开发技术周报</a></p>
<p><a href="http://memect.com/" target="_blank" rel="external">好东西传送门</a></p>
<p><strong>相关配套阅读：</strong></p>
<p><a href="http://www.jianshu.com/p/9a80e48ef7bc" target="_blank" rel="external">移动开发必读书单</a></p>
<p><strong>PS：如果对你有帮助就点赞关注下吧，过两天为大家整理整理一些知名的开源项目！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android开发者必须阅读的博客&quot;&gt;&lt;a href=&quot;#Android开发者必须阅读的博客&quot; class=&quot;headerlink&quot; title=&quot;Android开发者必须阅读的博客&quot;&gt;&lt;/a&gt;Android开发者必须阅读的博客&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;周末闲暇在家，为大家整理了一下Android开发者需要关注的博客、公众号等优秀的学习资源~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;博主长期坚持原创分享，喜欢请关注，转载请得到本人允许。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="推荐" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Melo&#39;s Blog</title>
  <subtitle>耐心的偏执狂，浪漫的现实主义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-04T15:47:20.175Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melo</name>
    <email>MeloAndroid@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/01/04/Android%206.0%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E7%AE%80%E6%B4%81%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2017/01/04/Android 6.0运行时权限简洁封装/</id>
    <published>2017-01-04T15:48:23.063Z</published>
    <updated>2017-01-04T15:47:20.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href="">暂无</a></li>
</ul>
</blockquote>
<h1 id="Android-6-0-运行时权限简洁封装"><a href="#Android-6-0-运行时权限简洁封装" class="headerlink" title="Android 6.0 运行时权限简洁封装"></a>Android 6.0 运行时权限简洁封装</h1><blockquote>
<p>本文原创，转载请注明出处。<br>欢迎关注我的 <a href="http://www.jianshu.com/users/f5909165c1e8/latest_articles" target="_blank" rel="external">简书</a> ，关注我的专题 <a href="http://www.jianshu.com/collection/b1fa46ec3b08" target="_blank" rel="external">Android Class</a> 我会长期坚持为大家收录简书上高质量的 Android 相关博文。</p>
</blockquote>
<p><strong>写在前面：</strong></p>
<p>Android M 中有一个比较重要的知识点就是运行时权限了，关于运行时权限的文章和封装库目前也出现了不少，在开发的过程中始终觉得运行时权限这块的代码可以进一步封装一下，让其使用起来能再简洁一点，并且还不容易出错。关于 Android 运行时权限的知识就不多讲解了，可以参考下面的一些资料：</p>
<p><a href="https://developer.android.com/training/permissions/requesting.html" target="_blank" rel="external">Android Runtime Permissions</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="external">Android 6.0 运行时权限处理完全解析</a></p>
<p>知识点比较简单，大致了解和使用过后，就来开始我的这次封装之旅吧。</p>
<a id="more"></a>
<p>现在直观的看看封装之后的使用，是不是清爽很多？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@OnClick(R.id.tv_toolbar_right)</div><div class="line">public void onClick() &#123;</div><div class="line">    performRequestPermissions(getString(R.string.permission_desc), new String[]&#123;Manifest.permission.READ_PHONE_STATE, Manifest.permission.ACCESS_COARSE_LOCATION&#125;</div><div class="line">            , PER_REQUEST_CODE, new PermissionsResultListener() &#123;</div><div class="line">                @Override</div><div class="line">                public void onPermissionGranted() &#123;</div><div class="line">                    Toast.makeText(MainActivity.this, &quot;已申请权限&quot;, Toast.LENGTH_LONG).show();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onPermissionDenied() &#123;</div><div class="line">                    Toast.makeText(MainActivity.this, &quot;拒绝申请权限&quot;, Toast.LENGTH_LONG).show();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我将运行时权限封装到 BaseActivity 中，MainActivty 继承BaseActivity，调用 performRequestPermissions 方法，此时我不用再去做一些判断，只需要穿入四个参数即可。当然你为了在 6.0 以下保证应用正常运行，你依然需要像以前一样，在<strong>清单文件</strong>中申明要使用的权限。</p>
<p>首先我需要一个接口做通信：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface PermissionsResultListener &#123;</div><div class="line"></div><div class="line">    void onPermissionGranted();</div><div class="line"></div><div class="line">    void onPermissionDenied();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后把逻辑代码封装在 BaseActivity 里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line">public class BaseActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private PermissionsResultListener mListener;</div><div class="line"></div><div class="line">    private int mRequestCode;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 其他 Activity 继承 BaseActivity 调用 performRequestPermissions 方法</div><div class="line">     *</div><div class="line">     * @param desc        首次申请权限被拒绝后再次申请给用户的描述提示</div><div class="line">     * @param permissions 要申请的权限数组</div><div class="line">     * @param requestCode 申请标记值</div><div class="line">     * @param listener    实现的接口</div><div class="line">     */</div><div class="line">    protected void performRequestPermissions(String desc, String[] permissions, int requestCode, PermissionsResultListener listener) &#123;</div><div class="line">        if (permissions == null || permissions.length == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        mRequestCode = requestCode;</div><div class="line">        mListener = listener;</div><div class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</div><div class="line">            if (checkEachSelfPermission(permissions)) &#123;// 检查是否声明了权限</div><div class="line">                requestEachPermissions(desc, permissions, requestCode);</div><div class="line">            &#125; else &#123;// 已经申请权限</div><div class="line">                if (mListener != null) &#123;</div><div class="line">                    mListener.onPermissionGranted();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (mListener != null) &#123;</div><div class="line">                mListener.onPermissionGranted();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 申请权限前判断是否需要声明</div><div class="line">     *</div><div class="line">     * @param desc</div><div class="line">     * @param permissions</div><div class="line">     * @param requestCode</div><div class="line">     */</div><div class="line">    private void requestEachPermissions(String desc, String[] permissions, int requestCode) &#123;</div><div class="line">        if (shouldShowRequestPermissionRationale(permissions)) &#123;// 需要再次声明</div><div class="line">            showRationaleDialog(desc, permissions, requestCode);</div><div class="line">        &#125; else &#123;</div><div class="line">            ActivityCompat.requestPermissions(BaseActivity.this, permissions, requestCode);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 弹出声明的 Dialog</div><div class="line">     *</div><div class="line">     * @param desc</div><div class="line">     * @param permissions</div><div class="line">     * @param requestCode</div><div class="line">     */</div><div class="line">    private void showRationaleDialog(String desc, final String[] permissions, final int requestCode) &#123;</div><div class="line">        final AlertDialog.Builder builder = new AlertDialog.Builder(this);</div><div class="line">        builder.setTitle(getString(R.string.tips))</div><div class="line">                .setMessage(desc)</div><div class="line">                .setPositiveButton(getResources().getString(R.string.confrim), new DialogInterface.OnClickListener() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void onClick(DialogInterface dialogInterface, int i) &#123;</div><div class="line">                        ActivityCompat.requestPermissions(BaseActivity.this, permissions, requestCode);</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .setNegativeButton(getResources().getString(R.string.cancle), new DialogInterface.OnClickListener() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void onClick(DialogInterface dialogInterface, int i) &#123;</div><div class="line">                        dialogInterface.dismiss();</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .setCancelable(false)</div><div class="line">                .show();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 再次申请权限时，是否需要声明</div><div class="line">     *</div><div class="line">     * @param permissions</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean shouldShowRequestPermissionRationale(String[] permissions) &#123;</div><div class="line">        for (String permission : permissions) &#123;</div><div class="line">            if (ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检察每个权限是否申请</div><div class="line">     *</div><div class="line">     * @param permissions</div><div class="line">     * @return true 需要申请权限,false 已申请权限</div><div class="line">     */</div><div class="line">    private boolean checkEachSelfPermission(String[] permissions) &#123;</div><div class="line">        for (String permission : permissions) &#123;</div><div class="line">            if (ContextCompat.checkSelfPermission(this, permission) != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 申请权限结果的回调</div><div class="line">     *</div><div class="line">     * @param requestCode</div><div class="line">     * @param permissions</div><div class="line">     * @param grantResults</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;</div><div class="line">        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</div><div class="line">        if (requestCode == mRequestCode) &#123;</div><div class="line">            if (checkEachPermissionsGranted(grantResults)) &#123;</div><div class="line">                if (mListener != null) &#123;</div><div class="line">                    mListener.onPermissionGranted();</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;// 用户拒绝申请权限</div><div class="line">                if (mListener != null) &#123;</div><div class="line">                    mListener.onPermissionDenied();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检查回调结果</div><div class="line">     *</div><div class="line">     * @param grantResults</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean checkEachPermissionsGranted(int[] grantResults) &#123;</div><div class="line">        for (int result : grantResults) &#123;</div><div class="line">            if (result != PackageManager.PERMISSION_GRANTED) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个方法都有注释，逻辑也相对简单，就是我会遍历每个数组中申请的权限，如果需要申请就去申请，然后再处理一下回调的结果，其中还有对用户拒绝，然后再次申请弹出 Dialog 的处理。</p>
<p>如果在 Fragment 中使用，只是改变了一下参数封到 BaseFragment 中，这里就不贴代码了，都已经上传 <strong>github</strong></p>
<p>BaseActivity：</p>
<p><a href="https://github.com/itsMelo/BuzzerBeater/blob/master/app/src/main/java/com/blog/melo/buzzerbeater/activity/BaseActivity.java" target="_blank" rel="external">BuzzerBeater BaseActivity</a></p>
<p>BaseFragment：</p>
<p><a href="https://github.com/itsMelo/BuzzerBeater/blob/master/app/src/main/java/com/blog/melo/buzzerbeater/fragment/BaseFragment.java" target="_blank" rel="external">BuzzerBeater BaseFragment</a></p>
<p>如有问题，继续交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;itsCoder主页：&lt;a href=&quot;http://itscoder.com/&quot;&gt;http://itscoder.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://itsmelo.github.io/&quot;&gt;Melo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;审阅者：&lt;a href=&quot;&quot;&gt;暂无&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Android-6-0-运行时权限简洁封装&quot;&gt;&lt;a href=&quot;#Android-6-0-运行时权限简洁封装&quot; class=&quot;headerlink&quot; title=&quot;Android 6.0 运行时权限简洁封装&quot;&gt;&lt;/a&gt;Android 6.0 运行时权限简洁封装&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文原创，转载请注明出处。&lt;br&gt;欢迎关注我的 &lt;a href=&quot;http://www.jianshu.com/users/f5909165c1e8/latest_articles&quot;&gt;简书&lt;/a&gt; ，关注我的专题 &lt;a href=&quot;http://www.jianshu.com/collection/b1fa46ec3b08&quot;&gt;Android Class&lt;/a&gt; 我会长期坚持为大家收录简书上高质量的 Android 相关博文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android M 中有一个比较重要的知识点就是运行时权限了，关于运行时权限的文章和封装库目前也出现了不少，在开发的过程中始终觉得运行时权限这块的代码可以进一步封装一下，让其使用起来能再简洁一点，并且还不容易出错。关于 Android 运行时权限的知识就不多讲解了，可以参考下面的一些资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/permissions/requesting.html&quot;&gt;Android Runtime Permissions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/50709663&quot;&gt;Android 6.0 运行时权限处理完全解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知识点比较简单，大致了解和使用过后，就来开始我的这次封装之旅吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>死磕 Fragment 的生命周期</title>
    <link href="http://yoursite.com/2016/12/12/%E6%AD%BB%E7%A3%95%20Fragment%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2016/12/12/死磕 Fragment 的生命周期/</id>
    <published>2016-12-12T15:26:45.845Z</published>
    <updated>2016-12-12T15:25:37.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href="https://github.com/jasonim" target="_blank" rel="external">jasonim</a></li>
</ul>
</blockquote>
<p>本文例子中 github 地址：<br><a href="https://github.com/itsMelo/BuzzerBeater" target="_blank" rel="external">github BuzzerBeater 项目链接</a><br>（第一个开源项目，目前在逐步更新一些知识点，希望对你有所帮助）</p>
<p>曾经在北京拥挤的13号线地铁上，一名背着双肩包穿着格子衫带着鸭舌帽脚踏帆布鞋的程序员讲了一句：<br>“我觉得 Fragment 真的太难用了”。从而引起一阵躁动激烈的讨论。</p>
<a id="more"></a>
<p><strong>正方观点：</strong></p>
<p>Fragment 真的太好用了。要知道因为 Activity 的启动，涉及到 Android 系统对 ActivityManager 的调度，会关联许多资源和进行诸多复杂运算，在一些高端手机上，这个调度的时长甚至会超过 100 ms。反观 Fragment，启动如巧克力入口般顺滑，轻量不消耗手机资源。还可以做成一个个模块，方便 Activity 复用。并且如果要涉及平板的适配，Fragment 更是必不可少。</p>
<p><strong>反方观点：</strong></p>
<p>Fragment 难用，属于坑多难填。Fragment 本质上是一个有生命周期的 View，生命周期繁多并且异常难管理，多个 Fragment 嵌套更是坑中之坑（我也遇到过…），连 square 和 FaceBook 都摒弃了 Fragment，更何况我们呢！</p>
<p>好吧，不要吵了，用或者不用，遇到问题如何解决，相信大家心里都有一个自己的答案。结合我自己开发时候遇到的问题，下面我们来总结一下 Fragment 的生命周期管理方式，以及一些技巧和建议。</p>
<h2 id="hide-amp-show"><a href="#hide-amp-show" class="headerlink" title="hide &amp; show"></a>hide &amp; show</h2><p>先结合一张项目截图，来直观地看看目前我是如何管理 Fragment 的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-beb0ccb60fbfee45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目截图"></p>
<p>因为我们的项目架构是一 Activity 多 Fragment，并且把所有的 Fragment 都装载到了一个 ViewPager 里面，启动一个新的 Fragment 的过程也是 ViewPager 滑动翻页的过程，未来会考虑把这种管理方式总结成文，整理给大家。总之你目前看到的上图界面，都是 Fragment 呈现的，并且点击按钮什么的，也会跳转到下一个 Fragment，这就涉及到了 Fragment 嵌套。</p>
<p>我也写了一个 Demo，去模拟了这个页面的搭建。</p>
<p>这里想多说几句</p>
<p>通过点击下方 Tab  管理页面的方式目前非常主流，这种布局方式事实上是从 iOS 上面借鉴过来的。（反正现在两大系统都是相互学习）在前一阵 google 的 support 25 包也终于推出了官方的 BottomNavigationView ，不过我的 Android Studio 安装 support 25 总是失败，所以在项目中我选用了一个还不错的开源库来做下方的底部导航。</p>
<p>BottomNavigationView 本身有一套 Material Design 的设计规范如下：</p>
<p><a href="https://material.google.com/components/bottom-navigation.html#bottom-navigation-usage" target="_blank" rel="external"> Material Design Navigation Bottom</a></p>
<p>感兴趣的去阅读一下，以后对产品、设计开撕是很有帮助的。其中有这么一条很有意思，是说 BottomNavigationView 并不建议把它设计成横向滑动的形式，也就是用 ViewPager 去装载 Fragment。为什么说这句很有意思呢？事实上市面上很多主流的 app，它们的 BottomNavigationView 确实是不可以横向滑动的，而我们每个人都在用的，月活8亿的国民软件微信，就恰恰把它的主页面做成了可以横向滑动的。</p>
<p>这里我想说下我的个人看法，首先规范未必需要严格遵守，做什么样的功能实现什么样的效果，要结合自己项目的架构和产品做一个合理的需求。拿 360手机助手 这个 app 举例，它底部的每一个 tab 都搭建了一个非常“重量级”的模块，并且每个 tab 下界面的内部还有许多负责的 View 层级和嵌套滑动的 ViewPager，所以试想一下，这样的页面要是做成微信那个样子，不卡顿就怪了~反观微信，首先我认为它的每个界面层级和交互都不复杂，逻辑也都在页面内，所以做成横向滑动的反而能提升用户的体验。</p>
<p>好了，前面说了好多无关紧要的话，赶紧来看看 demo 中通过 hide 和 show 的方式如何来管理 Fragment。<br><strong>MainActivity</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">private SearchFragment searchFragment;</div><div class="line">private MusicFragment musicFragment;</div><div class="line">private CarFragment carFragment;</div><div class="line">private SettingFragment settingFragment;</div><div class="line"></div><div class="line">private BaseFragment currentFragment;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    ButterKnife.bind(this);</div><div class="line">    setSupportActionBar(toolbar);</div><div class="line">    initView();</div><div class="line">    initData();</div><div class="line">    initListener();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void initData() &#123;</div><div class="line">    if (searchFragment == null) &#123;</div><div class="line">        searchFragment = SearchFragment.newInstance(getString(R.string.tab_1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!searchFragment.isAdded()) &#123;</div><div class="line">        // 提交事务</div><div class="line">        getSupportFragmentManager().beginTransaction().add(R.id.fl_content, searchFragment).commit();</div><div class="line"></div><div class="line">        // 记录当前Fragment</div><div class="line">        currentFragment = searchFragment;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void initListener() &#123;</div><div class="line">    bottomNavigation.setOnTabSelectedListener(new AHBottomNavigation.OnTabSelectedListener() &#123;</div><div class="line">        @Override</div><div class="line">        public boolean onTabSelected(int position, boolean wasSelected) &#123;</div><div class="line"></div><div class="line">            Log.d(TAG, &quot;onTabSelected: position:&quot; + position + &quot;,wasSelected:&quot; + wasSelected);</div><div class="line"></div><div class="line">            if (position == 0) &#123;// 导航</div><div class="line">                clickSearchLayout();</div><div class="line">            &#125; else if (position == 1) &#123;// 音乐</div><div class="line">                clickMusicLayout();</div><div class="line">            &#125; else if (position == 2) &#123;// 车辆</div><div class="line">                clickCarLayout();</div><div class="line">            &#125; else if (position == 3) &#123;</div><div class="line">                clickSettingLayout();</div><div class="line">            &#125; else if (position == 4) &#123;</div><div class="line">                clickToysLayout();</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">private void clickSearchLayout() &#123;</div><div class="line">    if (searchFragment == null) &#123;</div><div class="line">        searchFragment = SearchFragment.newInstance(getString(R.string.tab_1));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), searchFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickMusicLayout() &#123;</div><div class="line">    if (musicFragment == null) &#123;</div><div class="line">        musicFragment = MusicFragment.newInstance(getString(R.string.tab_2));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), musicFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickCarLayout() &#123;</div><div class="line">    if (carFragment == null) &#123;</div><div class="line">        carFragment = CarFragment.newInstance(getString(R.string.tab_3));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), carFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickSettingLayout() &#123;</div><div class="line">    if (settingFragment == null) &#123;</div><div class="line">        settingFragment = SettingFragment.newInstance(getString(R.string.tab_4));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), settingFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 添加或者显示 fragment</div><div class="line"> *</div><div class="line"> * @param transaction</div><div class="line"> * @param fragment</div><div class="line"> */</div><div class="line">private void addOrShowFragment(FragmentTransaction transaction, Fragment fragment) &#123;</div><div class="line">    if (currentFragment == fragment)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!fragment.isAdded()) &#123; // 如果当前fragment未被添加，则添加到Fragment管理器中</div><div class="line">        transaction.hide(currentFragment).add(R.id.fl_content, fragment).commit();</div><div class="line">    &#125; else &#123;</div><div class="line">        transaction.hide(currentFragment).show(fragment).commit();</div><div class="line">    &#125;</div><div class="line">    currentFragment = (BaseFragment) fragment;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码理解起来非常容易，我通过 add &amp; show / hide 的方式来管理底部的四个 tab 相互切换，并且打印了这四个 Fragment 的所有生命周期方法，包括<code>onHiddenChanged</code> 和 <code>setUserVisibleHint</code></p>
<p>当第一次进入某个页面时：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-73843156f8e179ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次进入某个页面时"></p>
<p>可以看到，当我依次点击下方四个 tab，界面第一次加载的时，会走 Fragment 的创建周期 onAttach – onResume，也许你会问，上面我执行相互切换操作，从第一个页面切换到第二个的时候，为什么第一个 Fragment 页面不可见了，不会调用 onPause 和 onStop 呢？</p>
<p>这是在你了解过 Activity 生命周期并且刚接触 Fragment 的生命周期时，第一个容易陷入的误区，事实上 Fragment 的生命周期，除了第一次它创建或销毁之外，统统都是由 Activity 所驱动的。 举个例子，当我点击 home 键回到桌面时：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a2f60abb148e85ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击 home 键"></p>
<p>可以看到我已经加载了的几个 Fragment 齐刷刷的调用了 onPause 和 onStop，如此得步调一致是因为这些 Fragment attach 的 Activity 回调了 onPause 和 onStop。相信肯定会有人说“不对啊，我要是用 replace 的方式去切换 Fragment，我打包票 Fragment 会像 Activity 一样，完整得走完生命周期“</p>
<p>你说的没错，因为 replace 这种切换方式就是始终上面我总结的那句“首次创建或销毁“，并且在 BottomNavigation 这样的使用场景中，没人会用这种 replace 的方式，因为每次切换都要重新创建 Fragment，用户看了下流量估计会打 12315 了。</p>
<p>（如果 Fragment 代表前男/女友，据说男人是用 add 保存，女人使用 replace 替换 hhh…）</p>
<p>当底部的四个 Fragment 都已经加载完成之后咧？再一起看下 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e07a6adc37fe2be8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="onHiddenChanged 回调"></p>
<p>当底部四个 Fragment 全部创建入栈之后，show 和 hide 来管理 Fragment，此时只有 <code>onHiddenChanged</code> 方法回调，这时候显然你可以在 <code>hide = false</code> 时，做一些资源回收操作，在 <code>hide = true</code> 时，做一些刷新操作。</p>
<p>在刚才我们打印的方法中，好像有一个一直没出现，没错就是 <code>setUserVisibleHint</code>，如果你做过 Fragment+ViewPager 的懒加载（下文我们会讲这个），相信你对它就比较熟悉了，通过名字就能猜测出来，这个方法是我们主动设置给 Fragment 的，那我们就来试试看：</p>
<p>改造 <code>addOrShowFragment</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 添加或者显示 fragment</div><div class="line"> *</div><div class="line"> * @param transaction</div><div class="line"> * @param fragment</div><div class="line"> */</div><div class="line">private void addOrShowFragment(FragmentTransaction transaction, Fragment fragment) &#123;</div><div class="line">    if (currentFragment == fragment)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!fragment.isAdded()) &#123; // 如果当前fragment未被添加，则添加到Fragment管理器中</div><div class="line">        transaction.hide(currentFragment).add(R.id.fl_content, fragment).commit();</div><div class="line">    &#125; else &#123;</div><div class="line">        transaction.hide(currentFragment).show(fragment).commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    currentFragment.setUserVisibleHint(false);</div><div class="line"></div><div class="line">    currentFragment = (BaseFragment) fragment;</div><div class="line"></div><div class="line">    currentFragment.setUserVisibleHint(true);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在切换时，我们对上一个 fragment <code>setUserVisibleHint</code>设置为 false，要展现的 Fragment <code>setUserVisibleHint</code> 设置为 true，打印 log 看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4449ec0891b3f069?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setUserVisibleHint"></p>
<p>可以看到目前我们用 setUserVisibleHint 也达到了与 onHiddenChanged 一样的效果。</p>
<p>文章写到现在，我们来做一个总结，上文的这种方式就是主流通过 BottomNavigation 管理 Fragment 的方式，这种方式有什么好处呢？毫无疑问会节省资源，不点开的界面不去创建它（这一点 ViewPager 做不到），只创建一次，未来仅仅更新界面数据就可以了。</p>
<h2 id="ViewPaager-amp-Fragment"><a href="#ViewPaager-amp-Fragment" class="headerlink" title="ViewPaager &amp; Fragment"></a>ViewPaager &amp; Fragment</h2><p>ViewPager 和 Fragment 配合使用相信大多数人都很熟悉了，所以来快速地给大家总结一下我认为需要梳理清楚的几个知识点，先来看我搭建的页面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9d4ecb7454abbf8f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TabLayout+ViewPager"></p>
<p>我在导航的这个模块中，搭建了一个 TabLayout+ViewPager+Fragment 的页面结构，当启动 app，进入首页，各个 Fragment 的生命周期方法是怎样的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-06aec47f6157e0aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页和 Tab 页生命周期方法"></p>
<p>可以看到，当我进入 app 的时候，所有 TabLayout 所在的父容器 SearchFragment 创建，调用了 onAttach –&gt; onResume 这当然是我们预料之中的，我们 ViewPager 第一个装载并展示的是 ScienceFragment，ScienceFragment 创建没有问题，可是第二个 tab GameFragment 为什么加载了呢？</p>
<p>没错这就是 ViewPager 的预加载机制。</p>
<p>ViewPager 出于优化体验的好心，默认去加载相邻两页，来尽可能保证滑动的流畅性，可是假如我们这是一个新闻资讯类的 app，每一个 tab 涉及了复杂的页面和大量的网络请求，这种预加载的机制带来的可能就是麻烦了。所以我们寻找一些办法试图去掉 ViewPager 的预加载。</p>
<p>ViewPager 自身提供了一个方法，<code>mViewPager.setOffscreenPageLimit()</code>，这个方法的官方文档的解释：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b50d507d34361c7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setOffscreenPageLimit 官方文档"></p>
<p>它的意思就是设置 ViewPager 左右两侧缓存页的数量，默认是1，那我们给它设置为0，是不是就能取消预加载了呢？再看看这段蜜汁源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-41aeb6dc992ac5b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setOffscreenPageLimit 源码"></p>
<p>总之源码的意思就是你设置为小于1的值就默认为1，反正这条路目前行不通了。</p>
<p>当然还有一个办法，你直接修改源码以后重新打一个 v4 包，不过非常不建议这样做，未来会产生一些兼容问题。</p>
<p>好吧，你应该知道马上就要说 ViewPager 的懒加载了， 就是要用到上文我们提到的 setUserVisibleHint 方法，当我左右滑动时，来看看打印的 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a1a256101fcdd443?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动时 log"></p>
<p>从 log 中可以分析到两个问题，首先 setUserVisibleHint 这个方法可能会在 onAttach 之前就调用，其次在滑动中设置缓存页数之外的页确实是销毁了。</p>
<p>回顾下前文， 明明说 setUserVisibleHint 这个方法需要主动调用，那在 ViewPager 中，Fragment 的 setUserVisibleHint 方法是谁在何时调用的呢？</p>
<p>我的 ViewPager Adapter 在这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MainTabAdapter extends FragmentStatePagerAdapter &#123;</div><div class="line"></div><div class="line">    private List&lt;Fragment&gt; mList;</div><div class="line"></div><div class="line">    private String mTabTitle[] = new String[]&#123;&quot;科技&quot;, &quot;游戏&quot;, &quot;装备&quot;, &quot;创业&quot;, &quot;想法&quot;&#125;;</div><div class="line"></div><div class="line">    public MainTabAdapter(FragmentManager fm, List&lt;Fragment&gt; list) &#123;</div><div class="line">        super(fm);</div><div class="line">        mList = list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Fragment getItem(int position) &#123;</div><div class="line">        return mList.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getCount() &#123;</div><div class="line">        return mList.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CharSequence getPageTitle(int position) &#123;</div><div class="line">        return mTabTitle[position];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看来看去也就 FragmentStatePagerAdapter  能做这件事了，点进去看看：</p>
<p>FragmentStatePagerAdapter 这个类其实就是一个对 PagerAdapter 的一个封装类，不到200行的代码，果真找到了 setUserVisibleHint 。</p>
<p>有两处位置调用了 setUserVisibleHint ，第一个位置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-86b3cdad740a50ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instantiateItem"></p>
<p>第二个位置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-303808d658d7e612?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setPrimaryItem"></p>
<p>这里源码处理的逻辑是这样子的：</p>
<p>在 instantiateItem 方法中，在我的数据集合中取出对应 positon 的 Fragment，直接给它的 setUserVisibleHint 设置为 false，然后才把它 add 进 FragmentTransaction 中，这恰恰解释了为什么 setUserVisibleHint 的第一次调用是在 onAttach 之前。</p>
<p>下一步 setUserVisibleHint 的设置是在 <code>setPrimaryItem</code>中，<code>setPrimaryItem</code>这个方法可以得到当前 ViewPager 正在展示的 Fragment，并且将上一个 Fragment 的 setUserVisibleHint 置为 false，将要展示的 setUserVisibleHint 置为 true。</p>
<p>通过阅读源码，我们明白了原理，所以直接给大家上在 BaseFragment 实现懒加载代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class BaseFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    protected boolean isViewCreated = false;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        return super.onCreateView(inflater, container, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</div><div class="line">        super.setUserVisibleHint(isVisibleToUser);</div><div class="line">        if (getUserVisibleHint()) &#123;</div><div class="line">            lazyLoadData();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 懒加载方法</div><div class="line">     */</div><div class="line">    protected void lazyLoadData() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具体的 Fragment 中实现懒加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ScienceFragment extends BaseFragment &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_science, container, false);</div><div class="line">        Log.e(TAG, &quot;onCreateView&quot;);</div><div class="line">        isViewCreated = true;</div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void lazyLoadData() &#123;</div><div class="line">        super.lazyLoadData();</div><div class="line">        if (isViewCreated) &#123;</div><div class="line">            Log.e(TAG, &quot;lazyLoadData...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看下 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e5ca14d9d1143cba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="懒加载 log"></p>
<p>可以看到，懒加载就这样实现了。</p>
<p>这里我们再做一个阶段总结，首先大家心里要清楚 setUserVisibleHint 这个是 ViewPager 的行为，它始终都是先行与 Fragment 的生命周期调用的。我们之所以能用懒加载这种办法，主要是因为预加载的 Fragment 已经创建完成一路调用了 onAttach –&gt; onPause，也就是说这个 Fragment 此时可用的，懒加载才有理由生效。不知道这样描述是否难懂，但是跑一下本文的例子就肯定能明白上面这段话了。</p>
<p>所以当 Fragment 第一次创建时，懒加载不会同时调用，所以我们来继续优化优化，我们让 ViewPager 一起加载这五个 Fragment 的布局，然后懒加载就全程可用啦~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mViewPager.setOffscreenPageLimit(5);</div></pre></td></tr></table></figure>
<p>此时无论是我滑动还是点击上方 tab 跳转到任意一个页面，<code>lazyLoadData</code> 方法都会调用，我们可以先加载布局出来，然后可见时刷新数据就 OK 了。</p>
<p>关于 Fragment 的管理，主要就是上文的两种方式，一是 add 和 hide 管理，二是 ViewPager + Fragment，当然具体到每个人自己的项目时，需要分析需求和产品思路找到一个适合自己的方式。当我们知道原理时，做操作就心里有底多了，出了问题也可以快速定位。</p>
<p>上面我们 ViewPager 的 adapter 使用的是 FragmentStatePagerAdapter，还有一个 FragmentPagerAdapter，因为本文的篇幅有些过长，下次会总结出它们在源码角度的区别，以及使用过程中踩到的一些坑。（如果有一些奇怪的问题无法解决，建议先使用 FragmentStatePagerAdapter）。</p>
<p><strong>写在最后：</strong></p>
<p>我们回过头来看开始那个辩题， Fragment 到底用不用？对于大多数开发者来说，当然要用，我个人其实还非常喜欢 Fragment，使用 Fragment 能体现 Android 组件化的思想，其带给开发者的便利远大于麻烦。虽然其生命周期复杂，栈又奇怪难管理，不过当正确的姿势使用 Fragment（不要嵌套 Fragment 使用），趟过一个个坑时，对 Fragment 自然也有信心了。</p>
<p>最后再上一张 Fragment 的生命周期图吧~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b0185314cdb61adc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fragment 生命周期"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;itsCoder主页：&lt;a href=&quot;http://itscoder.com/&quot;&gt;http://itscoder.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://itsmelo.github.io/&quot;&gt;Melo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;审阅者：&lt;a href=&quot;https://github.com/jasonim&quot;&gt;jasonim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文例子中 github 地址：&lt;br&gt;&lt;a href=&quot;https://github.com/itsMelo/BuzzerBeater&quot;&gt;github BuzzerBeater 项目链接&lt;/a&gt;&lt;br&gt;（第一个开源项目，目前在逐步更新一些知识点，希望对你有所帮助）&lt;/p&gt;
&lt;p&gt;曾经在北京拥挤的13号线地铁上，一名背着双肩包穿着格子衫带着鸭舌帽脚踏帆布鞋的程序员讲了一句：&lt;br&gt;“我觉得 Fragment 真的太难用了”。从而引起一阵躁动激烈的讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="动画" scheme="http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>面向对象六大原则和设计模式</title>
    <link href="http://yoursite.com/2016/11/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/11/20/面向对象六大原则和设计模式/</id>
    <published>2016-11-20T14:00:04.955Z</published>
    <updated>2016-11-20T14:06:07.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href=""></a></li>
</ul>
</blockquote>
<p><strong>写在前面：</strong></p>
<p>最近这段时间，无论是写文章的频率，还是新知识的汲取，都不如以往有热情。总是拿工作忙当借口，但是心里明白还是懒和拖延作祟。静下心来反思了最近的状态，还是要及时止住惰性，保持一个良好的、有节奏的学习步调。</p>
<p>本文的内容来自 <strong>Android</strong> 进阶书籍《从小工到专家》，六大原则和设计模式章节。读过之后觉得非常受用，所以为大家整理出来，之后也会带来 <strong>设计模式</strong> 和 <strong>单元测试</strong> 以及 <strong>代码重构</strong> 的介绍，希望我们能早日从码农变成一个开发工程师。话不多说，下面带来书中原汁原味的内容。</p>
<p>在工作的初期，我们可能会经常有这样的感受，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，当自己回头再看这些代码时可能会感慨，怎么能写成这个鸟样。再看那些知名的开源库，它们大多有整洁的代码、清晰简单的接口、职责单一的类，这个时候我们会通常会捶胸顿足而感慨：什么时候老夫才能写出这样的代码！</p>
<p>在做开发的这些年中，我渐渐的感觉到，其实国内的一些初、中级工程师写的东西不规范或者说不够清晰的原因是缺乏一些指导规则。他们手中挥舞着面向对象的大旗，写出来的东西却充斥着面向过程的气味。也许是他们不知道有这些规则，也许是他们知道但是不能很好的运用到实际的代码中，亦或是他们没有在实战项目中体会到这些原则能够带来的优点，以至于他们对这些原则并没有足够的重视。</p>
<p>本章没有详细介绍 OOP 六大原则、设计模式、反模式等内容，只是对它们做了一些简单的介绍。并不是因为它们不重要，而是由于它们太重要，因此我们必须阅读更详尽的书籍来涉入这些知识，设计模式可以参考《设计模式之禅》、《设计模式：可复用面向对象软件的基础》以及《Android源码设计模式解析与实战》，反模式的权威书籍则为《反模式：危机中软件、架构和项目的重构》一书。</p>
<a id="more"></a>
<p>（打字好累…）</p>
<h2 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a><strong>面向对象六大原则</strong></h2><p>在此之前，有一点需要大家知道，熟悉这些原则并不是说你写出的程序就一定灵活、清晰，只是为你优秀的代码之路铺上了一层栅栏，在这些原则的指导下，你才能避免陷入一些常见的代码泥沼，从而让你写出优秀的东西。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则的英文名称是 Single Responsibility Principle，简称是 SPR，简单地说就是一个类只做一件事，这个设计原则备受争议却又极其重要。只要你想和别人争执、怄气或者是吵架，这个原则是屡试不爽的。因为单一职责的划分界限并不是如马路上的行车道那么清晰，很多时候都是需要个人经验来界定。当然，最大的问题就是对职责的定义，什么是类的职责，以及怎么划分类的职责。</p>
<p>试想一下，如果你遵守了这个原则，那么你的类就会划分的很细，每个类都有比较单一的职责，这不就是高内聚、低耦合么！当然，如何界定类的职责就需要你的个人经验了。</p>
<p>我们定义一个网络请求的类，来体现 SRP 的原则，来执行网络请求的接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public interface HttpStack &#123;</div><div class="line">    /**</div><div class="line">     * 执行 Http 请求，并且返回一个 Response</div><div class="line">     */</div><div class="line">    public Response performRequest(Request&lt;?&gt; request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述程序中可以看到，HttpStack 只有一个 performRequest 函数，它的职责就是执行网络请求并且返回一个 Response，它的职责很单一，这样在需要修改执行网络请求的相关代码时，只需要修改实现 HttpStack 接口的类，而不会影响其他类的代码。如果某个类的职责包含有执行网络请求、解析网络请求、进行 gzip 压缩、封装请求参数等，那么在你修改某处代码时就必须谨慎，以免修改的代码影响了其它的功能。当你修改的代码能够基本上不影响其他功能。这就一定程度上保证了代码的可维护性。注意，单一职责原则并不是一个类只能有一个函数，而是说这个类中的函数所做的工作是高度相关的，也就是高内聚。 HttpStack 抽象了执行网络请求的具体过程，接口简单清晰，也便于扩展。</p>
<p><strong>优点：</strong></p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li>
<li>可读性提高，复杂性降低，那当然可读性提高了。</li>
<li>可维护性提高，可读性提高了，那当然更容易维护了。</li>
<li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是所有引用基类、接口的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何报错或者异常，使用者可能根本就不需要知道是子类还是父类。但是，反过来就不行了，有子类出现的地方，父类未必就能使用。</p>
<p>还是以 HttpStack 为例， HttpStack 来表示执行网络请求这个抽象概念。在执行网络请求时，只需要定义一个 HttpStack 对象，然后执行 performRequest 即可，至于 HttpStack 的具体实现由更高层的调用者指定。这部分代码在 RequestQueue 类中，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param coreNums  核心线程数</div><div class="line"> * @param httpStack http 执行器</div><div class="line"> */</div><div class="line">protected RequestQueue(int coreNums, HttpStack httpStack) &#123;</div><div class="line">    mDispatcherNums = coreNums;</div><div class="line">    mHttpStack = httpStack != null ? httpStack : HttpStackFactory.createHttpStack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HttpStackFactory 类的 createHttpStack 函数负责根据 API 版本创建不同的 HttpStack，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 根据 sdk 版本选择 HttpClient 或者 HttpURLConnection</div><div class="line"> */</div><div class="line">public static HttpStack createHttpStack() &#123;</div><div class="line">    int runtimeSDKApi = Build.VERSION.SDK_INT;</div><div class="line">    if (runtimeSDKApi &gt;= GINGERBREAD_SDK_NUM) &#123;</div><div class="line">        return new HttpUrlConnStack();</div><div class="line">    &#125;</div><div class="line">    return new HttpClientStack();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中， RequestQueue 类中依赖的是 HttpStack 接口，而通过 HttpStackFactory 的 createHttpStack 函数返回的是 HttpStack 的实现类 HttpClientStack 或 HttpUrlConnStack。这就是所谓的里氏替换原则，任何父类、父接口出现的地方子类都可以出现，这不就保证了可扩展性吗！</p>
<p>任何实现 HttpStack 接口的类的对象都可以传递给 RequestQueue 实现网络请求的功能，这样执行网络请求的方法就有很多种可能性，而不是只有 HttpClient 和 HttpURLConnection。例如，用户想使用 OkHttp 作为新的网络搜索执行引擎，那么创建一个实现了 HttpStack 接口的 OkHttpStack 类，然后在该类的 performRequest 函数中执行网络请求，最终将 OkHttpStack 对象注入 RequestQueue 即可。</p>
<p>细想一下，很多应用框架不就是这样实现的吗？框架定义一系列相关的逻辑骨架和抽象，使得用户可以将自己的实现注入到框架中，从而实现变化万千的功能。</p>
<p><strong>优点：</strong></p>
<ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性。</li>
<li>提高代码的重用性。</li>
<li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的。</li>
<li>提高产品或项目的开放性。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类所有的属性和方法。</li>
<li>降低了代码的灵活性。子类必须继承父类的属性和方法，让子类自由的世界中多了些约束。</li>
<li>增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的后果—大量的代码需要重构。</li>
</ul>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则这个名字看起来有点不好理解，“依赖”还有“倒置”，这到底是什么意思？依赖倒置原则的几个关键点如下。</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖其抽象。</li>
<li>抽象不应该依赖细节。</li>
<li>细节应该依赖抽象。</li>
</ul>
<p>在 Java 语言中，抽象就是指接口或者抽象类，两者都是不能直接被实例化的。细节就是实现类、实现接口或者继承抽象类而产生的类，其特点就是可以直接被实例化，也就是可以加上一个关键字 new 产生一个对象。依赖倒置原则是 Java 语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接依赖的关系，其依赖关系是通过接口或者抽象类产生的。软件先驱们总是喜欢将一些理论定义得很抽象，弄得不是那么容易理解，其实就是一句话：面向接口编程，或者说是面向抽象编程，这里的抽象是指抽象类或者是接口。面向接口编程是面向对象精髓之一。</p>
<p>采用依赖倒置原则可以减少类之间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>
<p>在前面我们的例子中， RequestQueue 实现类依赖于 HttpStack 接口（抽象），而不依赖于 HttpClientStack 与 HttpUrlConnStack 实现类（细节），这就是依赖倒置原则的体现。如果 RequestQueue 直接依赖了 HttpClientStack ，那么 HttpUrlConnStack 就不能传递给 RequestQueue 了。除非 HttpUrlConnStack 继承自 HttpClientStack 。但这么设计显然不符合逻辑，他们两个之间是同等级的“兄弟”关系，而不是父子的关系，因此，正确的设计就是依赖于 HttpStack 抽象，HttpStack 只是负责定义规范，而 HttpClientStack 和 HttpUrlConnStack 分别实现具体的功能。这样一来也同样保证了扩展性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>可扩展性好</li>
<li>耦合度低</li>
</ul>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则是 Java 世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：一个软件实体类，模块和函数应该对扩展开放，对修改关闭。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。</p>
<p>在软件开发过程中，永远不变的就是变化。开闭原则是使我们的软件系统拥抱变化的核心原则之一。对扩展开放，对修改关闭这样的高层次概括，即在需要对软件进行升级、变化时应该通过扩展的形式来实现，而非修改原有代码。当然这只是一种比较理想的状态，是通过扩展还是通过修改旧代码需要依据代码自身来定。</p>
<p>在我们封装的网络请求模块中，开闭原则体现的比较好的就是 Request 类族的设计。我们知道，在开发 C/S 应用时，服务器返回的数据多种多样，有字符串类型、xml、Json 等。而解析服务器返回的 Response 的原始数据类型则是通过 Request 类来实现的，这样就使得 Request 类对于服务器返回的数据格式有良好的扩展性，即 Request 的可变性太大。</p>
<p>例如，返回的数据格式是 Json，那么使用 JsonRequest 请求来获取数据，它会将结果转成 JsonObject 对象，我们看看 JsonRequest 的核心实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 返回的数据格式为 Json 的请求，Json 对应的对象类型为 JSONObject</div><div class="line">public class JsonRequest extends Request&lt;JSONObject&gt; &#123;</div><div class="line"></div><div class="line">    public JsonRequest(HttpMethod method, String url,</div><div class="line">                       RequestListener&lt;JSONObject&gt; listener) &#123;</div><div class="line">        super(method, url, listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将 Response 的结果转化为 JSONObject</div><div class="line">    @Override</div><div class="line">    public JSONObject parseResponse(Response response) &#123;</div><div class="line">        String jsonString = new String(response.getRawData());</div><div class="line">        try &#123;</div><div class="line">            return new JSONObject();</div><div class="line">        &#125; catch (JSONException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JsonRequest 通过实现 Request 抽象类的 parseResponse 解析服务器返回的结果，这里将结果转换为 JSONObject，并且封装到 Response 类中。</p>
<p>例如，我们的网络框架中，添加对图片请求的支持，即要实现类似 ImageLoader 的功能。这个时候我的请求返回的是 Bitmap 图片，因此，我需要在该类型的 Request 中得到的结果是 Request，但支持一种新的数据格式不能通过修改源码的形式，这样可能会为旧代码引入错误，但是，你又必须实现功能扩展。这就是开闭原则的定义：对扩展开放，对修改关闭。我们看看应该如何做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class ImageRequest extends Request&lt;Bitmap&gt; &#123;</div><div class="line"></div><div class="line">    public ImageRequest(HttpMethod method, String url,</div><div class="line">                        RequestListener&lt;Bitmap&gt; listener) &#123;</div><div class="line">        super(method, url, listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 将 Response 的结果转化为 Bitmap</div><div class="line">    @Override</div><div class="line">    public Bitmap parseResponse(Response response) &#123;</div><div class="line">        return BitmapFactory.decodeByteArray(response.rawData, 0, response.rawData.length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ImageRequest 类的 parseResponse 函数中将 Response 中的原始数据转换成为 Bitmap 即可，当我们需要添加其他数据格式的时候，只需要继承自 Request 类，并且在 parseResponse 方法中将数据转换为具体的形式即可。这样通过扩展的形式来应对软件的变化或者说用户需求的多样性，既避免了破坏原有系统，又保证了软件系统的可维护性。依赖于抽象，而不依赖于具体，使得对扩展开放，对修改关闭。开闭原则与依赖倒置原则，里氏替换原则一样，实际上都遵循一句话：面向接口编程。</p>
<p><strong>优点：</strong></p>
<ul>
<li>增加稳定性</li>
<li>可扩展性高</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端应该依赖于它不需要的接口：一个类对另一个类的依赖应该建立在最小的接口上。根据接口隔离原则，当一个接口太大时，我们需要把它分离成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。</p>
<p>可能描述起来不是很好理解，我们还是以示例来加强理解吧。<br>我们知道，在网络框架中，网络队列中是会对请求进行排序的。内部使用 PriorityBlockingQueue 来维护网络请求队列，PriorityBlockingQueue 需要调用 Request 类的排序方法就可以了，其他的接口他根本不需要，即 PriorityBlockingQueue 只需要 compareTo 这个接口，而这个 compareTo 接口就是我们所说的最小接口，而是 Java 中的 Comparable 接口，但我们这里是指为了学习，至于哪里定义的无关紧要。</p>
<p>在元素排序时，PriorityBlockingQueue 只需要知道元素是个 Comparable 对象即可，不需要知道这个对象是不是 Request 类以及这个类的其他接口。它只需要排序，因此，只要知道它是实现了 Comparable 对象即可，Comparable 就是它的最小接口，也是通过 Comparable 隔离了 PriorityBlockingQueue 类对 Request 类的其他方法的可见性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低耦合性</li>
<li>提升代码的可读性</li>
<li>隐藏实现的细节</li>
</ul>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>迪米特法则也成为最少知识原则（Least Knowledge Principle），虽然名字不同，但是描述的是同一个原则，一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>迪米特原则还有一个英文解释是：Only talk to your immedate friends（只与直接的朋友通信）。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多例如组合、聚合、依赖等。</p>
<p>例如在本例中，网络缓存中的 Response 缓存接口的设计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 请求缓存接口</div><div class="line"> *</div><div class="line"> * @param &lt;K&gt; key 的类型</div><div class="line"> * @param &lt;V&gt; value 的类型</div><div class="line"> */</div><div class="line">public interface Cache&lt;K, V&gt; &#123;</div><div class="line">    public V get(K key);</div><div class="line"></div><div class="line">    public void put(K key, V value);</div><div class="line"></div><div class="line">    public void remove(K key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cache 接口定义了缓存类型需要实现的最小接口，依赖缓存类的对象只需要知道该接口即可。例如，需要将 Http Response 缓存到内存中，并且按照 LRU 的规则进行存储。我们需要 LruCache 类实现这个功能。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// 将请求结果缓存到内存中</div><div class="line">public class LruMemCache implements Cache&lt;String, Response&gt; &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Response LRU 缓存</div><div class="line">     *</div><div class="line">     * @param key</div><div class="line">     * @return</div><div class="line">     */</div><div class="line"></div><div class="line">    private LruCache&lt;String, Response&gt; mResponseCache;</div><div class="line"></div><div class="line">    public LruMemCache() &#123;</div><div class="line">        //计算可使用的最大内存</div><div class="line">        final int maxMemory=(int) (Runtime.getRuntime().maxMemory() / 1024);</div><div class="line"></div><div class="line">        //取八分之一的可用最大内存为缓存</div><div class="line">        final int CacheSize = int maxMemory / 8;</div><div class="line">        mResponseCache = new LruCache&lt;String, Response&gt;(int CacheSize) &#123;</div><div class="line">            @Override</div><div class="line">            protected int SizeOf(String key, Response response) &#123;</div><div class="line">                return response.rawData.length / 1024;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Response get(String key) &#123;</div><div class="line">        return mResponseCache.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void put(String key, Response value) &#123;</div><div class="line">        mResponseCache.get(key, value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void remove(String key) &#123;</div><div class="line">        mResponseCache.remove(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，网络请求框架的直接朋友就是 Cache 或者 LruMemCache，间接朋友就是 LruCache 类。它只需要跟 Cache 类交互即可，并不需要知道 LruCache 类的存在，即真正实现了缓存功能的是 LruCache。这就是迪米特原则，尽量少地知道对象的信息，只与直接的朋友交互。</p>
<p><strong>优点：</strong></p>
<ul>
<li>降低复杂度</li>
<li>降低耦合性</li>
<li>增加稳定性</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>在软件工程中，设计模式是对软件设计中普遍存在、反复出现的各种问题所提出的通用解决方案。这个术语是由 Erich Gamma 等人在1990 年从<strong>建筑设计</strong>领域引入到软件工程领域，从此设计模式在面向对象设计领域逐渐被重视起来。</p>
<p>设计模式并不直接用来完成代码的编写，而是描述在各种情况下要如何解决软件设计问题。面向对象设计模式通常以类或对象来描述其中的关系和相互作用，他们的相互作用能够使软件系统具有高内聚、低耦合的特性，并且使软件能够应对变化。</p>
<p><strong>模式的4个要素</strong></p>
<p><strong>模式名称</strong><br>模式名称用一两个词来描述模式的问题、解决防范和效果。基于一个模式词汇表，同行、同事之间就可以通过它们进行交流，文档中也可以通过模式名来代表一个设计。模式名可以帮助我们思考，便于我们与其他人交流设计思想以及设计结果。</p>
<p><strong>问题</strong><br>描述了应该在什么情况使用设计模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，例如，某个设计不具备良好的可扩展性等，也可能描述了导致不灵活设计的类或者对象结构。</p>
<p><strong>解决方案</strong><br>描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同的场合，所以解决方案并不描述一个具体的设计或者实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的类或者对象组合来解决这个问题。</p>
<p><strong>效果</strong><br>描述了模式应用的效果及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象的设计要素之一。所以模式效果包括对它系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。</p>
<p>设计模式为反复出现的局部软件设计问题指出了通用的解决方案，在很大程度上促进了面向对象软件工程的发展。它将这些常见的设计问题一一总结，将大师们的经验、教训、设计经验分享给了所有人，使得即便是刚刚入行的工程师，也能够设计出可扩展、灵活的软件系统，大大提升了软件质量。关于设计模式领域的书籍大家可以参考《设计模式之禅》、《Android 源码设计模式解析与实战》。</p>
<h2 id="避免掉进过度设计的怪圈"><a href="#避免掉进过度设计的怪圈" class="headerlink" title="避免掉进过度设计的怪圈"></a>避免掉进过度设计的怪圈</h2><p>当你掌握一些设计模式或者方法之后，比较容易出现的问题就是过度设计。有的人甚至在一个应用中一定要将 23 种常见的设计模式运用上，这就本末倒置了。设计模式的四大要素中就明确指出，模式的运用应该根据软件系统所面临的问题来决定是否需要使用现有的设计。也就是说，再出现问题或者你预计会出现那样的问题时，才推荐使用特定的设计模式，而不是将各种设计模式套进你的软件中。</p>
<p>不管在设计、实现、测试之剑有多少时间都应该避免过度设计，它会打破你的反馈回路，使你的设计得不到反馈，从而慢慢陷入危险中。所以你只需要保持简单的设计，这样就有时间来测试该设计是否真的可行，然后作出最后的决策。</p>
<p>当设计一款软件时，从整体高度上设定一种架构模式，确定应用的整体架构，然后再分析一些重要米快的设计思路，并且保证他们的简单性、清晰性，如果有时间可以使用 Java 代码模拟一个简单的原型，确保设计是可行的，最后就可以付诸行动了。切实不要过度的追求设计，适当就好，当我们发现或者预计到将要出现问题时，在判断是否需要运用设计模式。</p>
<h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><p>反模式是一种文字记录形式，描述了对某个问题必然产生的消极后果的常见解决方案。由于管理人员或者开发人员不知道更好的解决方案，缺乏决定特定问题的经验或知识，或者说不适合的条件下套用了某个设计模式，这些都会造成反模式。与设计模式类似，反模式描述了一个一般的形式，主要原因、典型症状。后果，以及最后如何通过重构解决问题。</p>
<p>反模式是把一般情况映射到一类特定解决方案的有效方法。反模式的一般形式为它所针对的哪类问题提供了一个易于辨识的模板。此外，它还清楚地说明了与该问题相关联的症状以及导致这一问题的内在原因：把特定设计模式应用于不正确的环境。</p>
<p>反模式为识别软件行业反复出现的问题提供了实际经验，并为大多数常见的问题提供了详细的解决方案。反模式对业界常见的问题进行总结，并且告诉你如何识别这些问题以及如何解决。它有效的说明了可以在不同的层次上采取的措施，以便改善应用开发过程，软件系统和对软件项目的有效管理。</p>
<p>总的来说，设计模式总结了在特定问题下正确的解决方案，而反模式则是告诉你在特定问题上的错误解决方案和他们的原因、解决方案，通过最终的解决方案，它能够将腐化的软件系统拉回正轨。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>灵活的软件设计需要知识和经验与思考，好的设计通常是经历了时间的洗礼慢慢演化而来，工程师的成长也是一样。因此，掌握必要的面向对象、设计模式、反模式等知识，并且这工作中不断实践、思考，将使你的软件设计之路走得更加从容、顺畅。</p>
<p><strong>写在后面：</strong><br>面向对象的六大原则在开发过程中极为重要，他们给灵活、可扩展的软件系统提供了更细粒度的指导原则。如果能很好地将这些原则运用到项目中，再在一些合适的场景运用一些经过验证过设计模式，那么开发出来的软件在一定程度上能够得到质量保证。其实六大原则最终可以简化为几个关键字：抽象、单一职责、最小化。那么在实际开发中如何权衡，实践这些原则，也是需要大家在工作过程中不断地思考、摸索、实践。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;itsCoder主页：&lt;a href=&quot;http://itscoder.com/&quot;&gt;http://itscoder.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://itsmelo.github.io/&quot;&gt;Melo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;审阅者：&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近这段时间，无论是写文章的频率，还是新知识的汲取，都不如以往有热情。总是拿工作忙当借口，但是心里明白还是懒和拖延作祟。静下心来反思了最近的状态，还是要及时止住惰性，保持一个良好的、有节奏的学习步调。&lt;/p&gt;
&lt;p&gt;本文的内容来自 &lt;strong&gt;Android&lt;/strong&gt; 进阶书籍《从小工到专家》，六大原则和设计模式章节。读过之后觉得非常受用，所以为大家整理出来，之后也会带来 &lt;strong&gt;设计模式&lt;/strong&gt; 和 &lt;strong&gt;单元测试&lt;/strong&gt; 以及 &lt;strong&gt;代码重构&lt;/strong&gt; 的介绍，希望我们能早日从码农变成一个开发工程师。话不多说，下面带来书中原汁原味的内容。&lt;/p&gt;
&lt;p&gt;在工作的初期，我们可能会经常有这样的感受，自己的代码接口设计混乱、代码耦合较为严重、一个类的代码过多等等，当自己回头再看这些代码时可能会感慨，怎么能写成这个鸟样。再看那些知名的开源库，它们大多有整洁的代码、清晰简单的接口、职责单一的类，这个时候我们会通常会捶胸顿足而感慨：什么时候老夫才能写出这样的代码！&lt;/p&gt;
&lt;p&gt;在做开发的这些年中，我渐渐的感觉到，其实国内的一些初、中级工程师写的东西不规范或者说不够清晰的原因是缺乏一些指导规则。他们手中挥舞着面向对象的大旗，写出来的东西却充斥着面向过程的气味。也许是他们不知道有这些规则，也许是他们知道但是不能很好的运用到实际的代码中，亦或是他们没有在实战项目中体会到这些原则能够带来的优点，以至于他们对这些原则并没有足够的重视。&lt;/p&gt;
&lt;p&gt;本章没有详细介绍 OOP 六大原则、设计模式、反模式等内容，只是对它们做了一些简单的介绍。并不是因为它们不重要，而是由于它们太重要，因此我们必须阅读更详尽的书籍来涉入这些知识，设计模式可以参考《设计模式之禅》、《设计模式：可复用面向对象软件的基础》以及《Android源码设计模式解析与实战》，反模式的权威书籍则为《反模式：危机中软件、架构和项目的重构》一书。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="OOP" scheme="http://yoursite.com/tags/OOP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="六大原则" scheme="http://yoursite.com/tags/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>死磕 Fragment 的生命周期</title>
    <link href="http://yoursite.com/2016/10/31/%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%92%8C%E8%A1%A5%E9%97%B4%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2016/10/31/帧动画和补间动画/</id>
    <published>2016-10-31T14:43:46.247Z</published>
    <updated>2016-12-12T15:20:50.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href="https://github.com/jasonim" target="_blank" rel="external">jasonim</a></li>
</ul>
</blockquote>
<p>本文例子中 github 地址：<br><a href="https://github.com/itsMelo/BuzzerBeater" target="_blank" rel="external">github BuzzerBeater 项目链接</a><br>（第一个开源项目，目前在逐步更新一些知识点，希望对你有所帮助）</p>
<p>曾经在北京拥挤的13号线地铁上，一名背着双肩包穿着格子衫带着鸭舌帽脚踏帆布鞋的程序员讲了一句：<br>“我觉得 Fragment 真的太难用了”。从而引起一阵躁动激烈的讨论。</p>
<p><strong>正方观点：</strong></p>
<p>Fragment 真的太好用了。要知道因为 Activity 的启动，涉及到 Android 系统对 ActivityManager 的调度，会关联许多资源和进行诸多复杂运算，在一些高端手机上，这个调度的时长甚至会超过 100 ms。反观 Fragment，启动如巧克力入口般顺滑，轻量不消耗手机资源。还可以做成一个个模块，方便 Activity 复用。并且如果要涉及平板的适配，Fragment 更是必不可少。</p>
<p><strong>反方观点：</strong></p>
<p>Fragment 难用，属于坑多难填。Fragment 本质上是一个有生命周期的 View，生命周期繁多并且异常难管理，多个 Fragment 嵌套更是坑中之坑（我也遇到过…），连 square 和 FaceBook 都摒弃了 Fragment，更何况我们呢！</p>
<p>好吧，不要吵了，用或者不用，遇到问题如何解决，相信大家心里都有一个自己的答案。结合我自己开发时候遇到的问题，下面我们来总结一下 Fragment 的生命周期管理方式，以及一些技巧和建议。</p>
<h2 id="hide-amp-show"><a href="#hide-amp-show" class="headerlink" title="hide &amp; show"></a>hide &amp; show</h2><p>先结合一张项目截图，来直观地看看目前我是如何管理 Fragment 的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-beb0ccb60fbfee45?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目截图"></p>
<p>因为我们的项目架构是一 Activity 多 Fragment，并且把所有的 Fragment 都装载到了一个 ViewPager 里面，启动一个新的 Fragment 的过程也是 ViewPager 滑动翻页的过程，未来会考虑把这种管理方式总结成文，整理给大家。总之你目前看到的上图界面，都是 Fragment 呈现的，并且点击按钮什么的，也会跳转到下一个 Fragment，这就涉及到了 Fragment 嵌套。</p>
<p>我也写了一个 Demo，去模拟了这个页面的搭建。</p>
<p>这里想多说几句</p>
<p>通过点击下方 Tab  管理页面的方式目前非常主流，这种布局方式事实上是从 iOS 上面借鉴过来的。（反正现在两大系统都是相互学习）在前一阵 google 的 support 25 包也终于推出了官方的 BottomNavigationView ，不过我的 Android Studio 安装 support 25 总是失败，所以在项目中我选用了一个还不错的开源库来做下方的底部导航。</p>
<p>BottomNavigationView 本身有一套 Material Design 的设计规范如下：</p>
<p><a href="https://material.google.com/components/bottom-navigation.html#bottom-navigation-usage" target="_blank" rel="external"> Material Design Navigation Bottom</a></p>
<p>感兴趣的去阅读一下，以后对产品、设计开撕是很有帮助的。其中有这么一条很有意思，是说 BottomNavigationView 并不建议把它设计成横向滑动的形式，也就是用 ViewPager 去装载 Fragment。为什么说这句很有意思呢？事实上市面上很多主流的 app，它们的 BottomNavigationView 确实是不可以横向滑动的，而我们每个人都在用的，月活8亿的国民软件微信，就恰恰把它的主页面做成了可以横向滑动的。</p>
<p>这里我想说下我的个人看法，首先规范未必需要严格遵守，做什么样的功能实现什么样的效果，要结合自己项目的架构和产品做一个合理的需求。拿 360手机助手 这个 app 举例，它底部的每一个 tab 都搭建了一个非常“重量级”的模块，并且每个 tab 下界面的内部还有许多负责的 View 层级和嵌套滑动的 ViewPager，所以试想一下，这样的页面要是做成微信那个样子，不卡顿就怪了~反观微信，首先我认为它的每个界面层级和交互都不复杂，逻辑也都在页面内，所以做成横向滑动的反而能提升用户的体验。</p>
<p>好了，前面说了好多无关紧要的话，赶紧来看看 demo 中通过 hide 和 show 的方式如何来管理 Fragment。<br><strong>MainActivity</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">private SearchFragment searchFragment;</div><div class="line">private MusicFragment musicFragment;</div><div class="line">private CarFragment carFragment;</div><div class="line">private SettingFragment settingFragment;</div><div class="line"></div><div class="line">private BaseFragment currentFragment;</div><div class="line"></div><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line">    ButterKnife.bind(this);</div><div class="line">    setSupportActionBar(toolbar);</div><div class="line">    initView();</div><div class="line">    initData();</div><div class="line">    initListener();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void initData() &#123;</div><div class="line">    if (searchFragment == null) &#123;</div><div class="line">        searchFragment = SearchFragment.newInstance(getString(R.string.tab_1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!searchFragment.isAdded()) &#123;</div><div class="line">        // 提交事务</div><div class="line">        getSupportFragmentManager().beginTransaction().add(R.id.fl_content, searchFragment).commit();</div><div class="line"></div><div class="line">        // 记录当前Fragment</div><div class="line">        currentFragment = searchFragment;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void initListener() &#123;</div><div class="line">    bottomNavigation.setOnTabSelectedListener(new AHBottomNavigation.OnTabSelectedListener() &#123;</div><div class="line">        @Override</div><div class="line">        public boolean onTabSelected(int position, boolean wasSelected) &#123;</div><div class="line"></div><div class="line">            Log.d(TAG, &quot;onTabSelected: position:&quot; + position + &quot;,wasSelected:&quot; + wasSelected);</div><div class="line"></div><div class="line">            if (position == 0) &#123;// 导航</div><div class="line">                clickSearchLayout();</div><div class="line">            &#125; else if (position == 1) &#123;// 音乐</div><div class="line">                clickMusicLayout();</div><div class="line">            &#125; else if (position == 2) &#123;// 车辆</div><div class="line">                clickCarLayout();</div><div class="line">            &#125; else if (position == 3) &#123;</div><div class="line">                clickSettingLayout();</div><div class="line">            &#125; else if (position == 4) &#123;</div><div class="line">                clickToysLayout();</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">private void clickSearchLayout() &#123;</div><div class="line">    if (searchFragment == null) &#123;</div><div class="line">        searchFragment = SearchFragment.newInstance(getString(R.string.tab_1));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), searchFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickMusicLayout() &#123;</div><div class="line">    if (musicFragment == null) &#123;</div><div class="line">        musicFragment = MusicFragment.newInstance(getString(R.string.tab_2));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), musicFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickCarLayout() &#123;</div><div class="line">    if (carFragment == null) &#123;</div><div class="line">        carFragment = CarFragment.newInstance(getString(R.string.tab_3));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), carFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void clickSettingLayout() &#123;</div><div class="line">    if (settingFragment == null) &#123;</div><div class="line">        settingFragment = SettingFragment.newInstance(getString(R.string.tab_4));</div><div class="line">    &#125;</div><div class="line">    addOrShowFragment(getSupportFragmentManager().beginTransaction(), settingFragment);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 添加或者显示 fragment</div><div class="line"> *</div><div class="line"> * @param transaction</div><div class="line"> * @param fragment</div><div class="line"> */</div><div class="line">private void addOrShowFragment(FragmentTransaction transaction, Fragment fragment) &#123;</div><div class="line">    if (currentFragment == fragment)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!fragment.isAdded()) &#123; // 如果当前fragment未被添加，则添加到Fragment管理器中</div><div class="line">        transaction.hide(currentFragment).add(R.id.fl_content, fragment).commit();</div><div class="line">    &#125; else &#123;</div><div class="line">        transaction.hide(currentFragment).show(fragment).commit();</div><div class="line">    &#125;</div><div class="line">    currentFragment = (BaseFragment) fragment;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码理解起来非常容易，我通过 add &amp; show / hide 的方式来管理底部的四个 tab 相互切换，并且打印了这四个 Fragment 的所有生命周期方法，包括<code>onHiddenChanged</code> 和 <code>setUserVisibleHint</code></p>
<p>当第一次进入某个页面时：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-73843156f8e179ab?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首次进入某个页面时"></p>
<p>可以看到，当我依次点击下方四个 tab，界面第一次加载的时，会走 Fragment 的创建周期 onAttach – onResume，也许你会问，上面我执行相互切换操作，从第一个页面切换到第二个的时候，为什么第一个 Fragment 页面不可见了，不会调用 onPause 和 onStop 呢？</p>
<p>这是在你了解过 Activity 生命周期并且刚接触 Fragment 的生命周期时，第一个容易陷入的误区，事实上 Fragment 的生命周期，除了第一次它创建或销毁之外，统统都是由 Activity 所驱动的。 举个例子，当我点击 home 键回到桌面时：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a2f60abb148e85ed?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击 home 键"></p>
<p>可以看到我已经加载了的几个 Fragment 齐刷刷的调用了 onPause 和 onStop，如此得步调一致是因为这些 Fragment attach 的 Activity 回调了 onPause 和 onStop。相信肯定会有人说“不对啊，我要是用 replace 的方式去切换 Fragment，我打包票 Fragment 会像 Activity 一样，完整得走完生命周期“</p>
<p>你说的没错，因为 replace 这种切换方式就是始终上面我总结的那句“首次创建或销毁“，并且在 BottomNavigation 这样的使用场景中，没人会用这种 replace 的方式，因为每次切换都要重新创建 Fragment，用户看了下流量估计会打 12315 了。</p>
<p>（如果 Fragment 代表前男/女友，据说男人是用 add 保存，女人使用 replace 替换 hhh…）</p>
<p>当底部的四个 Fragment 都已经加载完成之后咧？再一起看下 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e07a6adc37fe2be8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="onHiddenChanged 回调"></p>
<p>当底部四个 Fragment 全部创建入栈之后，show 和 hide 来管理 Fragment，此时只有 <code>onHiddenChanged</code> 方法回调，这时候显然你可以在 <code>hide = false</code> 时，做一些资源回收操作，在 <code>hide = true</code> 时，做一些刷新操作。</p>
<p>在刚才我们打印的方法中，好像有一个一直没出现，没错就是 <code>setUserVisibleHint</code>，如果你做过 Fragment+ViewPager 的懒加载（下文我们会讲这个），相信你对它就比较熟悉了，通过名字就能猜测出来，这个方法是我们主动设置给 Fragment 的，那我们就来试试看：</p>
<p>改造 <code>addOrShowFragment</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 添加或者显示 fragment</div><div class="line"> *</div><div class="line"> * @param transaction</div><div class="line"> * @param fragment</div><div class="line"> */</div><div class="line">private void addOrShowFragment(FragmentTransaction transaction, Fragment fragment) &#123;</div><div class="line">    if (currentFragment == fragment)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!fragment.isAdded()) &#123; // 如果当前fragment未被添加，则添加到Fragment管理器中</div><div class="line">        transaction.hide(currentFragment).add(R.id.fl_content, fragment).commit();</div><div class="line">    &#125; else &#123;</div><div class="line">        transaction.hide(currentFragment).show(fragment).commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    currentFragment.setUserVisibleHint(false);</div><div class="line"></div><div class="line">    currentFragment = (BaseFragment) fragment;</div><div class="line"></div><div class="line">    currentFragment.setUserVisibleHint(true);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在切换时，我们对上一个 fragment <code>setUserVisibleHint</code>设置为 false，要展现的 Fragment <code>setUserVisibleHint</code> 设置为 true，打印 log 看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4449ec0891b3f069?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setUserVisibleHint"></p>
<p>可以看到目前我们用 setUserVisibleHint 也达到了与 onHiddenChanged 一样的效果。</p>
<p>文章写到现在，我们来做一个总结，上文的这种方式就是主流通过 BottomNavigation 管理 Fragment 的方式，这种方式有什么好处呢？毫无疑问会节省资源，不点开的界面不去创建它（这一点 ViewPager 做不到），只创建一次，未来仅仅更新界面数据就可以了。</p>
<h2 id="ViewPaager-amp-Fragment"><a href="#ViewPaager-amp-Fragment" class="headerlink" title="ViewPaager &amp; Fragment"></a>ViewPaager &amp; Fragment</h2><p>ViewPager 和 Fragment 配合使用相信大多数人都很熟悉了，所以来快速地给大家总结一下我认为需要梳理清楚的几个知识点，先来看我搭建的页面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9d4ecb7454abbf8f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TabLayout+ViewPager"></p>
<p>我在导航的这个模块中，搭建了一个 TabLayout+ViewPager+Fragment 的页面结构，当启动 app，进入首页，各个 Fragment 的生命周期方法是怎样的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-06aec47f6157e0aa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页和 Tab 页生命周期方法"></p>
<p>可以看到，当我进入 app 的时候，所有 TabLayout 所在的父容器 SearchFragment 创建，调用了 onAttach –&gt; onResume 这当然是我们预料之中的，我们 ViewPager 第一个装载并展示的是 ScienceFragment，ScienceFragment 创建没有问题，可是第二个 tab GameFragment 为什么加载了呢？</p>
<p>没错这就是 ViewPager 的预加载机制。</p>
<p>ViewPager 出于优化体验的好心，默认去加载相邻两页，来尽可能保证滑动的流畅性，可是假如我们这是一个新闻资讯类的 app，每一个 tab 涉及了复杂的页面和大量的网络请求，这种预加载的机制带来的可能就是麻烦了。所以我们寻找一些办法试图去掉 ViewPager 的预加载。</p>
<p>ViewPager 自身提供了一个方法，<code>mViewPager.setOffscreenPageLimit()</code>，这个方法的官方文档的解释：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b50d507d34361c7b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setOffscreenPageLimit 官方文档"></p>
<p>它的意思就是设置 ViewPager 左右两侧缓存页的数量，默认是1，那我们给它设置为0，是不是就能取消预加载了呢？再看看这段蜜汁源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-41aeb6dc992ac5b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setOffscreenPageLimit 源码"></p>
<p>总之源码的意思就是你设置为小于1的值就默认为1，反正这条路目前行不通了。</p>
<p>当然还有一个办法，你直接修改源码以后重新打一个 v4 包，不过非常不建议这样做，未来会产生一些兼容问题。</p>
<p>好吧，你应该知道马上就要说 ViewPager 的懒加载了， 就是要用到上文我们提到的 setUserVisibleHint 方法，当我左右滑动时，来看看打印的 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a1a256101fcdd443?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动时 log"></p>
<p>从 log 中可以分析到两个问题，首先 setUserVisibleHint 这个方法可能会在 onAttach 之前就调用，其次在滑动中设置缓存页数之外的页确实是销毁了。</p>
<p>回顾下前文， 明明说 setUserVisibleHint 这个方法需要主动调用，那在 ViewPager 中，Fragment 的 setUserVisibleHint 方法是谁在何时调用的呢？</p>
<p>我的 ViewPager Adapter 在这里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class MainTabAdapter extends FragmentStatePagerAdapter &#123;</div><div class="line"></div><div class="line">    private List&lt;Fragment&gt; mList;</div><div class="line"></div><div class="line">    private String mTabTitle[] = new String[]&#123;&quot;科技&quot;, &quot;游戏&quot;, &quot;装备&quot;, &quot;创业&quot;, &quot;想法&quot;&#125;;</div><div class="line"></div><div class="line">    public MainTabAdapter(FragmentManager fm, List&lt;Fragment&gt; list) &#123;</div><div class="line">        super(fm);</div><div class="line">        mList = list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Fragment getItem(int position) &#123;</div><div class="line">        return mList.get(position);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getCount() &#123;</div><div class="line">        return mList.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public CharSequence getPageTitle(int position) &#123;</div><div class="line">        return mTabTitle[position];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看来看去也就 FragmentStatePagerAdapter  能做这件事了，点进去看看：</p>
<p>FragmentStatePagerAdapter 这个类其实就是一个对 PagerAdapter 的一个封装类，不到200行的代码，果真找到了 setUserVisibleHint 。</p>
<p>有两处位置调用了 setUserVisibleHint ，第一个位置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-86b3cdad740a50ef?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="instantiateItem"></p>
<p>第二个位置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-303808d658d7e612?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setPrimaryItem"></p>
<p>这里源码处理的逻辑是这样子的：</p>
<p>在 instantiateItem 方法中，在我的数据集合中取出对应 positon 的 Fragment，直接给它的 setUserVisibleHint 设置为 false，然后才把它 add 进 FragmentTransaction 中，这恰恰解释了为什么 setUserVisibleHint 的第一次调用是在 onAttach 之前。</p>
<p>下一步 setUserVisibleHint 的设置是在 <code>setPrimaryItem</code>中，<code>setPrimaryItem</code>这个方法可以得到当前 ViewPager 正在展示的 Fragment，并且将上一个 Fragment 的 setUserVisibleHint 置为 false，将要展示的 setUserVisibleHint 置为 true。</p>
<p>通过阅读源码，我们明白了原理，所以直接给大家上在 BaseFragment 实现懒加载代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class BaseFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    protected boolean isViewCreated = false;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        return super.onCreateView(inflater, container, savedInstanceState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</div><div class="line">        super.setUserVisibleHint(isVisibleToUser);</div><div class="line">        if (getUserVisibleHint()) &#123;</div><div class="line">            lazyLoadData();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 懒加载方法</div><div class="line">     */</div><div class="line">    protected void lazyLoadData() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在具体的 Fragment 中实现懒加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class ScienceFragment extends BaseFragment &#123;</div><div class="line"></div><div class="line">    @Nullable</div><div class="line">    @Override</div><div class="line">    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_science, container, false);</div><div class="line">        Log.e(TAG, &quot;onCreateView&quot;);</div><div class="line">        isViewCreated = true;</div><div class="line">        return view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void lazyLoadData() &#123;</div><div class="line">        super.lazyLoadData();</div><div class="line">        if (isViewCreated) &#123;</div><div class="line">            Log.e(TAG, &quot;lazyLoadData...&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看下 log：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e5ca14d9d1143cba?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="懒加载 log"></p>
<p>可以看到，懒加载就这样实现了。</p>
<p>这里我们再做一个阶段总结，首先大家心里要清楚 setUserVisibleHint 这个是 ViewPager 的行为，它始终都是先行与 Fragment 的生命周期调用的。我们之所以能用懒加载这种办法，主要是因为预加载的 Fragment 已经创建完成一路调用了 onAttach –&gt; onPause，也就是说这个 Fragment 此时可用的，懒加载才有理由生效。不知道这样描述是否难懂，但是跑一下本文的例子就肯定能明白上面这段话了。</p>
<p>所以当 Fragment 第一次创建时，懒加载不会同时调用，所以我们来继续优化优化，我们让 ViewPager 一起加载这五个 Fragment 的布局，然后懒加载就全程可用啦~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mViewPager.setOffscreenPageLimit(5);</div></pre></td></tr></table></figure>
<p>此时无论是我滑动还是点击上方 tab 跳转到任意一个页面，<code>lazyLoadData</code> 方法都会调用，我们可以先加载布局出来，然后可见时刷新数据就 OK 了。</p>
<p>关于 Fragment 的管理，主要就是上文的两种方式，一是 add 和 hide 管理，二是 ViewPager + Fragment，当然具体到每个人自己的项目时，需要分析需求和产品思路找到一个适合自己的方式。当我们知道原理时，做操作就心里有底多了，出了问题也可以快速定位。</p>
<p>上面我们 ViewPager 的 adapter 使用的是 FragmentStatePagerAdapter，还有一个 FragmentPagerAdapter，因为本文的篇幅有些过长，下次会总结出它们在源码角度的区别，以及使用过程中踩到的一些坑。（如果有一些奇怪的问题无法解决，建议先使用 FragmentStatePagerAdapter）。</p>
<p><strong>写在最后：</strong></p>
<p>我们回过头来看开始那个辩题， Fragment 到底用不用？对于大多数开发者来说，当然要用，我个人其实还非常喜欢 Fragment，使用 Fragment 能体现 Android 组件化的思想，其带给开发者的便利远大于麻烦。虽然其生命周期复杂，栈又奇怪难管理，不过当正确的姿势使用 Fragment（不要嵌套 Fragment 使用），趟过一个个坑时，对 Fragment 自然也有信心了。</p>
<p>最后再上一张 Fragment 的生命周期图吧~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b0185314cdb61adc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fragment 生命周期"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>Activity 中不得不谈的 setContentView</title>
    <link href="http://yoursite.com/2016/08/19/Android%20%E4%B8%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%B0%88%E7%9A%84%20setContentView/"/>
    <id>http://yoursite.com/2016/08/19/Android 中不得不谈的 setContentView/</id>
    <published>2016-08-19T14:24:34.071Z</published>
    <updated>2016-08-24T09:25:05.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://itsmelo.github.io/" target="_blank" rel="external">Melo</a></li>
<li>审阅者：<a href="">暂无</a><br><strong>写在前面：</strong><br>几个月之前在做项目的布局优化时，使用 <strong>Hierarchy Viewer</strong> 查看项目的层级结构，然后发现顶层的布局并不是在XML中我写的根布局，而是嵌套了多层 Layout ，简单查阅了一些资料之后明白这是系统为我们加上的。把这个知识点写在了印象笔记中的 TODO list（里面还有好多知识想研究，一直在拖延T.T），搁置了好久最近重新拿出来好好研究了一下，争取做到温故知新，融会贯通嘛。</li>
</ul>
</blockquote>
<a id="more"></a>
<p>也许有的同学没看过 Hierarchy Viewer 下项目的界面布局，没关系，我现在带大家了解下。<br>新建一个 module ，打开 sdk tool 文件夹下的 Hierarchy Viewer ，布局结构展示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-cec85b655a857ea2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MainActivity界面层级"></p>
<p>先别着急找放大镜，想想我们新建项目的默认布局，按理说根布局应该是 RelativeLayout ，并且子 View 是一个 TextView 写着 “Hello World”才对啊~ <strong>多出来的这些布局层级是什么</strong>？</p>
<p>既然陌生又看不懂，那就先从我们熟悉的入手，找一下我们自己写的布局：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-972bcb0f5f20225a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RelativeLayout"></p>
<p>原来 RelativeLayout 和它的子 View TextView 在这里，看一下左下角的位置标识，红框部分指明 RelativeLayout 是 Toolbar 以下的部分。</p>
<p>再想想，我们是通过什么方法将这个布局填充到 Activity 上的呢？</p>
<p>没错是 <strong>setContentView</strong> </p>
<p>那就在 setContentView 中寻找蛛丝马迹吧</p>
<p>因为在 Android Studio 中 MainActivity 默认继承于v7包下的 AppCompatActivity ，目的是为了提供控件的向下兼容或者新控件，AppCompatActivity 也是层层继承于 Activity ，所以我们直接去看 <strong>Activity</strong> 的 <strong>setContentView</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Set the activity content from a layout resource.  The resource will be</div><div class="line"> * inflated, adding all top-level views to the activity.</div><div class="line"> *</div><div class="line"> * @param layoutResID Resource ID to be inflated.</div><div class="line"> *</div><div class="line"> * @see #setContentView(android.view.View)</div><div class="line"> * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</div><div class="line"> */</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    getWindow().setContentView(layoutResID);</div><div class="line">    initWindowDecorActionBar();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getWindow()</code> 拿到了 Activity 的成员变量 <strong>mWindow</strong> ，进而调用了 <code>setContentView()</code> 方法，mWindow 是 <strong>Window</strong> 类，继续跟进，看看 <strong>Window</strong> 类是什么</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8437b107b9f42a95?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Window类"></p>
<p>注释中的描述翻译过来就是，Window 是 视觉和行为表现的顶层抽象基类，它的实例会当作顶层视图添加进 <strong>WindowManager</strong> ， 它有一个唯一的实现类是 <strong>PhoneWindow</strong>。<br>本文我们不会去剖析 WindowManager 有哪些作用和行为，我默默地把它加入了我的 TODO list 中，拖延到什么时候就不一定了哈T.T。</p>
<p>为了防止你忘了我们在做什么和我们即将做什么，先来一个<strong>中场回顾</strong>：<br>首先我们查看布局时发现有很多“超出我们预料和理解范畴”的布局出现，跟进 <code>setContentView()</code> 方法，发现 Acitvity 中是 Window 调用了 <code>setContentView()</code> ，而抽象基类 Window 有一个唯一的实现类 PhoneWindow。不多说，来看看实现类 PhoneWindow 中的 <code>setContentView()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</div><div class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</div><div class="line">    // before this happens.</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        //初始化 DectorView 和 mContentParent</div><div class="line">        installDecor();</div><div class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        mContentParent.removeAllViews();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</div><div class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</div><div class="line">                getContext());</div><div class="line">        transitionTo(newScene);</div><div class="line">    &#125; else &#123;</div><div class="line">        //首次 setContentView 走到这里</div><div class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</div><div class="line">    &#125;</div><div class="line">    final Callback cb = getCallback();</div><div class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</div><div class="line">        cb.onContentChanged();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们没有调用 <code>setContentView()</code> 时，mContentParent （是ViewGroup） 是 null ，所以有两行代码值得我们关注 <code>installDecor()</code> 和 <code>mLayoutInflater.inflate(layoutResID, mContentParent)</code><br>首先 mContentParent 作为第二个参数传入了 inflate 方法中， 也就是说 我的布局中的 RelativeLayout 被层层解析之后的 <strong>View 视图树</strong> 作为了 mContentParent 的<strong>子 View</strong> 插入。</p>
<p>现在不知道 mContentParent 是什么没关系，继续跟进 <strong><code>installDecor()</code></strong> 方法。</p>
<p>随着API level的升高，源码发生了很多有关 Feature 、 Style 和 Wiget 的细微变化，还是蛮有意思的<br>这里我还想说一句，相信在 Android 设计之初 PhoneWindow 这个类就存在了，显然现在的这个命名有些问题，毕竟目前的设备不仅仅是 phone 了，也许改成 DeviceWindow 会比较合适<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void installDecor() &#123;</div><div class="line">    if (mDecor == null) &#123;</div><div class="line">        // new 一个 DecorView</div><div class="line">        mDecor = generateDecor();</div><div class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</div><div class="line">    &#125;</div><div class="line">    if (mContentParent == null) &#123;</div><div class="line">        //初始化 mContentParent </div><div class="line">        mContentParent = generateLayout(mDecor);</div><div class="line">        // Set up decor part of UI to ignore fitsSystemWindows if appropriate.</div><div class="line">        mDecor.makeOptionalFitsSystemWindows();</div><div class="line">        // 找到一个带ActionBar属性的布局容器 decorContentParent </div><div class="line">        final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</div><div class="line">                R.id.decor_content_parent);</div><div class="line"></div><div class="line">        if (decorContentParent != null) &#123;</div><div class="line">            mDecorContentParent = decorContentParent;</div><div class="line">            mDecorContentParent.setWindowCallback(getCallback());             </div><div class="line">            //配置UI设置</div><div class="line">            mDecorContentParent.setUiOptions(mUiOptions);</div><div class="line">        &#125;</div><div class="line">     &#125; else &#123;</div><div class="line">      if (mContentParent instanceof FrameLayout) &#123;</div><div class="line">              ((FrameLayout)mContentParent).setForeground(null);</div><div class="line">            &#125;</div><div class="line">     &#125;                   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>省略了与分析无关的代码，其中很多是对 feature 和 style 属性的一些判断和设置，首先 <code>installDecor()</code> 方法从字面意思看，很有可能是初始化加载 DecorView 的，首先看看 PhoneWindow 中两个成员变量 <strong>mDecor</strong>  和 <strong>mContentParent</strong> 分别是什么：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e0fed131805b5bf1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mDector 和 mContentParent"></p>
<p>描述的信息可以概括为 mDector 是 窗体的顶级视图，mContentParent 是放置窗体内容的容器，也就是我们 <code>setContentView()</code> 时，所加入的 View 视图树。</p>
<p>当二者为 null 时，有两行代码值得关注，分别为 <code>mDecor = generateDecor()</code> 和 <code>mContentParent = generateLayout(mDecor)</code></p>
<p>不过在此之前，先来看看这行寻找 decorContentParent 布局的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</div><div class="line">                    R.id.decor_content_parent);</div></pre></td></tr></table></figure>
<p>decor_content_parent 看起来很眼熟的样子，点击它进入布局来看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-332d077b32ef2f63?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screen_toolbar.xml"></p>
<p>为什么说 <strong>decor_content_parent</strong> 眼熟呢？打开布局查看器来看看</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b17214f45ed6067a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>在 <strong>Hierarchy Viewer</strong> 中可以看到 ActionBarOverlayLayout 的布局文件的 id 正是 <strong>decor_content_parent</strong> 不光如此 布局文件中的每个 View 节点的名称和 id 都与 <strong>Hierarchy Viewer</strong> 视图中的一一对应。再看其中的 FrameLayout 的 id 为 content ， 我们自然而然的猜测它就是我们根布局 RelativeLayout 的<strong>父布局</strong>，心里一下有了底，继续研究~</p>
<p>跟进 generateDecor() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected DecorView generateDecor() &#123;</div><div class="line">    return new DecorView(getContext(), -1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个没什么可多说的，就是为我们的窗体 new 了 一个 DecorView 。</p>
<p>再来看 generateLayout(mDecor) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">  protected ViewGroup generateLayout(DecorView decor) &#123;</div><div class="line">      // Apply data from current theme.</div><div class="line">      // 获得窗体的 style 样式</div><div class="line">      TypedArray a = getWindowStyle();</div><div class="line">         </div><div class="line">      // 省略大量无关代码</div><div class="line">                          </div><div class="line">      // Inflate the window decor.</div><div class="line">      int layoutResource;</div><div class="line">      int features = getLocalFeatures();</div><div class="line"></div><div class="line">      //填充带有 style 和 feature 属性的 layoutResource (是一个layout id)</div><div class="line"></div><div class="line">      View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line"></div><div class="line">      // 插入的顶层布局 DecorView 中</div><div class="line"></div><div class="line">      decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">      mContentRoot = (ViewGroup) in;</div><div class="line"></div><div class="line">      // 找到我们XML文件的父布局 contentParent </div><div class="line"></div><div class="line">      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">      if (contentParent == null) &#123;</div><div class="line">          throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">      &#125;</div><div class="line">// 省略无关代码</div><div class="line">      mDecor.finishChanging();</div><div class="line">      // 返回 contentParent 并赋值给成员变量 mContentParent</div><div class="line">      return contentParent;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这个方法的代码有300多行，剔除了很多无关代码，我们分模块来看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">View in = mLayoutInflater.inflate(layoutResource, null);</div><div class="line">    decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</div><div class="line">    mContentRoot = (ViewGroup) in;</div></pre></td></tr></table></figure>
<p>首先 layoutResource 是系统的 xml 布局文件的 id，里面有我们设置窗体的 features 和 style 属性，然后通过 <code>decor.addView</code> 添加进 mDector 视图。这里也是我们要在 <code>setContentView()</code> 之前执行<code>requestWindowFeature()</code> 才可以的原因</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</div><div class="line">    if (contentParent == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Window couldn&apos;t find content container view&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Remaining setup -- of background and title -- that only applies</div><div class="line">    // to top-level windows.</div><div class="line">   </div><div class="line">    mDecor.finishChanging();</div><div class="line"></div><div class="line">    return contentParent;</div></pre></td></tr></table></figure>
<p>关键点来了， <code>ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</code><br>通过 findViewById 找到系统修饰布局文件中 id 为：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-81b5ec907ab9dbf5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>这个 id 是不是非常眼熟，与我们上文的猜测不谋而合，这就是我们一直在寻找的作为 <strong>activity_main</strong> 的父布局的 <strong>FrameLayout</strong> </p>
<p>我们在布局文件查看器中再找一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-46e6acb79d3bb7db?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容器 FrameLayout id = content"></p>
<p>return contentParent 这一步就返回了我们的成员变量 <strong>mContentParent</strong> </p>
<p>到现在为止其实整个知识点主干的逻辑已经走完了，为大家花了一张简单的思维导图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-87182e07c37ac78e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用逻辑"></p>
<p>并不复杂，线性逻辑调用还是蛮清晰的。</p>
<p>不过相信你也许会问，上文你仅仅提到了两个布局呀，一个顶层的 <strong>DecorView</strong> 和 我们布局文件的父布局 <strong>FrameLayout</strong> ，而查看布局层级时，为什么有这么多其他这么多额外的布局呢？</p>
<p>因为随着 Android API level 的不断变化，组件也在随之增多，比如 ActionBar Toolbar 等等，这些组件相关的布局是否加载与你的 <strong>feature</strong> 设置设备的特性相关联，而且版本不同，布局文件的<strong>层级结构</strong>也在不断变化着丰富着，我这个是 API22 的源码，我做了一些对比，有许多代码细节是不一样的，比如在这里的 <strong>feature</strong> 就新增了 Toolbar ，但是大体上的逻辑框架肯定不会变<br>比如我们目前的 MainActivity 的视图主要有两大分支，一条设置 Toolbar 的相关配置，一条就是我们的 RelativeLayout 了。</p>
<p><strong>写在后面：</strong><br>写这篇博客的原因一是我自己要研究梳理总结这个知识点，二是想让大家明白，Android 版本之间的迭代很快，一年前的博客阐述的观点到今天可能就再不适用了，但是 PhoneWindow 管理布局视图的这套逻辑框架，却一直没怎么改变。通过阅读源码，可以学习 Google 工程师们良好的代码风格，汲取他们搭建框架的思想，让我们自己写的代码也能如此健壮。</p>
<p><strong>PS： PhoneWindow 什么时候能改个名字啊！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;文章来源：itsCoder 的 &lt;a href=&quot;https://github.com/itsCoder/weeklyblog&quot;&gt;WeeklyBolg&lt;/a&gt; 项目&lt;/li&gt;
&lt;li&gt;itsCoder主页：&lt;a href=&quot;http://itscoder.com/&quot;&gt;http://itscoder.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;作者：&lt;a href=&quot;https://itsmelo.github.io/&quot;&gt;Melo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;审阅者：&lt;a href=&quot;&quot;&gt;暂无&lt;/a&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;几个月之前在做项目的布局优化时，使用 &lt;strong&gt;Hierarchy Viewer&lt;/strong&gt; 查看项目的层级结构，然后发现顶层的布局并不是在XML中我写的根布局，而是嵌套了多层 Layout ，简单查阅了一些资料之后明白这是系统为我们加上的。把这个知识点写在了印象笔记中的 TODO list（里面还有好多知识想研究，一直在拖延T.T），搁置了好久最近重新拿出来好好研究了一下，争取做到温故知新，融会贯通嘛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="setContentView" scheme="http://yoursite.com/tags/setContentView/"/>
    
  </entry>
  
  <entry>
    <title>开发一个Android应用之前，应该考虑点什么？</title>
    <link href="http://yoursite.com/2016/08/12/%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid%E5%BA%94%E7%94%A8%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E7%82%B9%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2016/08/12/开发一个Android应用之前，应该考虑点什么/</id>
    <published>2016-08-12T08:33:18.120Z</published>
    <updated>2016-08-12T08:33:18.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发一个Android应用之前，应该考虑点什么？"><a href="#开发一个Android应用之前，应该考虑点什么？" class="headerlink" title="开发一个Android应用之前，应该考虑点什么？"></a>开发一个Android应用之前，应该考虑点什么？</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-e22b0058b534ace3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><a id="more"></a><br><strong>写在前面：</strong><br>昨天参加了秋百万大大组织的北京<strong>GDG</strong>活动，收获颇丰。又跟几个有写作习惯的朋友建立了一个“神秘组织”，每两周为一个周期，每人都会产出一篇原创的文章，互相校验和探讨，意在督促组员之间学习和分享开源技术。而简书上的平台就交给我维护了，不出意外，几天之内大家就可以看到我们的主页和第一期成员的文章啦，<strong>敬请期待~</strong></p>
<p>前几天接手了一个老员工遗留下来的代码，别提多痛苦了，甚至有了让我推倒重写的冲动，很多地方的设计问题颇多，老大也快无法忍受了。。。上学的时候写一篇作文，要想好主题立意和分段，解数学题的时候也得在草稿纸上梳理清楚逻辑之后再下笔。其实开发一个Android也应是如此，不做准备，埋头苦写，最后会导致问题颇多。所以本文会<strong>根据网络上优秀内容和我实际的开发经验</strong>讨论总结一下，<strong>开发一个Android应用之前，都应该做哪些准备</strong>。</p>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a><strong>编码规范</strong></h2><p><strong>编码规范</strong>的问题是我最先想强调的，因为我接手的项目命名就极其混乱，甚至在一个类中的命名都没有统一化（生无可恋脸）。代码可能不是你自己一个人写，<strong>保证代码可读性</strong>是非常必要的。而规范存在的意义就是淡化每个人的习惯而达到统一。不多说，下面就介绍<strong>Android的编码规范</strong>。</p>
<ul>
<li>除了注释，代码中不出现中文</li>
<li>每个类写上必要的注释，类的说明，作者，联系方式</li>
<li>方法加上必要的注释说明，方便以后维护</li>
</ul>
<p><strong>包管理</strong></p>
<ul>
<li>base:存放基础类的包，里面的类以Base为前缀，例如BaseActivity；</li>
<li>activity:存放activity的包，每个activity命名以Activity结尾，例如MainActivity;</li>
<li>fragment:存放fragment的包，每个fragment命名以Fragment结尾，例如ChatFragment;</li>
<li>receiver:存放receiver的包；</li>
<li>service:存放service的包；</li>
<li>adapter:存放adapter的包，每个adapter命名以Adapter结尾，例如EventItemAdapter;</li>
<li>common:存放一些公共常量，例如后端接口、SharedPreferenceKey、IntentExtra等;</li>
<li>utils:存放工具类的包，比如常见的工具类：LogUtils、DateUtils；</li>
<li>entity:存放实体类的包；</li>
<li>widget:存放自定义View的包；</li>
</ul>
<p>以上是一些常见的包，但不局限于此，视项目的具体情况而定。</p>
<p><strong>命名</strong></p>
<p><strong>大驼峰命名(UpperCamelCase)：每个单词的第一个字母都大写。</strong></p>
<p><strong>小驼峰命名(lowerCamelCase)：除第一个单词以外，每一个单词的第一个字母大写。</strong></p>
<p><strong>命名的基本原则:</strong></p>
<ul>
<li>尽可能地使用统一的命名规范；</li>
<li>不使用汉语拼音；</li>
<li>除了常见的英文缩写，尽量少地使用缩写；</li>
</ul>
<p><strong>包命名</strong></p>
<ul>
<li>小写字母，参见上文包管理；</li>
<li>连续的单词直接连接起来，不使用下划线；</li>
</ul>
<p><strong>Java类命名</strong></p>
<ul>
<li>大驼峰命名 UserListAdapter；</li>
<li>除常见的缩写单词以外，不使用缩写，缩写的单词每个字母都大写 RequesURLList；</li>
<li>公共的工具类建议以Utils、Manager为后缀，如LogUtils；</li>
<li>接口命名遵循以上原则，以able或ible为后缀；</li>
</ul>
<p><strong>变量命名</strong></p>
<ul>
<li>成员变量命名<ul>
<li>小驼峰命名；</li>
<li>不推荐使用谷歌的前面加m的编码风格（如果使用团队中使用m，则统一使用）；</li>
</ul>
</li>
<li>常量命名<ul>
<li>单词每个字母均大写；</li>
<li>单词之间下划线连接；</li>
</ul>
</li>
<li>控件变量命名<ul>
<li>小驼峰命名；</li>
<li>建议使用 控件缩写+逻辑名称 格式，例如 tvPostTitle、etUserName；</li>
<li>对应的控件的id的命名控件缩写_逻辑名称，单词均小写，用下划线连接，例如：tv_post_title、</li>
<li>et_user_name；</li>
</ul>
</li>
<li>常见的控件缩写如下：<br>控件 缩写<br>Linearlayout    ll<br>RelativeLayout    rl<br>TextView    tv<br>EditText    et<br>Button    btn<br>ImageView    iv<br>CheckBox    chb<br>ListView    lv<br>GridView    gv<br>RadioButton    rb</li>
</ul>
<p><strong>方法命名</strong></p>
<ul>
<li>小驼峰命名；</li>
<li>Getter和Setter方法，推荐使用自动生成的，写起来也很方便。注意，bool类型的变量Getter方法写成isTrue这种；</li>
<li>方法名应当保证见名知义的原则，尽量不使用or或者and，遵循“do one thing”原则；</li>
</ul>
<p><strong>布局文件命名</strong></p>
<ul>
<li>activity、fragment布局文件名以对应的类别名称为前缀，逻辑名称放在其后，以下划线连接，例如activity_home、fragment_chat_list，方便查找；</li>
<li>ListView、GridView的item布局文件建议以list_item、gird_item为前缀，加上对应的逻辑名称，例如<br>list_item_post、grid_item_photo；</li>
<li>Dialog的布局文件以dialog为前缀，逻辑名称放在其后，下划线连接，例如dialog_warnning;<br>包含项布局命名以include开头，在加上对应的逻辑名称，例如include_foot</li>
<li>控件的id命名参见控件变量命名；</li>
</ul>
<p><strong>资源命名</strong></p>
<ul>
<li>图标资源以ic为前缀，例如ic_chat，指聊天图标；</li>
<li>背景图片以bg为前缀，例如bg_login，指的是登录页的背景图；</li>
<li>按钮图片以btn为前缀，例如btn_login，指的是登录按钮的图片，不过这只有一种状态，需要加上状态的可以在后面添加，例如btn_login_pressed，表示登录按钮按下的图片；</li>
<li>当使用shape和selector文件为背景或者按钮时，命名参照以上说明；</li>
</ul>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a><strong>项目架构</strong></h2><p><strong>项目框架</strong><br>一个好的项目架构可以降低项目的复杂性，并且易扩展、易维护，耦合低，结构清晰，功能内聚。<br><strong>MVC</strong>，<strong>MVP</strong>，<strong>MVVM</strong>还有一些设计模式，结合你app的业务，自行选择一个最合适的一条路走到黑，建议不要“混搭”。</p>
<p><strong>开源框架</strong></p>
<p>开源框架的选择分两大类，一是权威性毫无争议，放心选择的这类帮助我们快速开发的，比如：</p>
<ul>
<li>网络 Retrofit + OkHttp+ RxJava、Volley、android-async-http</li>
<li>依赖注入 Dagger2、ButterKnife、RoboGuice</li>
<li>事件总线 otto、EventBus</li>
<li>图片加载 Fresco、Glide、Picasso</li>
<li>数据库 GreenDao、Ormlite、LitePal</li>
<li>日志输出 logger、LogUtils</li>
<li>当然不能忘了Google提供的兼容support全家桶</li>
</ul>
<p>还有一类框架虽然不是毫无争议，但是也能极大节省我们的时间，提升开发效率，对于这类项目，要在Github上长期<strong>淘宝</strong>了。找那种star很多，issues解决很快，长期维护的项目，这种坑会比较少。</p>
<h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a><strong>代码细节</strong></h2><p><strong>抽取基类</strong><br>即使目前你没有需要，也一定要抽取一个BaseActivity和BaseFragment，因为早晚会用到，切记！<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseActivity extends Activity&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123;</div><div class="line">        super.onCreate(savedInstanceState, persistentState);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void init() &#123;</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        initView();</div><div class="line">        initData();</div><div class="line">        initListener();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化布局</div><div class="line">     */</div><div class="line">    protected abstract void initView();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化数据</div><div class="line">     */</div><div class="line">    protected  abstract void initData();</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 初始化侦听</div><div class="line">     */</div><div class="line">    protected abstract void initListener();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BaseFragment也同理，随着业务的增加和抽象，基类会继续扩展。其实不仅仅是<strong>BaseActivity</strong>和<strong>BaseFragment</strong>，如果你一个业务模块中有很多相似和相同的逻辑，也可以抽取一个<strong>BaseXXX</strong>这是非常好的一个习惯。</p>
<p>还有一些建议，不做展开，大家请自行搜索：</p>
<ul>
<li>Android Studio上好用的插件</li>
<li>selector</li>
<li>图片的.9处理</li>
<li>Resources xml文件中，记得用注释分割每个类用到的资源，建议不共用</li>
<li>慎用static关键字</li>
<li>定期code review，不断代码重构</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>推荐一个我曾经写过的总结：</p>
<p><a href="http://www.jianshu.com/p/be05874965d4" target="_blank" rel="external">Android性能优化总结</a></p>
<p><strong>写在后面：</strong></p>
<p>本文做了一个初步总结，未来会慢慢扩展和完善，如果有遗漏，大家可以补充~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发一个Android应用之前，应该考虑点什么？&quot;&gt;&lt;a href=&quot;#开发一个Android应用之前，应该考虑点什么？&quot; class=&quot;headerlink&quot; title=&quot;开发一个Android应用之前，应该考虑点什么？&quot;&gt;&lt;/a&gt;开发一个Android应用之前，应该考虑点什么？&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-e22b0058b534ace3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="规范" scheme="http://yoursite.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="开源库" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Activity的生命周期，你足够了解吗？</title>
    <link href="http://yoursite.com/2016/08/01/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%BD%A0%E8%B6%B3%E5%A4%9F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/08/01/Activity的生命周期，你足够了解吗？/</id>
    <published>2016-08-01T09:51:11.192Z</published>
    <updated>2016-08-01T09:52:46.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Activity的生命周期，你足够了解吗？"><a href="#Activity的生命周期，你足够了解吗？" class="headerlink" title="Activity的生命周期，你足够了解吗？"></a>Activity的生命周期，你足够了解吗？</h1><p><strong>写在前面：</strong><br>对于Activity的生命周期，相信只要已经接触过Android的同学，一定可以说出个大概，因为Activity的生命周期真的是太重要的机制了。不过在开发中，我们在每个生命周期方法应该做些什么，还有一些比较关键的知识细节也许你还不清楚，所以本文会带着大家再来探寻一次Activity的生命周期。<br><img src="http://upload-images.jianshu.io/upload_images/1915184-ce9b7e9c5b9796ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><a id="more"></a><br>最近又到了校招的季节，假设你在面试的时候遇到了一个<strong>穿着拖鞋、衣衫褴褛</strong>的Android面试官，拿着你的简历，眉头深锁，对着简历上面<strong>“精通Activity的生命周期和启动模式”</strong>的这句话，问了你以下几个问题：</p>
<ul>
<li><p>onSaveInstanceState方法在Activity的哪两个生命周期方法之间调用？</p>
</li>
<li><p>弹出一个Dialog时，onPause会调用吗？什么情况下会，什么情况下不会？</p>
</li>
<li><p>横竖屏切换的时候，生命周期方法是如何调用的？如何进行配置呢？</p>
</li>
<li><p>Activity调用了onDestory方法，就会在Activity的任务栈消失吗？</p>
</li>
<li><p>永久性质的数据，应该在哪个生命周期方法中保存？</p>
</li>
<li><p>在onCreate或者onRestoreInstance方法中恢复数据时，有什么区别？</p>
</li>
</ul>
<p>如何这些问题你都能回答出来并且懂得原理的话，好吧，你可以点击浏览器的右上角了~如果并没有<strong>完完全全理解Activity的生命周期</strong>，那么继续往下看。</p>
<h2 id="Activity生命周期的回调意义"><a href="#Activity生命周期的回调意义" class="headerlink" title="Activity生命周期的回调意义"></a>Activity生命周期的回调意义</h2><p><strong>直接上图：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-eb9b1e13d3636e78?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的生命周期方法"></p>
<p>相信找张图你百分百看过，我来简略的介绍一下Activity的生命周期：</p>
<ol>
<li><p><strong>onCreate和onDestory</strong><br>分别代表了一个Activity的<strong>创建和销毁</strong>、第一个生命周期和最后一个生命周期回调，期间包裹了一个<strong>完整</strong>(entire lifetime)的Activity生命周期。</p>
</li>
<li><p><strong>onStart和onStop</strong><br>分别代表了Activity已经处于<strong>可见状态和不可见状态</strong>，此时的Activity未处在前台，<strong>不可以与用户交互</strong>，可多次被调用，期间Activity处于可见(visable lifetime)状态。</p>
</li>
<li><p><strong>onResume和onPause</strong><br>分别代表了Activity已经进入前台获得焦点和退出前台失去焦点，此时的Activity是可以和<strong>用户交互的</strong>，可多次被调用，期间的Activity处于前台(foreground lifetime)状态。</p>
</li>
<li><p><strong>onRestart</strong><br>表示Activity正在重新启动，正常状态下，Acitivty调用了onPause–onStop但是并没有被销毁，重新显示此Activity时，onRestory会被调用。</p>
</li>
</ol>
<p>好了在毫无新鲜感的痛苦中，上面人尽皆知的Acitivty生命周期方法终于被我介绍完了~本文不再去写Demo来分析比如A和B相互启动，或者点击Back或者Home键时，Activity生命周期方法的调用，因为我相信你如果<strong>真正理解了上面的Activity的生命周期方法的含义</strong>，这些都可以分析出来。</p>
<h2 id="每个生命周期方法都应该干点啥？"><a href="#每个生命周期方法都应该干点啥？" class="headerlink" title="每个生命周期方法都应该干点啥？"></a>每个生命周期方法都应该干点啥？</h2><ol>
<li><p><strong>onCreate</strong><br>这个方法是在Activity的此生中第一次也会是唯一一次调用，所以在这个方法中，我们应该去初始化一些总体资源比如<strong>setContentView</strong>或者加载一些关于这个Activity的<strong>全局数据</strong>。</p>
</li>
<li><p><strong>onStart</strong><br>这个生命周期方法会被重复调用中，也可以加载一些当Activity可见时，才需要加载的数据，或者注册一个广播，监听UI的变化来刷新界面。</p>
</li>
<li><p><strong>onResume</strong><br>当Activity获取焦点时，这个方法会被回调，<strong>十分轻量级</strong>，最好做一些轻量级的数据加载和布置，这些数据的变动应该是处在onResume—onPause这个生命圈之内的。</p>
</li>
</ol>
<ol>
<li><p><strong>onPause</strong> onPause方法是我绝对想跟大家强调的一个方法，首先onPause方法绝对不可以进行<strong>太耗时的操作</strong>，或者一些<strong>重量级的释放操作</strong>，因为这会影响下一个Activity进入前台与用户交互。也就是说，只有onPause方法调用完毕，下一个Activity的onStart才会调用。<br>在一些永久数据保存上，找到了这样的一段描述：</p>
<blockquote>
<p>onPause(), onStop(), onDestroy() are “killable after” lifecycle methods. This indicates whether or not the system can kill the<br>process hosting the activity at any time after the method returns,<br>without executing another line of the activity’s code. Because<br>onPause() is the first of the three, once the activity is created,<br>onPause() is the last method that’s guaranteed to be called before<br>the process can be killed—if the system must recover memory in an<br>emergency, then onStop() and onDestroy() might not be called.<br>Therefore, you should use onPause() to write crucial persistent data<br>(such as user edits) to storage. However, you should be selective<br>about what information must be retained during onPause(), because<br>any blocking procedures in this method block the transition to the<br>next activity and slow the user experience.</p>
</blockquote>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得onPause是<strong>持久化相关数据</strong>的最后的可靠时机。</p>
<p>所以比如你要写入数据库的数据，就可以放到onPause保存，关于一些其他细节，推荐大家看一看我以前总结的一篇文章：</p>
</li>
</ol>
<ol>
<li><strong>onStop和onDestory</strong><br>在onStop和onDestory我们通常都会做一些<strong>释放资源相关</strong>的操作，当然这个资源的释放是与onStart和onCreate相匹配的，毕竟他们是成对出现的。</li>
</ol>
<p>画一张简单的图来表达含义：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-f3a075db34bdaf6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用法解析"></p>
<p>PS：Activity被翻译成活动，其实不如翻译成<strong>“界面”</strong>更容易贴切，所以与界面展示相关资源的初始化，可以放到Activity中进行。而有些<strong>重量级</strong>的资源，与<strong>界面无关的</strong>，并且与<strong>进程同生共死</strong>，可以考虑放在<strong>Application中的onCreate</strong>方法中进行初始化。</p>
<h2 id="开始填坑"><a href="#开始填坑" class="headerlink" title="开始填坑"></a>开始填坑</h2><p>觉得大家应该比较容易理解以上的内容，那么就开始把文章开头问题的坑给填上吧~</p>
<p><strong>onSaveInstanceState方法在Activity的哪两个生命周期方法之间调用？</strong></p>
<p>其实onSaveInstanceState方法与onPause方法的调用顺序没有先后之分，你需要记住的是，onSaveInstanceState一定在<strong>onStop方法之前</strong>调用。</p>
<p><strong>弹出一个Dialog时，onPause会调用吗？什么情况下会，什么情况下不会？</strong></p>
<p>首先，如果你弹出的是本Activity的Dialog，并不会有任何生命周期方法调用。你肯定不服并且说：应该是onPause方法调用，明明Activity不可点击了嘛！<br>我想说的是，Dialog是一个<strong>View</strong>，它本身就<strong>依附在Acitivty</strong>上，可以理解为是<strong>属于</strong>本Activity的，<strong>所以它的焦点也自然是本Activity的焦点</strong>，自然不会有什么生命周期方法调用了。<br>如果<strong>其他Activity</strong>的Dialog弹出了，onPause才会调用。</p>
<p><strong>横竖屏切换的时候，生命周期方法是如何调用的？如何进行配置呢？</strong></p>
<p>横竖屏切换时，如果不做任何配置，生命周期方法的回调顺序为：</p>
<blockquote>
<p>onPause–onSaveInstanceState–onStop–onDestory–onCreate–onStart–onResume</p>
</blockquote>
<p>也就是说Activity被销毁并重建了。如果不想这样可以在清单文件中的Activity添加一行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;</div></pre></td></tr></table></figure>
<p>此时再切换横竖屏，就不会销毁并再次创建了。</p>
<p><strong>在onCreate或者onRestoreInstance方法中恢复数据时，有什么区别？</strong></p>
<p>当onRestoreInstance调用时，其中的bundle参数必然不为空，而使用onCreate恢复数据时，bundle也许是空的，所以要进行一下非空判断。</p>
<p><strong>Activity调用了onDestory方法，就会在Activity的任务栈消失吗？</strong></p>
<p>什么时候onDestory会被调用呢？</p>
<p>可以分为两大类嘛：1.点击了back键 2.Activity被意外销毁</p>
<p>点击back键相当于调用了finish()方法，通常来说finish<br>方法会至少有两个目的，一是将Activity从返回栈中退出，二是调用onDestory方法（未必是及时调用）<br>而直接调用onDestory，是不会将Activity在任务栈中清除的。</p>
<p><strong>写在后面：</strong><br>不知不觉本文就要结束了，Android是一个<strong>复杂而有机的整体</strong>，关于Activity 的生命周期方法，可继续研究的知识非常多，在未来会给大家从源码上分析Activity 的创建流程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Activity的生命周期，你足够了解吗？&quot;&gt;&lt;a href=&quot;#Activity的生命周期，你足够了解吗？&quot; class=&quot;headerlink&quot; title=&quot;Activity的生命周期，你足够了解吗？&quot;&gt;&lt;/a&gt;Activity的生命周期，你足够了解吗？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;对于Activity的生命周期，相信只要已经接触过Android的同学，一定可以说出个大概，因为Activity的生命周期真的是太重要的机制了。不过在开发中，我们在每个生命周期方法应该做些什么，还有一些比较关键的知识细节也许你还不清楚，所以本文会带着大家再来探寻一次Activity的生命周期。&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-ce9b7e9c5b9796ce?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>ActivityThread的main方法究竟做了什么？</title>
    <link href="http://yoursite.com/2016/07/28/ActivityThread%E7%9A%84main%E6%96%B9%E6%B3%95%E7%A9%B6%E7%AB%9F%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/07/28/ActivityThread的main方法究竟做了什么？/</id>
    <published>2016-07-28T02:38:32.727Z</published>
    <updated>2016-07-28T02:39:14.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ActivityThread的main方法究竟做了什么？"><a href="#ActivityThread的main方法究竟做了什么？" class="headerlink" title="ActivityThread的main方法究竟做了什么？"></a>ActivityThread的main方法究竟做了什么？</h1><p><strong>写在前面：</strong><br>在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-0dd4fc7c8f275bd3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="轻松一下"></p>
<p><strong>问大家一个问题：</strong></p>
<p>Android中一个应用程序的<strong>真正入口</strong>是什么？</p>
<p><strong>无论你知道不知道，别着急回答，再问大家一个问题：</strong></p>
<p>Android不能像java一样直接跑在<strong>main方法</strong>的原因是什么？</p>
<p>Android应用程序的载体是APK文件，它本质上，是一个<strong>资源和组件的容器</strong>，APK文件和我们常见的<strong>可执行文件</strong>的区别在何处？</p>
<p>每个可执行文件运行在一个进程中，但是APK文件可能运行在一个单独的进程，也可以和其他APK运行在同一进程中，结合上面，我想表达的是：</p>
<p><strong>Android系统的设计理念就是弱化进程，取而代之是组件的概念。</strong></p>
<p>但是我们都知道，Android系统基于<strong>Linux</strong>系统之上，而Linux系统的运行环境恰恰就是由<strong>进程</strong>组成。所有的Android应用进程都是有Zygote进程fork出来的，因此构成进程的地层系统、虚拟机、动态库等，都是相同的。</p>
<p>当然Android除了继承从Zygote中得到的某些基础的“家当”之外，Android还需要在应用的Java层建立一套框架来管理运行的组件。由于每个应用的配置都不相同，因此不能再Zygote中完全建立好再继承，只能在应用启动时创建。</p>
<p><strong>这套框架就构成了Android应用的基础。</strong></p>
<p>而这套框架有很多核心类，比如：</p>
<p><strong>ActivityThread</strong>、<strong>ApplicationThread</strong>、<strong>Context</strong>、<strong>ActivityManagerService</strong>等等。这里我先给自己挖一个坑，将来慢慢填上，争取清晰简洁的给大家讲明白<strong>Android的组件管理</strong>。</p>
<p>而今天，我们现在聊聊<strong>ActivityThread</strong>的<strong>main</strong>方法</p>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><p>好像忘了点什么。。。</p>
<p>对对，回头看看，我们还有两个问题没解答呢，整个Android应用进程的体系非常复杂，而ActivityThread是真正的核心类，它的<strong>main方法</strong>，是<strong>整个应用进程的入口</strong>。</p>
<p>所以当有人问你应用进程的真正入口是什么，你回答“Activity 的 onCreate 方法”显然就没理解这个问题的意思。</p>
<p>而第二个问题，相信你心里肯定知道大概怎么回答，我们的一个Android应用程序可以是理解为是<strong>四大组件和各种资源的集合</strong>，它需要各种各样的环境资源，当然不能像Java直接跑在main方法里面。</p>
<p>而今天我们就来看看ActivityThread的main方法究竟做了些什么。</p>
<p>在此之前，安利一个看源码的网站，非常不错</p>
<p><a href="http://grepcode.com/" target="_blank" rel="external">http://grepcode.com/</a></p>
<p>点击进去类名就可以查看源码了</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a143e41ffdd1b71a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="成员变量"></p>
<p>ActivityThread的源码有5000多行，显然我没能力弄懂它每一行代码的意思，不过我们只要知道它大体上负责着什么功能和职责，就可以了。</p>
<p>看看上图中的成员变量，在给大家上一个图，就能理解<strong>ActivityThread管理着</strong>什么。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b76be1a1e19381df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityThread类的对象的关联图"></p>
<p>从图中可以知道，<strong>mActivities</strong>、<strong>mServices</strong>和<strong>mProviderMap</strong> 这三个变量都被保存在<strong>ArrayMap</strong>之中，他们分别保存了应用中所有的<strong>Activity</strong>对象、<strong>Services</strong>对象、和<strong>ContentProvider</strong>对象。 咦？同为四大组件的BroadcastReceive去哪里了？注意，BroadcastReceiver对象没有必要用任何数据结构来保存，因为BroadcastReceiver对象的生命周期很短暂，属于我调用它时，再创建运行，因此不需要保存<strong>BroadcastReceiver</strong>的对象。</p>
<p>我们都知道应用中Applicaiton对象是唯一的，而<strong>mInitialApplication</strong>变量是恰恰是Application对象。当你的应用自定义一个派生Applicaiton类，则它就是mInitialApplication了。</p>
<p><strong>ApplicationThread</strong>类型变量mAppThread是一个<strong>Binder</strong>实体对象，<strong>ActivityManagerService</strong>作为Client端调用ApplicationThread的接口，目的是用来调度管理Activity，这个我们未来会细说。</p>
<p>变量<strong>mResourcesManager</strong>管理着应用中的资源。</p>
<p>一口气说了这么多，怎么样，ActivityThread是不是相当于一个CEO，管理调度着几乎所有的<strong>Android应用进程的资源和四大组件</strong></p>
<p>上面非常多的问题我未来会给大家慢慢解答，因为篇幅太长反而会影响阅读和知识的吸收，话不多说，<strong>来看看入口方法main都做了些什么</strong>？</p>
<h2 id="ActivityThread的main方法"><a href="#ActivityThread的main方法" class="headerlink" title="ActivityThread的main方法"></a>ActivityThread的main方法</h2><p>感兴趣的同学去刚才给出的网站上搜搜ActivityThread的类，大致浏览一下，这里先贴出<strong>main方法</strong>的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">public static void More ...main(String[] args) &#123;</div><div class="line">5220        SamplingProfilerIntegration.start();</div><div class="line">5221</div><div class="line">5222        // CloseGuard defaults to true and can be quite spammy.  We</div><div class="line">5223        // disable it here, but selectively enable it later (via</div><div class="line">5224        // StrictMode) on debug builds, but using DropBox, not logs.</div><div class="line">5225        CloseGuard.setEnabled(false);</div><div class="line">5226		// 初始化应用中需要使用的系统路径</div><div class="line">5227        Environment.initForCurrentUser();</div><div class="line">5228</div><div class="line">5229        // Set the reporter for event logging in libcore</div><div class="line">5230        EventLogger.setReporter(new EventLoggingReporter());</div><div class="line">5231		//增加一个保存key的provider</div><div class="line">5232        Security.addProvider(new AndroidKeyStoreProvider());</div><div class="line">5233</div><div class="line">5234        // Make sure TrustedCertificateStore looks in the right place for CA certificates</div><div class="line">			//为应用设置当前用户的CA证书保存的位置</div><div class="line">5235        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</div><div class="line">5236        TrustedCertificateStore.setDefaultUserDirectory(configDir);</div><div class="line">5237		//设置进程的名称</div><div class="line">5238        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);</div><div class="line">5239</div><div class="line">5240        Looper.prepareMainLooper();</div><div class="line">5241		//创建ActivityThread 对象</div><div class="line">5242        ActivityThread thread = new ActivityThread();</div><div class="line">5243        thread.attach(false);</div><div class="line">5244</div><div class="line">5245        if (sMainThreadHandler == null) &#123;</div><div class="line">5246            sMainThreadHandler = thread.getHandler();</div><div class="line">5247        &#125;</div><div class="line">5248</div><div class="line">5249        if (false) &#123;</div><div class="line">5250            Looper.myLooper().setMessageLogging(new</div><div class="line">5251                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">5252        &#125;</div><div class="line">5253</div><div class="line">5254        Looper.loop();</div><div class="line">5255</div><div class="line">5256        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">5257    &#125;</div></pre></td></tr></table></figure>
<p>代码并不多，但是条条关键，这些操作我都为大家写了注释，看一下就知道程序在做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Looper.prepareMainLooper();</div><div class="line">//创建ActivityThread 对象</div><div class="line">      ActivityThread thread = new ActivityThread();</div><div class="line">      thread.attach(false);</div><div class="line">      </div><div class="line">      if (sMainThreadHandler == null) &#123;</div><div class="line">           sMainThreadHandler =thread.getHandler();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (false) &#123;</div><div class="line">          Looper.myLooper().setMessageLogging(new</div><div class="line">                  LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</div><div class="line">      &#125;</div><div class="line">	</div><div class="line">      Looper.loop();</div><div class="line">	</div><div class="line">      throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这几行代码拿出来单独讲解一下，首先Looper.prepareMainLooper();是为主线程创建了Looper，然后thread.getHandler();是保存了主线程的Handler，最后Looper.loop();进入消息循环。</p>
<p>如果不了解Android的消息机制，大家可以来看看以前我写的文章来了解一下：</p>
<p><a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">Android消息机制详解</a></p>
<p>马上就要大功告成了，最后还剩下一行代码还没解释：</p>
<p>thread.attach(false);</p>
<p>继续跟进attach方法，一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">			if (!system) &#123;</div><div class="line">5080            ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</div><div class="line">5081                @Override</div><div class="line">5082                public void More ...run() &#123;</div><div class="line">5083                    ensureJitEnabled();</div><div class="line">5084                &#125;</div><div class="line">5085            &#125;);</div><div class="line">5086            android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</div><div class="line">5087                                                    UserHandle.myUserId());</div><div class="line">//将mAppThread放到RuntimeInit类中的静态变量</div><div class="line">5088            RuntimeInit.setApplicationObject(mAppThread.asBinder());</div><div class="line">5089            final IActivityManager mgr = ActivityManagerNative.getDefault();</div><div class="line">5090            try &#123;</div><div class="line">					//将mAppThread传入ActivityThreadManager中</div><div class="line">5091                mgr.attachApplication(mAppThread);</div><div class="line">5092            &#125; catch (RemoteException ex) &#123;</div><div class="line">5093                // Ignore</div><div class="line">5094            &#125;</div><div class="line">5095            // Watch for getting close to heap limit.</div><div class="line">5096            BinderInternal.addGcWatcher(new Runnable() &#123;</div><div class="line">5097                @Override public void More ...run() &#123;</div><div class="line">5098                    if (!mSomeActivitiesChanged) &#123;</div><div class="line">5099                        return;</div><div class="line">5100                    &#125;</div><div class="line">5101                    Runtime runtime = Runtime.getRuntime();</div><div class="line">5102                    long dalvikMax = runtime.maxMemory();</div><div class="line">5103                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</div><div class="line">5104                    if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123;</div><div class="line">5105                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024)</div><div class="line">5106                                + &quot; total=&quot; + (runtime.totalMemory()/1024)</div><div class="line">5107                                + &quot; used=&quot; + (dalvikUsed/1024));</div><div class="line">5108                        mSomeActivitiesChanged = false;</div><div class="line">5109                        try &#123;</div><div class="line">5110                            mgr.releaseSomeActivities(mAppThread);</div><div class="line">5111                        &#125; catch (RemoteException e) &#123;</div><div class="line">5112                        &#125;</div><div class="line">5113                    &#125;</div><div class="line">5114                &#125;</div><div class="line">5115            &#125;);</div><div class="line">5116        &#125;</div></pre></td></tr></table></figure>
<p>当传入的参数为false时，就走到了如上面贴出的代码中：</p>
<p>此时主要完成两件事</p>
<p>1.调用 RuntimeInit.setApplicationObject() 方法，把对象mAppThread（Binder）放到了RuntimeInit类中的静态变量mApplicationObject中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">	public static final void More ...setApplicationObject(IBinder app) &#123;</div><div class="line">360        mApplicationObject = app;</div><div class="line">361    &#125;</div></pre></td></tr></table></figure>
<p>mAppThread的类型是<strong>ApplicationThread</strong>，它是ActivityThread的成员变量，定义和初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final ApplicationThread mAppThread = new ApplicationThread();</div></pre></td></tr></table></figure>
<p>第二件事比较关键了，就是调用<strong>ActivityManagerService</strong>的attachApplication()方法，将mAppThread 作为参数传入ActivityManagerService，这样ActivityManagerService就可以调用<strong>ApplicaitonThread</strong>的接口了。这与我们刚才说的，ActivityManagerService作为Client端调用ApplicaitonThread的接口管理Activity，就不谋而合了。</p>
<p><strong>写在后面：</strong><br>本文我们明白了ActiivtyThread作为进程的核心类它都管理着哪些对象，并且解释了程序真正入口ActivityThread的main方法都完成了哪些重要的操作，之后会继续带大家了解相关共同组成Android应用进程的核心类，如果有问题和疑问可以多交流，毕竟我也是边学习变整理总结嘛~</p>
<p>如果有需要，推荐你了解一下Context，对你会很有帮助哦~</p>
<p><a href="http://www.jianshu.com/p/46c35c5079b4" target="_blank" rel="external">你足够了解Context吗？</a></p>
<p>最后PS：<br><strong>注意保护电脑不要被水淹！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ActivityThread的main方法究竟做了什么？&quot;&gt;&lt;a href=&quot;#ActivityThread的main方法究竟做了什么？&quot; class=&quot;headerlink&quot; title=&quot;ActivityThread的main方法究竟做了什么？&quot;&gt;&lt;/a&gt;ActivityThread的main方法究竟做了什么？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;在暴雨天能去上课的都是好学生，能去上班的都是游泳运动员~&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ActivityThread" scheme="http://yoursite.com/tags/ActivityThread/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android微信自动回复功能</title>
    <link href="http://yoursite.com/2016/07/28/Android%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/28/Android微信自动回复功能/</id>
    <published>2016-07-28T02:35:00.055Z</published>
    <updated>2016-07-28T02:35:48.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android微信自动回复功能"><a href="#Android微信自动回复功能" class="headerlink" title="Android微信自动回复功能"></a>Android微信自动回复功能</h1><p><strong>写在前面：</strong><br>最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。<br><a id="more"></a><br>老大还提示我需要用<strong>AccessibilityService</strong>去实现它，当然在此之前我并不知道<strong>AccessibilityService</strong>是什么鬼，不过没关系，                             <strong>just do IT</strong> ！</p>
<h2 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h2><p><a href="https://developer.android.com/reference/android/accessibilityservice/AccessibilityService.html" target="_blank" rel="external">AccessibilityService官方文档（需翻墙）</a></p>
<p>上面这个链接是AccessibilityService的官方文档，可以翻墙点进去了解下，我再给大家总结一下：</p>
<p>AccessibilityService是Android系统框架提供给安装在设备上应用的一个可选的导航反馈特性。AccessibilityService 可以替代应用与用户交流反馈，比如将文本转化为语音提示，或是用户的手指悬停在屏幕上一个较重要的区域时的触摸反馈等。</p>
<p>如果感觉上面的描述比较抽象，没关系，也许你见过下面这张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-4e0ed17ecddf2329?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="辅助功能中的服务"></p>
<p>打开你手机的设置–辅助功能中，有很多APP提供的服务，他们都是基于AccessibilityService编写的，AccessibilityService可以侦听你的点击，长按，手势，通知栏的变化等。并且你可以通过很多种方式找到窗体中的EditText，Button等组件，去填充他们，去点击他们来帮你实现自动化的功能。</p>
<p>像360助手的自动安装功能，它就是侦听着系统安装的APP，然后找到“安装”按钮，实现了自动点击。微信自动抢红包功能，实现方式都是如此。</p>
<h2 id="配置AccessibilityService"><a href="#配置AccessibilityService" class="headerlink" title="配置AccessibilityService"></a>配置AccessibilityService</h2><p>首先我们在res文件夹下创建xml文件夹，然后创建一个名为auto_reply_service_config的文件，一会我们会在清单文件中引用它。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8480a79d9d81a235?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AccessibilityService配置文件"></p>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;accessibility-service 	          xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;     android:accessibilityEventTypes=&quot;typeNotificationStateChanged|typeWindowStateChanged&quot;</div><div class="line">    android:accessibilityFeedbackType=&quot;feedbackGeneric&quot;</div><div class="line">    android:accessibilityFlags=&quot;flagDefault&quot;</div><div class="line">    android:canRetrieveWindowContent=&quot;true&quot;</div><div class="line">    android:description=&quot;@string/accessibility_description&quot;</div><div class="line">    android:notificationTimeout=&quot;100&quot;</div><div class="line">    android:packageNames=&quot;com.tencent.mm&quot; /&gt;</div></pre></td></tr></table></figure>
<p>这个文件表示我们对AccessibilityService服务未来侦听的行为做了一些配置，比如 <strong>typeNotificationStateChanged</strong> 和 <strong>typeWindowStateChanged</strong> 表示我们需要侦听通知栏的状态变化和窗体状态改变。<br>android:packageNames=”com.tencent.mm” 这是微信的包名，表示我们只关心微信这一个应用。</p>
<p>代码不打算带着大家一行一行看了，如果有不明白的，去看看文档，或者下面回复我，我给大家解答~</p>
<h2 id="创建AccessibilityService"><a href="#创建AccessibilityService" class="headerlink" title="创建AccessibilityService"></a>创建AccessibilityService</h2><p>下面贴出AccessibilityService类的全部代码，注释还算详尽，如有疑问，下方回复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div></pre></td><td class="code"><pre><div class="line">package com.ileja.autoreply;</div><div class="line"></div><div class="line">import android.accessibilityservice.AccessibilityService;</div><div class="line">import android.annotation.SuppressLint;</div><div class="line">import android.app.ActivityManager;</div><div class="line">import android.app.KeyguardManager;</div><div class="line">import android.app.Notification;</div><div class="line">import android.app.PendingIntent;</div><div class="line">import android.content.ClipData;</div><div class="line">import android.content.ClipboardManager;</div><div class="line">import android.content.ComponentName;</div><div class="line">import android.content.Context;</div><div class="line">import android.content.Intent;</div><div class="line">import android.os.Bundle;</div><div class="line">import android.os.Handler;</div><div class="line">import android.os.PowerManager;</div><div class="line">import android.text.TextUtils;</div><div class="line">import android.view.KeyEvent;</div><div class="line">import android.view.accessibility.AccessibilityEvent;</div><div class="line">import android.view.accessibility.AccessibilityNodeInfo;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class AutoReplyService extends AccessibilityService &#123;</div><div class="line">    private final static String MM_PNAME = &quot;com.tencent.mm&quot;;</div><div class="line">    boolean hasAction = false;</div><div class="line">    boolean locked = false;</div><div class="line">    boolean background = false;</div><div class="line">    private String name;</div><div class="line">    private String scontent;</div><div class="line">    AccessibilityNodeInfo itemNodeinfo;</div><div class="line">    private KeyguardManager.KeyguardLock kl;</div><div class="line">    private Handler handler = new Handler();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 必须重写的方法，响应各种事件。</div><div class="line">     * @param event</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void onAccessibilityEvent(final AccessibilityEvent event) &#123;</div><div class="line">        int eventType = event.getEventType();</div><div class="line">        android.util.Log.d(&quot;maptrix&quot;, &quot;get event = &quot; + eventType);</div><div class="line">        switch (eventType) &#123;</div><div class="line">            case AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED:// 通知栏事件</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;get notification event&quot;);</div><div class="line">                List&lt;CharSequence&gt; texts = event.getText();</div><div class="line">                if (!texts.isEmpty()) &#123;</div><div class="line">                    for (CharSequence text : texts) &#123;</div><div class="line">                        String content = text.toString();</div><div class="line">                        if (!TextUtils.isEmpty(content)) &#123;</div><div class="line">                            if (isScreenLocked()) &#123;</div><div class="line">                                locked = true;</div><div class="line">                                wakeAndUnlock();</div><div class="line">                                android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is locked&quot;);</div><div class="line">                                if (isAppForeground(MM_PNAME)) &#123;</div><div class="line">                                    background = false;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                    handler.postDelayed(new Runnable() &#123;</div><div class="line">                                        @Override</div><div class="line">                                        public void run() &#123;</div><div class="line">                                            sendNotifacationReply(event);</div><div class="line">                                            if (fill()) &#123;</div><div class="line">                                                send();</div><div class="line">                                            &#125;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;, 1000);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    background = true;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                &#125;</div><div class="line">                            &#125; else &#123;</div><div class="line">                                locked = false;</div><div class="line">                                android.util.Log.d(&quot;maptrix&quot;, &quot;the screen is unlocked&quot;);</div><div class="line">                                // 监听到微信红包的notification，打开通知</div><div class="line">                                if (isAppForeground(MM_PNAME)) &#123;</div><div class="line">                                    background = false;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in foreground&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                    handler.postDelayed(new Runnable() &#123;</div><div class="line">                                        @Override</div><div class="line">                                        public void run() &#123;</div><div class="line">                                            if (fill()) &#123;</div><div class="line">                                                send();</div><div class="line">                                            &#125;</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;, 1000);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                    background = true;</div><div class="line">                                    android.util.Log.d(&quot;maptrix&quot;, &quot;is mm in background&quot;);</div><div class="line">                                    sendNotifacationReply(event);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;get type window down event&quot;);</div><div class="line">                if (!hasAction) break;</div><div class="line">                itemNodeinfo = null;</div><div class="line">                String className = event.getClassName().toString();</div><div class="line">                if (className.equals(&quot;com.tencent.mm.ui.LauncherUI&quot;)) &#123;</div><div class="line">                    if (fill()) &#123;</div><div class="line">                        send();</div><div class="line">                    &#125;else &#123;</div><div class="line">                        if(itemNodeinfo != null)&#123;</div><div class="line">                            itemNodeinfo.performAction(AccessibilityNodeInfo.ACTION_CLICK);</div><div class="line">                            handler.postDelayed(new Runnable() &#123;</div><div class="line">                                @Override</div><div class="line">                                public void run() &#123;</div><div class="line">                                    if (fill()) &#123;</div><div class="line">                                        send();</div><div class="line">                                    &#125;</div><div class="line">                                    back2Home();</div><div class="line">                                    release();</div><div class="line">                                    hasAction = false;</div><div class="line">                                &#125;</div><div class="line">                            &#125;, 1000);</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                //bring2Front();</div><div class="line">                back2Home();</div><div class="line">                release();</div><div class="line">                hasAction = false;</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 寻找窗体中的“发送”按钮，并且点击。</div><div class="line">     */</div><div class="line">    @SuppressLint(&quot;NewApi&quot;)</div><div class="line">    private void send() &#123;</div><div class="line">        AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();</div><div class="line">        if (nodeInfo != null) &#123;</div><div class="line">            List&lt;AccessibilityNodeInfo&gt; list = nodeInfo</div><div class="line">                    .findAccessibilityNodeInfosByText(&quot;发送&quot;);</div><div class="line">            if (list != null &amp;&amp; list.size() &gt; 0) &#123;</div><div class="line">                for (AccessibilityNodeInfo n : list) &#123;</div><div class="line">                    if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled())</div><div class="line">                    &#123;    </div><div class="line">                        n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">            &#125; else &#123;</div><div class="line">                List&lt;AccessibilityNodeInfo&gt; liste = nodeInfo</div><div class="line">                        .findAccessibilityNodeInfosByText(&quot;Send&quot;);</div><div class="line">                if (liste != null &amp;&amp; liste.size() &gt; 0) &#123;</div><div class="line">                    for (AccessibilityNodeInfo n : liste) &#123;</div><div class="line">                        if(n.getClassName().equals(&quot;android.widget.Button&quot;) &amp;&amp; n.isEnabled())</div><div class="line">                        &#123;    </div><div class="line">                             n.performAction(AccessibilityNodeInfo.ACTION_CLICK);&#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            pressBackButton();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 模拟back按键</div><div class="line">     */</div><div class="line">    private void pressBackButton()&#123;</div><div class="line">        Runtime runtime = Runtime.getRuntime();</div><div class="line">        try &#123;</div><div class="line">            runtime.exec(&quot;input keyevent &quot; + KeyEvent.KEYCODE_BACK);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @param event</div><div class="line">     */</div><div class="line">    private void sendNotifacationReply(AccessibilityEvent event) &#123;</div><div class="line">        hasAction = true;</div><div class="line">        if (event.getParcelableData() != null</div><div class="line">                &amp;&amp; event.getParcelableData() instanceof Notification) &#123;</div><div class="line">            Notification notification = (Notification) event</div><div class="line">                    .getParcelableData();</div><div class="line">            String content = notification.tickerText.toString();</div><div class="line">            String[] cc = content.split(&quot;:&quot;);</div><div class="line">            name = cc[0].trim();</div><div class="line">            scontent = cc[1].trim();</div><div class="line"></div><div class="line">            android.util.Log.i(&quot;maptrix&quot;, &quot;sender name =&quot; + name);</div><div class="line">            android.util.Log.i(&quot;maptrix&quot;, &quot;sender content =&quot; + scontent);</div><div class="line"></div><div class="line"></div><div class="line">            PendingIntent pendingIntent = notification.contentIntent;</div><div class="line">            try &#123;</div><div class="line">                pendingIntent.send();</div><div class="line">            &#125; catch (PendingIntent.CanceledException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressLint(&quot;NewApi&quot;)</div><div class="line">    private boolean fill() &#123;</div><div class="line">        AccessibilityNodeInfo rootNode = getRootInActiveWindow();</div><div class="line">        if (rootNode != null) &#123;</div><div class="line">            return findEditText(rootNode, &quot;正在忙,稍后回复你&quot;);</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    private boolean findEditText(AccessibilityNodeInfo rootNode, String content) &#123;</div><div class="line">        int count = rootNode.getChildCount();</div><div class="line"></div><div class="line">        android.util.Log.d(&quot;maptrix&quot;, &quot;root class=&quot; + rootNode.getClassName() + &quot;,&quot;+ rootNode.getText()+&quot;,&quot;+count);</div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            AccessibilityNodeInfo nodeInfo = rootNode.getChild(i);</div><div class="line">            if (nodeInfo == null) &#123;</div><div class="line">                android.util.Log.d(&quot;maptrix&quot;, &quot;nodeinfo = null&quot;);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            android.util.Log.d(&quot;maptrix&quot;, &quot;class=&quot; + nodeInfo.getClassName());</div><div class="line">            android.util.Log.e(&quot;maptrix&quot;, &quot;ds=&quot; + nodeInfo.getContentDescription());</div><div class="line">            if(nodeInfo.getContentDescription() != null)&#123;</div><div class="line">                int nindex = nodeInfo.getContentDescription().toString().indexOf(name);</div><div class="line">                int cindex = nodeInfo.getContentDescription().toString().indexOf(scontent);</div><div class="line">                android.util.Log.e(&quot;maptrix&quot;, &quot;nindex=&quot; + nindex + &quot; cindex=&quot; +cindex);</div><div class="line">                if(nindex != -1)&#123;</div><div class="line">                    itemNodeinfo = nodeInfo;</div><div class="line">                    android.util.Log.i(&quot;maptrix&quot;, &quot;find node info&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (&quot;android.widget.EditText&quot;.equals(nodeInfo.getClassName())) &#123;</div><div class="line">                android.util.Log.i(&quot;maptrix&quot;, &quot;==================&quot;);</div><div class="line">                Bundle arguments = new Bundle();</div><div class="line">                arguments.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_MOVEMENT_GRANULARITY_INT,</div><div class="line">                        AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD);</div><div class="line">                arguments.putBoolean(AccessibilityNodeInfo.ACTION_ARGUMENT_EXTEND_SELECTION_BOOLEAN,</div><div class="line">                        true);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY,</div><div class="line">                        arguments);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_FOCUS);</div><div class="line">                ClipData clip = ClipData.newPlainText(&quot;label&quot;, content);</div><div class="line">                ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);</div><div class="line">                clipboardManager.setPrimaryClip(clip);</div><div class="line">                nodeInfo.performAction(AccessibilityNodeInfo.ACTION_PASTE);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (findEditText(nodeInfo, content)) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onInterrupt() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 判断指定的应用是否在前台运行</div><div class="line">     *</div><div class="line">     * @param packageName</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isAppForeground(String packageName) &#123;</div><div class="line">        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        ComponentName cn = am.getRunningTasks(1).get(0).topActivity;</div><div class="line">        String currentPackageName = cn.getPackageName();</div><div class="line">        if (!TextUtils.isEmpty(currentPackageName) &amp;&amp; currentPackageName.equals(packageName)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 将当前应用运行到前台</div><div class="line">     */</div><div class="line">    private void bring2Front() &#123;</div><div class="line">        ActivityManager activtyManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = activtyManager.getRunningTasks(3);</div><div class="line">        for (ActivityManager.RunningTaskInfo runningTaskInfo : runningTaskInfos) &#123;</div><div class="line">            if (this.getPackageName().equals(runningTaskInfo.topActivity.getPackageName())) &#123;</div><div class="line">                activtyManager.moveTaskToFront(runningTaskInfo.id, ActivityManager.MOVE_TASK_WITH_HOME);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 回到系统桌面</div><div class="line">     */</div><div class="line">    private void back2Home() &#123;</div><div class="line">        Intent home = new Intent(Intent.ACTION_MAIN);</div><div class="line"></div><div class="line">        home.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">        home.addCategory(Intent.CATEGORY_HOME);</div><div class="line"></div><div class="line">        startActivity(home);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 系统是否在锁屏状态</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isScreenLocked() &#123;</div><div class="line">        KeyguardManager keyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);</div><div class="line">        return keyguardManager.inKeyguardRestrictedInputMode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void wakeAndUnlock() &#123;</div><div class="line">        //获取电源管理器对象</div><div class="line">        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);</div><div class="line"></div><div class="line">        //获取PowerManager.WakeLock对象，后面的参数|表示同时传入两个值，最后的是调试用的Tag</div><div class="line">        PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_BRIGHT_WAKE_LOCK, &quot;bright&quot;);</div><div class="line"></div><div class="line">        //点亮屏幕</div><div class="line">        wl.acquire(1000);</div><div class="line"></div><div class="line">        //得到键盘锁管理器对象</div><div class="line">        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);</div><div class="line">        kl = km.newKeyguardLock(&quot;unLock&quot;);</div><div class="line"></div><div class="line">        //解锁</div><div class="line">        kl.disableKeyguard();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void release() &#123;</div><div class="line"></div><div class="line">        if (locked &amp;&amp; kl != null) &#123;</div><div class="line">            android.util.Log.d(&quot;maptrix&quot;, &quot;release the lock&quot;);</div><div class="line">            //得到键盘锁管理器对象</div><div class="line">            kl.reenableKeyguard();</div><div class="line">            locked = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着配置清单文件，权限和service的配置比较重要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    package=&quot;com.ileja.autoreply&quot;&gt;</div><div class="line"></div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.GET_TASKS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.REORDER_TASKS&quot; /&gt;</div><div class="line">    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;application</div><div class="line">        android:allowBackup=&quot;true&quot;</div><div class="line">        android:icon=&quot;@mipmap/ic_launcher&quot;</div><div class="line">        android:label=&quot;@string/app_name&quot;</div><div class="line">        android:supportsRtl=&quot;true&quot;</div><div class="line">        android:theme=&quot;@style/AppTheme&quot;&gt;</div><div class="line">        &lt;activity android:name=&quot;.MainActivity&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</div><div class="line"></div><div class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line">        &lt;/activity&gt;</div><div class="line"></div><div class="line">        &lt;service</div><div class="line">            android:name=&quot;.AutoReplyService&quot;</div><div class="line">            android:enabled=&quot;true&quot;</div><div class="line">            android:exported=&quot;true&quot;</div><div class="line">            android:label=&quot;@string/app_name&quot;</div><div class="line">            android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;</div><div class="line">            &lt;intent-filter&gt;</div><div class="line">                &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot;/&gt;</div><div class="line">            &lt;/intent-filter&gt;</div><div class="line"></div><div class="line">            &lt;meta-data</div><div class="line">                android:name=&quot;android.accessibilityservice&quot;</div><div class="line">                android:resource=&quot;@xml/auto_reply_service_config&quot;/&gt;</div><div class="line">        &lt;/service&gt;</div><div class="line">    &lt;/application&gt;</div><div class="line">&lt;/manifest&gt;</div></pre></td></tr></table></figure>
<p>为了使用某些必要的API，最低API level应该是18</p>
<p>运行程序，打开服务，看看效果如何把~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e94c54ef21781ad7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开辅助服务"></p>
<p>接着用其他手机试着发送给我几条微信</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9098668b06dd7e3d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自动回复微信"></p>
<p>可以看到，自动回复功能就实现了。</p>
<p><strong>写在后面：</strong></p>
<p>代码没有给大家详细讲解，不过看注释应该可以看懂个大概。当微信程序切换到后台，或者锁屏（无锁屏密码）时，只要有通知出现，都可以实现自动回复。</p>
<p>关于<strong>AccessibilityService</strong>可以监控的行为非常多，所以我觉得可以实现各种各样炫酷的功能，不过我并不建议你打开某些流氓软件的AccessibilityService服务，因为很有可能造成一些安全问题，所以，自己动手写就安全多了嘛。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android微信自动回复功能&quot;&gt;&lt;a href=&quot;#Android微信自动回复功能&quot; class=&quot;headerlink&quot; title=&quot;Android微信自动回复功能&quot;&gt;&lt;/a&gt;Android微信自动回复功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;最近接到老大的一个需求，要求在手机端拦截微信的通知（Notification），从而获得联系人和内容。之后将联系人和内容发送到我们的硬件产品上，展示出来之后，再将我们想回复内容传给微信，并且发送给相应联系人。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>跳出手机的Dialog--Presentation</title>
    <link href="http://yoursite.com/2016/07/28/%E8%B7%B3%E5%87%BA%E6%89%8B%E6%9C%BA%E7%9A%84Dialog--Presentation/"/>
    <id>http://yoursite.com/2016/07/28/跳出手机的Dialog--Presentation/</id>
    <published>2016-07-28T02:33:09.556Z</published>
    <updated>2016-07-28T02:34:20.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跳出手机的Dialog–Presentation"><a href="#跳出手机的Dialog–Presentation" class="headerlink" title="跳出手机的Dialog–Presentation"></a>跳出手机的Dialog–Presentation</h1><p><strong>写在前面：</strong><br><strong>Presentation 是 what？</strong><br>也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-7e831736d001e10a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="容我想想"></p>
<p>Presentation是说明书？<br>Presentation是一个颁奖典礼？<br><strong>Presentation还是某卖药公司UE总监让所有IT人尴尬癌尽犯的PPT Presentation？</strong></p>
<p>公司做的是智能硬件方向，国内有关Presentation资料几乎是空白的，所以我的研究更多参考了Presentation官方文档和一些英文资料。<strong>如果各位看官有什么建议，一定要记得补充。</strong></p>
<h2 id="presentation的定义"><a href="#presentation的定义" class="headerlink" title="presentation的定义"></a>presentation的定义</h2><p>好吧，既然上面这些都不是，Presentation是一个类，我们翻过太平洋的墙，来看看Presentation的定义。</p>
<blockquote>
<p>A presentation is a special kind of dialog whose purpose is to present content on a secondary display.</p>
</blockquote>
<p>我们仅仅先来看这一句定义，因为当你对一个东西完全不了解时候，知道的越多，越会影响你的判断。</p>
<p>翻译下：presentation 是一种特殊的 <strong>dialog</strong> ，目的是为了在<strong>辅助屏幕</strong>上展示不同的内容。</p>
<p>在这句话上，我收集到了两个关键的信息：</p>
<ul>
<li><p><strong>presentation 是一个 dialog</strong><br>根据<strong>生物遗传学</strong>的角度，presentation 无论被描述成什么天花乱坠的模样，它也是一个dialog。</p>
</li>
<li><p><strong>presentation 目的是显示在辅助屏幕上</strong></p>
</li>
</ul>
<p>进一步思考下，也就是说：</p>
<p>我可以拿着我自己的手机，点击一个按钮，然后在你的电脑上或者手机上，弹出一个<strong>自定义的Dialog</strong>（<strong>脑补一下恶作剧场景O(∩_∩)O</strong>）？</p>
<p>这与我们之前，通过一些软件，将手机屏幕同步到电脑上，<strong>区别</strong>又在哪里呢？</p>
<p>相信很多人都能立刻想明白，区别在于：<strong>展示不同内容</strong></p>
<p>通过软件同步到电脑，展示的东西始终与我的手机屏幕相同。</p>
<p>而利用 presentation 我可以自由的展示我想展示的内容，因为它是一个Dialog，是局部可控的。</p>
<h2 id="寻找并投影到辅助屏幕"><a href="#寻找并投影到辅助屏幕" class="headerlink" title="寻找并投影到辅助屏幕"></a>寻找并投影到辅助屏幕</h2><p>产品经理找到我，向我提出了以下几个疑问：</p>
<p>现在手里有一部Android手机</p>
<p> 能否连接以下几种设备</p>
<ul>
<li><p>另一部Android手机</p>
</li>
<li><p>笔记本电脑</p>
</li>
<li><p>智能电视</p>
</li>
<li><p>小米盒子等</p>
</li>
</ul>
<p>并且连接之后，利用presentation展示不同内容。</p>
<p>我乍一看这几个设备，感觉都没问题呀。可是当我拿着手机挨个尝试，几次失败，并且耐心分析之后，发现了问题。</p>
<p>首先Presentation是Android 4.2引出的，与之同时Android 4.2 还支持 Miracast 影像传输协议。所以它俩一定是有联系的。</p>
<p><strong>Miracast</strong> </p>
<p><a href="http://www.360doc.com/content/15/0422/21/1204156_465287702.shtml" target="_blank" rel="external">Miracast简介</a></p>
<p>Miracast是一种基于WIFI的传输协议，Android 4.2以上的手机、Win8电脑、智能电视、盒子几乎都是支持它的。</p>
<p>不过Miracast它将设备分为发送端和接收端<br>发送端有手机、电脑。<br>接收端有智能电视、电视盒子。</p>
<p>所以，手机连手机或电脑展示Presentation，是行不通的。手机作为发射端，去寻找智能电视和盒子才是正解。</p>
<h2 id="Presentation"><a href="#Presentation" class="headerlink" title="Presentation"></a>Presentation</h2><p>终于弄明白了要寻找的设备是怎样的，建立连接之前，参考官方文档的样例，我们先把<strong>Presentation</strong>给搭建好。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9b65f51ad6fddc47?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Presentation类"></p>
<p>可以看到，和Activity一样，可以通过setContentView来给Presentation设置一个布局。自然布局里可以有各种各样的组件，还可以有像GLSurfaceView、SurfaceView 这种重量级的组件，来显示炫酷的动画。这里我们就仅仅写一个TextView，展示一行“show a Presentation”文字。</p>
<p>值得一提的是，在Presentation中的getContext得到的context与它依附的Activity的context是不同的，Presentation的context是目标屏幕属性的context，包含着辅助屏幕的属性信息。</p>
<h2 id="获取辅助屏幕"><a href="#获取辅助屏幕" class="headerlink" title="获取辅助屏幕"></a>获取辅助屏幕</h2><p>获取辅助屏幕有两种方式</p>
<ul>
<li><p><strong>MediaRouter</strong></p>
</li>
<li><p><strong>DisplayManager</strong></p>
</li>
</ul>
<p><strong>MediaRouter</strong></p>
<p>利用MediaRouter的API寻找周围设备是一种最简单的方式了，它会直接绑定周围最合适的设备。就相当于你用谷歌搜索直接点击“<strong>手气不错</strong>”</p>
<p>代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-a732a40ac5b0917c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击按钮，展示Presentation"></p>
<p>可以看到在Presentation的构造中，传入了一个display，这就是搜索到的那个设备</p>
<p>先来测试一下，Android 4.2的手机在开发中选项中，都有模拟辅助屏幕的功能，我们选择一个分辨率，打开它，模拟一个外部的屏幕。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ac89976cb382208d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开模拟辅助屏幕"></p>
<p>默认辅助屏幕是同步手机屏幕的，打开之后，进入测试app，点击按钮：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bf37642c0f80de9e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
<p>注意这可不是一个Dialog，而是我们把内容展示在了一个模拟的辅助屏幕上，回头看看标题，是不是就实现了呢？</p>
<p><strong>DisplayManager</strong></p>
<p>第二种搜索设备的方法是DisplayManager，他可以搜索周围所有可用的display，产生一个display数组，然后你就可以选择合适的设备进行展示了。</p>
<p>代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-64ae611bb26eb676?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayManager"></p>
<p>代码还是挺简单的，搜索到周围所有可用设备之后，展示到ListView上，点击条目，在APP上和Presentataion上分别跑一个秒表，看看延时性如何，截图如下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-3eaea827329729f0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DisplayManager"></p>
<p>可以看到，搜索到的设备名称是  <strong>叠加视图#1</strong> ，点击条目之后两个秒表也分别跑了起来。</p>
<p><strong>总结：</strong></p>
<p>上面对Presentation进行了一个简略的介绍，因为相信大家如果做的不是智能硬件方向，基本上不会遇到这个需求。关于Activity对Presentation的管理方式，官方文档的有两个Demo可以参考，需要时可以去查看。</p>
<p><strong>写在后面：</strong></p>
<p>周末在连接智能电视测试时，发现延时很小，完全可以投入使用。<br>关于Presentation资料比较少，欢迎大家一同交流</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;跳出手机的Dialog–Presentation&quot;&gt;&lt;a href=&quot;#跳出手机的Dialog–Presentation&quot; class=&quot;headerlink&quot; title=&quot;跳出手机的Dialog–Presentation&quot;&gt;&lt;/a&gt;跳出手机的Dialog–Presentation&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Presentation 是 what？&lt;/strong&gt;&lt;br&gt;也许你刚看到标题的时候，会默默把这个单词扔到翻译工具里面，就像老大最开始跟我提起这个单词的时候一样。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Presentation" scheme="http://yoursite.com/tags/Presentation/"/>
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>3分钟傻瓜式反编译一个APP</title>
    <link href="http://yoursite.com/2016/07/28/3%E5%88%86%E9%92%9F%E5%82%BB%E7%93%9C%E5%BC%8F%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AAAPP/"/>
    <id>http://yoursite.com/2016/07/28/3分钟傻瓜式反编译一个APP/</id>
    <published>2016-07-28T02:32:03.731Z</published>
    <updated>2016-07-28T02:32:41.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3分钟傻瓜式反编译一个APP"><a href="#3分钟傻瓜式反编译一个APP" class="headerlink" title="3分钟傻瓜式反编译一个APP"></a>3分钟傻瓜式反编译一个APP</h1><p><strong>写在前面：</strong><br>最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~<br>前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。<br><a id="more"></a></p>
<h2 id="反编译是为了啥？"><a href="#反编译是为了啥？" class="headerlink" title="反编译是为了啥？"></a>反编译是为了啥？</h2><p>我们什么时候需要反编译呢？</p>
<ul>
<li><p>想获得目标APP的资源（图片等）</p>
</li>
<li><p>有功能不会写了，参考（copy）一下同类APP</p>
</li>
<li><p>某些“羞羞”的事情</p>
</li>
</ul>
<p>前两条需求还是蛮常见的，最后一条是开个玩笑，别做<strong>坏事</strong>就~</p>
<h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul>
<li><p>onekey decompile apk （一键反编译APK工具）</p>
</li>
<li><p>目标APK</p>
<p> <a href="http://download.csdn.net/download/g_bird0622/7145155" target="_blank" rel="external">onekey decompile apk下载链接</a></p>
</li>
</ul>
<h2 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h2><p>下载工具压缩包</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-7095016c09c79e8b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载压缩包"></p>
<p>多说一句，这个工具集成了三个反编译的工具的功能，一步到位。如果你对这三个工具各自的功能使用感兴趣，<strong>自行搜索学习</strong>一下。</p>
<p>解压到C盘根目录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-203b3fb4209cf8dd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压到C盘根目录"></p>
<p>这里强调一下，最好是放在C盘根目录下，放到别的盘反编译可能会失败。我就失败过一次，具体原因是什么不得而知~</p>
<p><strong>得到以下文件：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e3b98a03c4269c2d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="得到以下文件"></p>
<p>将要反编译的APK放到这个目录下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-0b0cdfd317a1af22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="放APK到目录下"></p>
<p>将apk文件<strong>拖拽</strong>到<code>_onekey-decompile-apk.bat</code>上</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d84f2f1dae7043a3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拖拽"></p>
<p><strong>然后耐心等待十几秒……</strong></p>
<p><strong>源代码弹出，反编译完成！</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-378d927bd2257158?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="反编译完成"></p>
<ul>
<li>会在<code>onekey-decompile-apk</code>目录下生成和apk同名的目录(放置了apktools反编译出来的东西)</li>
<li>会在<code>onekey-decompile-apk</code>目录下生成和apk同名的jar文件(dex2jar反编译出来的class)</li>
</ul>
<p>图片资源会很完整，有些代码被混淆了，不过还是能看懂个大概的~</p>
<p><strong>写在后面：</strong></p>
<p>这个工具的作用不止于此，有需要再慢慢研究吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3分钟傻瓜式反编译一个APP&quot;&gt;&lt;a href=&quot;#3分钟傻瓜式反编译一个APP&quot; class=&quot;headerlink&quot; title=&quot;3分钟傻瓜式反编译一个APP&quot;&gt;&lt;/a&gt;3分钟傻瓜式反编译一个APP&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;最近工作有些忙，一段时间没更新博客了，趁着刚吃完晚饭，来更新一下~&lt;br&gt;前几天，需求上有一个功能没思路，反编译了一下同类型的APP，找到了一个关键类，问题得以解决。网络上有很多比较成熟的文章，不过我个人对于反编译这块，有些需求过剩，不够简单粗暴，所以特来介绍一个方便的工具来进行反编译操作。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="反编译" scheme="http://yoursite.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Handler可能造成内存泄漏（四）</title>
    <link href="http://yoursite.com/2016/07/28/Handler%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Handler可能造成内存泄漏（四）/</id>
    <published>2016-07-28T02:18:57.129Z</published>
    <updated>2016-07-28T02:19:58.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler可能造成内存泄漏（四）"><a href="#Handler可能造成内存泄漏（四）" class="headerlink" title="Handler可能造成内存泄漏（四）"></a>Handler可能造成内存泄漏（四）</h1><p><strong>写在前面：</strong><br>不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：<br><a id="more"></a><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">子线程为何不能更新UI（一）</a></p>
<p>第一篇中我们探究了，在Android设计之时，为何子线程允许更新UI。官方给出的解释是由于<strong>线程安全</strong>（Thread Safe）问题。（当然也有一些其他方面的猜想）</p>
<p><a href="http://www.jianshu.com/p/8501d3b0c359" target="_blank" rel="external">解决在子线程更新UI崩溃问题（二）</a></p>
<p>第二篇中，我们总结了三种崩溃解决的办法。</p>
<ul>
<li><p>Activity.runOnUIThread();</p>
</li>
<li><p>View.post();</p>
</li>
<li><p>Handler;</p>
</li>
</ul>
<p>我们本着寻找最优解的思路比较了三种解决办法，发现代码的实现方式都为Handler，从而真正引出了Android消息机制，Handler。</p>
<p><a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">带着这篇去通关所有Handler的提问（三）</a></p>
<p>第三篇文章是我们这个系列的重头戏，我用一个还算生动的故事，为大家解释了Handler和相关核心类的关系，推荐阅读。</p>
<p>OK，回顾之后，我们正式来开始本篇文章。</p>
<h2 id="内存泄漏是怎么一回事？"><a href="#内存泄漏是怎么一回事？" class="headerlink" title="内存泄漏是怎么一回事？"></a>内存泄漏是怎么一回事？</h2><p>可以看到，标题中有一个显眼的名词，就是<strong>内存泄漏</strong>，我想有必要给初学的朋友们讲讲何为内存泄漏。</p>
<p>在讨论内存泄漏之前，先简单的说说Android中<strong>内存的回收</strong></p>
<p><strong>Dalivik</strong>虚拟机扮演了常规的垃圾回收角色，为了<strong>GC</strong>能够从App中及时回收内存，我们需要时时刻刻在适当的时机来释放<strong>引用对象</strong>，Dalvik的GC会自动把离开<strong>活动线程</strong>的对象进行回收。</p>
<p>什么是<strong>Android内存泄漏</strong>：</p>
<p>虽然Android是一个<strong>自动管理内存</strong>的开发环境，但是垃圾回收器只会移除那些已经失去引用的、不可达的对象，在十几万、几十万行代码中，由于你的失误使得一个本应该被<strong>销毁的对象仍然被错误的持有</strong>，那么该对象就永远不会被释放掉，这些已经没有任何价值的对象，仍然占据<strong>聚集在你的堆内存中</strong>，GC就会被频繁触发，多说几句，如果手机不错，一次GC的时间70毫秒，不会对应用的性能产生什么影响，但是如果一个手机的性能不是那么出色，一次GC时间120毫秒，出现大量的GC操作，我相信用户就能感觉到了吧。这些无用的引用堆积在堆内存中，越积越多最终导致Crash。</p>
<p>有关一些性能优化推荐给大家一个我总结的博客。</p>
<p><a href="http://www.jianshu.com/p/be05874965d4" target="_blank" rel="external">Android性能优化总结</a></p>
<p>扯得好像远了一点，既然明白了内存泄漏是怎么回事，那与<strong>Handler</strong>又有什么关系呢？</p>
<h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><p>参考一篇外文：</p>
<p><a href="http://www.androiddesignpatterns.com/2013/01/inner-class-handler-memory-leak.html" target="_blank" rel="external">inner-class-handler-memory-leak</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-cdcc17e0dcd66c8c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Handler时，给出的warnning"></p>
<p>当我们正常使用Handler时，会给出一个<strong>warning</strong>提示。翻译过来就是，这个Handler类应该是静态的，否则可能造成内存泄漏。</p>
<p>当我们简单的使用Handler的时候，并不会踩到内存泄漏这个坑，不过当Handler作为一个<strong>内部类或者匿名类</strong>时，这个问题就可能发生。</p>
<p>在上篇中，我们知道，当Android启动之时，<strong>ActivityThread</strong>类中，会创建<strong>UI</strong>线程的<strong>Looper</strong>和<strong>MessageQueue</strong></p>
<p>MessageQueue中的消息会被一个接一个处理。应用的所有事件(比如<strong>Activity生命周期</strong>回调方法，<strong>按钮点击</strong>等等)都会被当做一个消息对象放入到Looper的消息队列中，然后再被逐一执行。UI线程的Looper存在于整个应用的<strong>生命周期</strong>内。</p>
<p>当在UI线程中创建Handler对象时，它就会和UI线程中Looper的消息队列进行关联。发送到这个消息队列中的消息会持有这个Handler的<strong>引用</strong>，这样当Looper最终处理这个消息的时候framework就会调用Handler#handleMessage(Message)方法来处理具体的逻辑。</p>
<p><strong>在Java中，非静态的内部类或者匿名类会隐式的持有其外部类的引用，而静态的内部类则不会。</strong></p>
<p>那么，内存到底是在哪里泄露的呢？其实泄漏发生的还是比较隐晦的，但是再看看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class SampleActivity extends Activity &#123;</div><div class="line"></div><div class="line">  private final Handler mLeakyHandler = new Handler() &#123;</div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">      // ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    // Post a message and delay its execution for 10 minutes.</div><div class="line">    mLeakyHandler.postDelayed(new Runnable() &#123;</div><div class="line">      @Override</div><div class="line">      public void run() &#123; /* ... */ &#125;</div><div class="line">    &#125;, 1000 * 60 * 10);</div><div class="line"></div><div class="line">    // Go back to the previous Activity.</div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当activity被finish的时候，延迟发送的消息仍然会存活在UI线程的消息队列中，直到10分钟后它被处理掉。这个消息持有activity的Handler的引用，Handler又隐式的持有它的外部类(这里就是SampleActivity)的引用。这个引用会一直存在直到这个消息被处理，所以垃圾回收机制就没法回收这个activity，内存泄露就发生了。需要注意的是：15行的匿名Runnable子类也会导致内存泄露。非静态的匿名类会隐式的持有外部类的引用，所以context会被泄露掉。</p>
<p>解决这个问题也很简单：在新的类文件中实现Handler的子类或者使用static修饰内部类。静态的内部类不会持有外部类的引用，所以activity不会被泄露。如果你要在Handler内调用外部activity类的方法的话，可以让Handler持有外部activity类的弱引用，这样也不会有泄露activity的风险。关于匿名类造成的泄露问题，我们可以用static修饰这个匿名类对象解决这个问题，因为静态的匿名类也不会持有它外部类的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class SampleActivity extends Activity &#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Instances of static inner classes do not hold an implicit</div><div class="line">   * reference to their outer class.</div><div class="line">   */</div><div class="line">  private static class MyHandler extends Handler &#123;</div><div class="line">    private final WeakReference&lt;SampleActivity&gt; mActivity;</div><div class="line"></div><div class="line">    public MyHandler(SampleActivity activity) &#123;</div><div class="line">      mActivity = new WeakReference&lt;SampleActivity&gt;(activity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">      SampleActivity activity = mActivity.get();</div><div class="line">      if (activity != null) &#123;</div><div class="line">        // ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  private final MyHandler mHandler = new MyHandler(this);</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Instances of anonymous classes do not hold an implicit</div><div class="line">   * reference to their outer class when they are &quot;static&quot;.</div><div class="line">   */</div><div class="line">  private static final Runnable sRunnable = new Runnable() &#123;</div><div class="line">      @Override</div><div class="line">      public void run() &#123; /* ... */ &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    // Post a message and delay its execution for 10 minutes.</div><div class="line">    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);</div><div class="line"></div><div class="line">    // Go back to the previous Activity.</div><div class="line">    finish();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态和非静态内部类的区别是非常微妙的，但这个区别是每个Android开发者应该清楚的。那么底线是什么？如果要实例化一个超出activity生命周期的内部类对象，避免使用非静态的内部类。建议使用静态内部类并且在内部类中持有外部类的弱引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Handler可能造成内存泄漏（四）&quot;&gt;&lt;a href=&quot;#Handler可能造成内存泄漏（四）&quot; class=&quot;headerlink&quot; title=&quot;Handler可能造成内存泄漏（四）&quot;&gt;&lt;/a&gt;Handler可能造成内存泄漏（四）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;不知不觉中我们已经进行了三篇有关Android消息机制的研究，温故知新，我们先来回顾一下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>带着这篇去通关所有Handler的提问（三）</title>
    <link href="http://yoursite.com/2016/07/28/%E5%B8%A6%E7%9D%80%E8%BF%99%E7%AF%87%E5%8E%BB%E9%80%9A%E5%85%B3%E6%89%80%E6%9C%89Handler%E7%9A%84%E6%8F%90%E9%97%AE%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/带着这篇去通关所有Handler的提问（三）/</id>
    <published>2016-07-28T02:17:44.984Z</published>
    <updated>2016-07-28T02:18:29.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="带着这篇去通关所有Handler的提问（三）"><a href="#带着这篇去通关所有Handler的提问（三）" class="headerlink" title="带着这篇去通关所有Handler的提问（三）"></a>带着这篇去通关所有Handler的提问（三）</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-5b46d5a0584720ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br>大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的<strong>思路</strong>和<strong>知识点</strong>：<br><a id="more"></a><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">Android消息机制字典型探究（一）</a></p>
<p>在第一篇文章中，我们总结了Android系统不允许在子线程更新UI的原因，本质上是<strong>线程安全问题</strong>，从而引出了Handler。</p>
<p><a href="http://www.jianshu.com/p/8501d3b0c359" target="_blank" rel="external">Android消息机制字典型探究（二）</a></p>
<p>在第二篇文章中，我们又分析了三种在子线程更新UI的方法，分别是：<strong>View.post(param); Activity.runOnUIThread(param); Handler</strong>，当我们对这三种方法的源码进一步分析发现，其实都是对Handler做了一些封装，所以本文我们就来正式全面探究有关<strong>Handler</strong>的知识点。</p>
<p>当时我去面试的四家公司，都问到了Handler的相关知识，有深有浅，所以重要程度<strong>不言而喻</strong>。面试官拿起你的简历，让你谈谈Handler，你仅仅在表象上回答了Android线程通信的机理，然后面试官紧接着问了你如下的几个问题：</p>
<ul>
<li><p>Handler是属于哪个类的？</p>
</li>
<li><p>Handler、Looper、MessageQueue何时建立的相互关系？</p>
</li>
<li><p>主线程的Looper和MessageQueue是何时创建的？</p>
</li>
<li><p>在同一线程中，Looper和MessageQueue是怎样的数量对应关系，与Handler又是怎样的数量对应关系？</p>
</li>
<li><p>MessageQueue中消息为空，线程阻塞挂起等待，为什么不会造成ANR？</p>
</li>
<li><p>有关Handler的内存泄漏是怎么一回事？</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-7a0d4ec7091a39fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一脸萌比"></p>
<p>so…光知道表象很可能是不够的，而且还给自己挖了一个坑，所以我们对于一个知识点的探寻要全面充分一点。下面正式开始本文。</p>
<h2 id="Windows和Android消息机制的区别"><a href="#Windows和Android消息机制的区别" class="headerlink" title="Windows和Android消息机制的区别"></a>Windows和Android消息机制的区别</h2><p>现在的操作系统普遍采用消息驱动模式。Windows操作系统就是典型的<strong>消息驱动模型</strong>。但是，Android的消息处理机制和Windows的消息处理机制又不太相同。我给大家画了图，看看二者的区别。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-989ad8fda07a2608?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Windows进程消息模型"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d41410cd42ed3d8d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android进程消息模型"></p>
<p>通过消息机制图的对比，Windows消息处理模型中，存在一个系统的消息队列，这个队列是整个进程的核心，几乎所有的动作都要转换成消息，然后放到这个队列中，由主线程统一处理。</p>
<p>而Android没有全局的消息队列，消息队列是和某个线程相关联在一起的。每个线程最多有一个消息队列，消息的取出和处理，也在这个线程本身中完成。</p>
<p>也就是说，Android中，如果你想在当前线程使用消息模型，则必须构建一个消息队列，而消息机制的相关主要类是：<strong>Looper、Handler、MessageQueue、Message。</strong></p>
<p>我们并不着急去翻看这些类的源码，理清楚底层实现的逻辑，而且先在宏观表象上看看，Android消息机制是如何运行的？</p>
<h2 id="Android消息机制的宏观原理"><a href="#Android消息机制的宏观原理" class="headerlink" title="Android消息机制的宏观原理"></a>Android消息机制的宏观原理</h2><p>先来看一张<strong>Android消息处理类之间的关系图</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-514571cad65f7171?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android消息处理机制"></p>
<p>我们从表象上解释一下原理，Handler负责将Message发送至当前线程的MessageQueue中，Looper时时刻刻监视着MessageQueue，将符合时间要求的Message取出，再带给发送消息的那个Handler通过HandleMessage处理。</p>
<p>对于消息机制的理解不能仅仅停留在这一步，下面我们从源码的角度分析一下具体的逻辑细节。</p>
<h2 id="Android消息机制相关类的源码分析"><a href="#Android消息机制相关类的源码分析" class="headerlink" title="Android消息机制相关类的源码分析"></a>Android消息机制相关类的源码分析</h2><p>其实写这篇文章之前，我就一直在思考，站在什么角度展开这个机制的描述，更容易让大家理解接受。思来想去，我觉得还是以一个Message游历的形式去描写，会显着有趣和清晰一点。</p>
<p><strong>Message：</strong></p>
<p>人在边境X（<strong>子线程</strong>）服役的士兵Message慵懒得躺在一个人数为50（池中最大数量）的军营（Message池）中。不料这时突然接到了上司的obtain()命令（据说obtain命令更加节省军费），让他去首都（<strong>主线程</strong>）告诉中央领导一些神秘代码。小Message慌乱地整理了下衣角和帽子，带上信封，准备出发。</p>
<p>上司让士兵Message收拾完毕之后等待一个神秘人的电话，并且嘱咐他：到了首都之后，0是这次任务的暗号。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-080d1ddd6f3223a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Message的创建和携带信息"></p>
<p>Message是消息的载体，Message设计成为<strong>Parcelable</strong>类的派生类，这表明Message可以通过<strong>binder</strong>来跨进程发送。<br>通常我们都会用<strong>obtain()</strong>方法去创建Message，如果消息池中有Message有，则取出，没有，再重新创建。这样可以防止对象的重复创建，节省资源。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8982fddc999074a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="obtain方法源码"></p>
<p>“铃铃铃…”小Message接到了一个陌生男子的电话。<br>“我叫handler，来自activity大本营，是你这次任务的接受者，一会我带你去首都的消息中心去报道。”</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>来自Activity大本营Handler部门是整个消息机制系统的核心部门，当然部门下有<strong>很多个</strong> Handler，这次协助小Message任务的叫mHandler。Handler部门下的员工都有一个特点，就是只关心自己的message。</p>
<p>Handler属于Activity，创建任何一个Handler都属于重写了Activity中的Handler。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-39a9617e0ae54894?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity中定义了Handler"></p>
<p>在Handler的构造中，默认完成了对当前线程Looper的绑定，至于Looper是谁，一会再谈。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-52c8a9bd457f43b5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler的构造方法"></p>
<p>通过Looper.myLooper()获取了当前线程保存的Looper实例，又通过mLooper.mQueue获取了Looper中的MessageQueue实例。在此时，mhandler实例与looper和messageQueue实例，关联上了。</p>
<p>mHandler神情骄傲得对小Message说：我已经跟首都的消息中心打好了招呼，准备接收你了，现在有两种车，一种车名叫“<strong>send</strong>”，一种叫“<strong>post</strong>”，你想坐哪辆去首都都可以，不过要根据你上司的命令，选择车种类下对应的型号哦~</p>
<ul>
<li><p><strong>send</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-304ec3faab1a3176?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
<li><p><strong>post</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-0b9ad4781e0b1861?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>
</li>
</ul>
<p>从代码的实现上来看，post方法也是在使用send类的方法在发送消息，只是他们的参数要求是Runnable对象。</p>
<p>通过对Handler源码的分析，发现除了sendMessageAtFrontOfQueue方法之外，其余任何send的相关方法，都经过层层包装走到了sendMessageAtTime方法中，我们来看看源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-fd684532b5c792e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime源码"></p>
<p>这时小Message和mHandler一同上了车牌号为“sendMessage”的车，行驶在一条叫“enqueueMessage”的高速公路上，mHandler向一无所知的小Message介绍说，每个像他一样的Message都是通过<strong>enqueueMessage</strong>路进入MessageQueue的。我们是要去首都的MessageQueue中心，其实你的消息到时候也是我处理的，不过现在还不是时候哦，因为我很忙。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-12ec385d2ec1164f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enqueueMessage源码"></p>
<p>enqueueMessage是MessageQueue的方法，用来将Message根据时间排序，放入到MessageQueue中。其中msg.target = this，<strong>是保证每个发送Message的Handler也能处理这个Message。</strong></p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>路上的时间不短不长，mHandler依然为小Message热心介绍着MessageQueue和Looper<br>“在每个驻扎地（线程）中，只有一个MessageQueue和一个Looper，他们两个是相杀相爱，同生共死的好基友，Looper是个跑不死的邮差，一直负责取出MessageQueue中的Message”<br>“不过通常只有首都（主线程）的Looper和MessageQueue是创建好的，其他地方需要我们人为地创建哦~”</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bed816d7d28d1c87?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="prepare方法"></p>
<p>Looper类提供了prepare方法来创建Looper。可以看到，当重复创建Looper时，会抛出异常，也就是说，每个线程只有一个Looper。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-9fe5b7b2e249c771?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Looper构造"></p>
<p>紧接着在Looper的构造方法中，又创建了与它一一对应的MessageQueue，既然Looper在一个线程中是唯一的，所以MessageQueue也是唯一的。</p>
<p>在Android中，ActivityThread的main方法是程序的入口，主线程的Looper和MessageQueue就是在此时创建的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-2a78bc7e32ab5990?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ActivityThread的main方法"></p>
<p>可以看到，在main方法中，既创建了Looper，也调用了<strong>Looper.loop()</strong>方法。</p>
<p>mHandler和小Message通过enqueueMessage路来到了MessageQueue中，进入之前，门卫仔仔细细地给小Message贴上了以下标签：<br>“mHandler负责带入”<br>“处理时间为0ms”<br>并且告诉小Message，一定要按照时间顺序排队。<br>进入队伍中，Looper大哥正在不辞辛劳的将一个又一个跟小Message一样的士兵带走。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-663c57da42f084c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="loop方法"></p>
<p>分析一下loop方法，有一个for的死循环，不断地调用queue.next方法，在消息队列中取Message。并且在Message中取出target，这个target其实就是发送消息的handler，调用它的dispatchMessage方法。</p>
<p>首都的MessageQueue中心虽然人很多，但是大家都井井有条的排着队伍，Looper老哥看了一眼手里的名单，叫到了小Message的名字，看了一眼小Message身上的标签，对他说：“喔，又是mHandler带来的人啊，那把你交给他处理了”</p>
<p>忐忑不安的小Message看到了一个熟悉的身影，mHandler就在面前，显然mHandler有些健忘，可能是接触了太多跟小Message一样的人，为了让mHandler想起自己，小Message说出了上司交给他的暗号0.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b6daebfefccb8e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatchMessage方法"></p>
<p>可以看见dispatchMessage方法中的逻辑比较简单，具体就是如果mCallback不为空，则调用mCallback的handleMessage()方法，否则直接调用Handler的handleMessage()方法，并将消息对象作为参数传递过去。</p>
<p>在handlerMessage()方法中，小Message出色的完成了自己的任务。</p>
<p><strong>写在后面：</strong></p>
<p>下一篇中，我们会探讨一下为什么loop方法中for死循环不会造成ANR，有一些有关Handler的使用技巧，以及可能造成的内存泄漏，敬请期待。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;带着这篇去通关所有Handler的提问（三）&quot;&gt;&lt;a href=&quot;#带着这篇去通关所有Handler的提问（三）&quot; class=&quot;headerlink&quot; title=&quot;带着这篇去通关所有Handler的提问（三）&quot;&gt;&lt;/a&gt;带着这篇去通关所有Handler的提问（三）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-5b46d5a0584720ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;大家久等了，Melo前阵花了一周的时间去毕业旅行，所以更新就拖延了一阵，话不多说，我们来回顾一下本系列的前两篇文章的&lt;strong&gt;思路&lt;/strong&gt;和&lt;strong&gt;知识点&lt;/strong&gt;：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>5分钟实现Android中更换头像功能</title>
    <link href="http://yoursite.com/2016/07/28/5%E5%88%86%E9%92%9F%E5%AE%9E%E7%8E%B0Android%E4%B8%AD%E6%9B%B4%E6%8D%A2%E5%A4%B4%E5%83%8F%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/28/5分钟实现Android中更换头像功能/</id>
    <published>2016-07-28T02:16:11.761Z</published>
    <updated>2016-07-28T02:17:14.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5分钟实现Android中更换头像功能"><a href="#5分钟实现Android中更换头像功能" class="headerlink" title="5分钟实现Android中更换头像功能"></a>5分钟实现Android中更换头像功能</h1><p><strong>写在前面：</strong><br>更换头像这个功能在用户界面几乎是<strong>100%</strong>出现的。通过<strong>拍摄照片</strong>或者<strong>调用图库中的图片</strong>，并且进行剪裁，来进行头像的设置。<br>功能相关<strong>截图</strong>如下：<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/1915184-1326e6af0cd65974?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户界面，头像未设置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-5d3ecb18b3ee4220?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击头像，弹出Dialog"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-22349a556aec7417?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择照片，进行剪裁"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-bb2445cf910509af?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头像设置成功"></p>
<p>下面我们直接看看<strong>完整代码</strong>吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class UserActivity extends BaseActivity implements OnClickListener &#123;</div><div class="line"></div><div class="line">	private ImageView iv_photo;</div><div class="line">	private Bitmap head;// 头像Bitmap</div><div class="line">	private static String path = &quot;/sdcard/myHead/&quot;;// sd路径</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		initView();</div><div class="line">		initListener();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void initView() &#123;</div><div class="line">		setContentView(R.layout.activity_user);</div><div class="line">		iv_photo = (ImageView) findViewById(R.id.iv_photo);</div><div class="line">		Bitmap bt = BitmapFactory.decodeFile(path + &quot;head.jpg&quot;);// 从SD卡中找头像，转换成Bitmap</div><div class="line">		if (bt != null) &#123;</div><div class="line">			@SuppressWarnings(&quot;deprecation&quot;)</div><div class="line">			Drawable drawable = new BitmapDrawable(bt);// 转换成drawable</div><div class="line">			iv_photo.setImageDrawable(drawable);</div><div class="line">		&#125; else &#123;</div><div class="line">			/**</div><div class="line">			 * 如果SD里面没有则需要从服务器取头像，取回来的头像再保存在SD中</div><div class="line">			 * </div><div class="line">			 */</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void initListener() &#123;</div><div class="line">		iv_photo.setOnClickListener(this);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@Override</div><div class="line">	public void onClick(View v) &#123;</div><div class="line">		switch (v.getId()) &#123;</div><div class="line">		case R.id.iv_photo:// 更换头像</div><div class="line">			showTypeDialog();</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void showTypeDialog() &#123;</div><div class="line">		AlertDialog.Builder builder = new AlertDialog.Builder(this);</div><div class="line">		final AlertDialog dialog = builder.create();</div><div class="line">		View view = View.inflate(this, R.layout.dialog_select_photo, null);</div><div class="line">		TextView tv_select_gallery = (TextView) view.findViewById(R.id.tv_select_gallery);</div><div class="line">		TextView tv_select_camera = (TextView) view.findViewById(R.id.tv_select_camera);</div><div class="line">		tv_select_gallery.setOnClickListener(new OnClickListener() &#123;// 在相册中选取</div><div class="line">			@Override</div><div class="line">			public void onClick(View v) &#123;</div><div class="line">				Intent intent1 = new Intent(Intent.ACTION_PICK, null);</div><div class="line">				intent1.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;);</div><div class="line">				startActivityForResult(intent1, 1);</div><div class="line">				dialog.dismiss();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		tv_select_camera.setOnClickListener(new OnClickListener() &#123;// 调用照相机</div><div class="line">			@Override</div><div class="line">			public void onClick(View v) &#123;</div><div class="line">				Intent intent2 = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">				intent2.putExtra(MediaStore.EXTRA_OUTPUT,</div><div class="line">						Uri.fromFile(new File(Environment.getExternalStorageDirectory(), &quot;head.jpg&quot;)));</div><div class="line">				startActivityForResult(intent2, 2);// 采用ForResult打开</div><div class="line">				dialog.dismiss();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		dialog.setView(view);</div><div class="line">		dialog.show();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</div><div class="line">		switch (requestCode) &#123;</div><div class="line">		case 1:</div><div class="line">			if (resultCode == RESULT_OK) &#123;</div><div class="line">				cropPhoto(data.getData());// 裁剪图片</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			break;</div><div class="line">		case 2:</div><div class="line">			if (resultCode == RESULT_OK) &#123;</div><div class="line">				File temp = new File(Environment.getExternalStorageDirectory() + &quot;/head.jpg&quot;);</div><div class="line">				cropPhoto(Uri.fromFile(temp));// 裁剪图片</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			break;</div><div class="line">		case 3:</div><div class="line">			if (data != null) &#123;</div><div class="line">				Bundle extras = data.getExtras();</div><div class="line">				head = extras.getParcelable(&quot;data&quot;);</div><div class="line">				if (head != null) &#123;</div><div class="line">					/**</div><div class="line">					 * 上传服务器代码</div><div class="line">					 */</div><div class="line">					setPicToView(head);// 保存在SD卡中</div><div class="line">					iv_photo.setImageBitmap(head);// 用ImageView显示出来</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			break;</div><div class="line">		default:</div><div class="line">			break;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">		super.onActivityResult(requestCode, resultCode, data);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 调用系统的裁剪功能</div><div class="line">	 * </div><div class="line">	 * @param uri</div><div class="line">	 */</div><div class="line">	public void cropPhoto(Uri uri) &#123;</div><div class="line">		Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</div><div class="line">		intent.setDataAndType(uri, &quot;image/*&quot;);</div><div class="line">		intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</div><div class="line">		// aspectX aspectY 是宽高的比例</div><div class="line">		intent.putExtra(&quot;aspectX&quot;, 1);</div><div class="line">		intent.putExtra(&quot;aspectY&quot;, 1);</div><div class="line">		// outputX outputY 是裁剪图片宽高</div><div class="line">		intent.putExtra(&quot;outputX&quot;, 150);</div><div class="line">		intent.putExtra(&quot;outputY&quot;, 150);</div><div class="line">		intent.putExtra(&quot;return-data&quot;, true);</div><div class="line">		startActivityForResult(intent, 3);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void setPicToView(Bitmap mBitmap) &#123;</div><div class="line">		String sdStatus = Environment.getExternalStorageState();</div><div class="line">		if (!sdStatus.equals(Environment.MEDIA_MOUNTED)) &#123; // 检测sd是否可用</div><div class="line">			return;</div><div class="line">		&#125;</div><div class="line">		FileOutputStream b = null;</div><div class="line">		File file = new File(path);</div><div class="line">		file.mkdirs();// 创建文件夹</div><div class="line">		String fileName = path + &quot;head.jpg&quot;;// 图片名字</div><div class="line">		try &#123;</div><div class="line">			b = new FileOutputStream(fileName);</div><div class="line">			mBitmap.compress(Bitmap.CompressFormat.JPEG, 100, b);// 把数据写入文件</div><div class="line">		&#125; catch (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; finally &#123;</div><div class="line">			try &#123;</div><div class="line">				// 关闭流</div><div class="line">				b.flush();</div><div class="line">				b.close();</div><div class="line">			&#125; catch (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再添加以下权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;</div><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure>
<p>Dialog的xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; &gt;</div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_select_gallery&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:gravity=&quot;center_horizontal&quot;</div><div class="line">        android:padding=&quot;20dp&quot;</div><div class="line">        android:text=&quot;从图库中选取&quot;</div><div class="line">        android:textColor=&quot;#000&quot;</div><div class="line">        android:textSize=&quot;20sp&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;View</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;1dp&quot;</div><div class="line">        android:layout_marginLeft=&quot;10dp&quot;</div><div class="line">        android:layout_marginRight=&quot;10dp&quot;</div><div class="line">        android:background=&quot;#000&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:id=&quot;@+id/tv_select_camera&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;wrap_content&quot;</div><div class="line">        android:gravity=&quot;center_horizontal&quot;</div><div class="line">        android:padding=&quot;20dp&quot;</div><div class="line">        android:text=&quot;拍摄照片&quot;</div><div class="line">        android:textColor=&quot;#000&quot;</div><div class="line">        android:textSize=&quot;20sp&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure>
<p>代码的注释还算全面，仔细阅读一定能看懂，大家可以试试这个demo~这样一个更换头像的功能就实现了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5分钟实现Android中更换头像功能&quot;&gt;&lt;a href=&quot;#5分钟实现Android中更换头像功能&quot; class=&quot;headerlink&quot; title=&quot;5分钟实现Android中更换头像功能&quot;&gt;&lt;/a&gt;5分钟实现Android中更换头像功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;更换头像这个功能在用户界面几乎是&lt;strong&gt;100%&lt;/strong&gt;出现的。通过&lt;strong&gt;拍摄照片&lt;/strong&gt;或者&lt;strong&gt;调用图库中的图片&lt;/strong&gt;，并且进行剪裁，来进行头像的设置。&lt;br&gt;功能相关&lt;strong&gt;截图&lt;/strong&gt;如下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制字典型探究（二）</title>
    <link href="http://yoursite.com/2016/07/28/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AD%97%E5%85%B8%E5%9E%8B%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Android消息机制字典型探究（二）/</id>
    <published>2016-07-28T02:14:33.902Z</published>
    <updated>2016-07-28T02:15:31.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android消息机制字典型探究（二）"><a href="#Android消息机制字典型探究（二）" class="headerlink" title="Android消息机制字典型探究（二）"></a>Android消息机制字典型探究（二）</h1><p><img src="http://upload-images.jianshu.io/upload_images/1915184-8d34278385fceccd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br><a href="http://www.jianshu.com/p/8c06b1d7ca68" target="_blank" rel="external">Android消息机制字典型探究（一）</a><br>为了完成整个<strong>Android消息机制的探究</strong>，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中<strong>不允许子线程更新UI</strong>的原因，是由于<strong>线程安全</strong>的问题。<br>当然我们<strong>目前</strong>分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：<strong>实践去发现问题，全面的理解问题，寻找最优解</strong>。Android本身就是一个复杂而有机的整体，<strong>由一个知识点可以牵出一条知识线。从而构成相关的知识体系</strong>。<br><a id="more"></a><br><strong>这种学习方式会让你知道的越来越多，也能站在一定的高度上体会Android在设计之时的巧妙，全局的理解Android，做到融会贯通。也能在你的代码中，收获很多有益的启发。</strong></p>
<p>说完以上这些，就可以正式开始本文的话题了。既然在我们只可以在主线程更新UI，那解决这个问题，一共有几种方式呢？我就来直接告诉大家，解决子线程更新UI问题的方式，<strong>一共有三种。</strong></p>
<ol>
<li><p><strong>runOnUiThread</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-ee3a4f5a9a294b01?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runOnUiThread的使用"></p>
<p>简单讲解一下代码，点击crash按钮，开启一个子线程，显然我们在子线程中直接给 <strong>iv_handler</strong><br>设置一张图片，是肯定崩溃的。当我们调用<strong>runOnUiThread</strong>方法，并且传入一个<strong>Runnable</strong>对象，并且在其中设置<strong>更新UI</strong>的逻辑，问题就解决了。相信你也和我一样对此非常好奇，那就赶紧点进去看看，源码中是如何实现的吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-215bb46aaa0df885?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runOnUiThread实现原理"></p>
<p>先来翻译一下这段注释：</p>
<blockquote>
<p>在UI线程中执行该Runnable.  <em> 如果当前线程是UI线程,那么该Runnable会立即执行.  </em> 如果当前的线程不是UI线程则调用UI线程handler的post()方法将其放入UI线程的消息队列中.  *<br>注意:勿在runOnUiThread(Runnable runnable)中做耗时操作</p>
</blockquote>
<p>首先我想说明的是，runOnUiThread方法是属于<strong>Activity</strong>的，也就是说我们能拿到Activity才能使用该方法。我们本文的这个例子，明显是执行了<strong>mHandler.post(action)</strong>方法。我们目前不去研究<strong>handler.post</strong>方法，因为一会你就知道为什么了。再来看看第二种解决问题的办法。</p>
</li>
<li><p><strong>view.post</strong> <img src="http://upload-images.jianshu.io/upload_images/1915184-80f462b718e89b2a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view.post方法使用"></p>
<p>代码跟上一个解决办法如出一辙，我们还是来看看源码，分析一下这个方法的实现方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-40b751ac6dcb8c73?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="view.post源码"></p>
<p>先来翻译一下注释的意思：</p>
<blockquote>
<p>将Runnable对象添加到message queue中，并且这个runnable对象会跑在UI线程中。</p>
</blockquote>
<p>翻译完注释再来看代码，当View和Activity完成attach操作时，会产生一个<strong>attachInfo</strong>参数，在attachInfo参数中取出来了属于activity的mHandler，仍然去调用了mHandler.post(action)方法。也就是说无论我们是选择第一种方法还是第二种方法去解决这个崩溃问题，都是<strong>殊途同归</strong>的，最后经过层层封装，都走到了<strong>handler.post</strong>方法中。</p>
</li>
</ol>
<p><strong>handler.post</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-f35b59a4217f4ad7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="发送message到主线程"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-e4f720124308ab1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="handler处理信息"></p>
<p>啊哈哈，我们连载通篇的主角<strong>Handler</strong>今天终于正式登场了，没错上面的代码就是将子线程的消息发送到主线程并处理的标准写法。等等，post方法在哪里？别着急，在本篇文章中，我并不打算给大家展开整个Handler知识体系的研究。我们先来看看post方法调用层级</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-2d101a24320abf9c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-2c64da2ca248d98a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageDelayed"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-5dc923d75bd384d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sendMessageAtTime"></p>
<p>可以看到，方法的调用顺序为post–sendMessageDelayed–sendMessageAtTime.</p>
<p>在本文中我们不再继续深究下去，未来我会对这些方法的调用层级、顺序、以及使用场景为大家进行一下完整地整理总结，本文不再赘述。</p>
<p><strong>想强调的是：</strong><br>其实在这篇博客的目的：<br>1.从解决问题并寻找方法的角度引出Handler，真正开启Handler的知识体系。</p>
<p>2.思考问题，解决问题的过程。回首第一篇文章中，我因为在子线程更新UI而造成了崩溃，然后：</p>
<ul>
<li><p>在寻找解决办法之前，带着强烈的好奇心，去寻找了为何不能在子线程更新UI原因。在这个过程中，我理解了什么<strong>线程安全</strong>，深入理解了<strong>Context</strong>。</p>
</li>
<li><p>去寻找解决问题的所有办法（三种），并且去探究了这几种方法的原理，试图选择在本例中的最优解（事实上这几种方法本质上没区别）。</p>
</li>
<li><p>将问题简单化，所有问题的解决办法都指向了Handler，所以我们只需要探究Handler即可。</p>
</li>
</ul>
<p><strong>写在最后：</strong></p>
<p>很多初学者认为Handler就是为了解决子线程更新UI的问题而存在的，事实上这种理解是<strong>错误</strong>的。Handler作为Android的线程间通信的机制，意义远不止此。下一篇中，Melo将带大家真正的理解Android的消息机制。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android消息机制字典型探究（二）&quot;&gt;&lt;a href=&quot;#Android消息机制字典型探究（二）&quot; class=&quot;headerlink&quot; title=&quot;Android消息机制字典型探究（二）&quot;&gt;&lt;/a&gt;Android消息机制字典型探究（二）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-8d34278385fceccd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/8c06b1d7ca68&quot;&gt;Android消息机制字典型探究（一）&lt;/a&gt;&lt;br&gt;为了完成整个&lt;strong&gt;Android消息机制的探究&lt;/strong&gt;，我准备将知识点细分成一个个模块。在连载的第一篇文章中，在子线程更新UI导致崩溃，我们去分析探究了Android中&lt;strong&gt;不允许子线程更新UI&lt;/strong&gt;的原因，是由于&lt;strong&gt;线程安全&lt;/strong&gt;的问题。&lt;br&gt;当然我们&lt;strong&gt;目前&lt;/strong&gt;分析的东西和写出文字都与Android消息机制无关。不过我其实是想给大家展示学习编程，或者说学习Android的一些好的习惯和解决问题的思路，总结起来就是：&lt;strong&gt;实践去发现问题，全面的理解问题，寻找最优解&lt;/strong&gt;。Android本身就是一个复杂而有机的整体，&lt;strong&gt;由一个知识点可以牵出一条知识线。从而构成相关的知识体系&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
  </entry>
  
  <entry>
    <title>Android消息机制字典型探究（一）</title>
    <link href="http://yoursite.com/2016/07/28/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%AD%97%E5%85%B8%E5%9E%8B%E6%8E%A2%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/07/28/Android消息机制字典型探究（一）/</id>
    <published>2016-07-28T02:12:46.236Z</published>
    <updated>2016-07-28T02:13:51.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android消息机制字典型探究（一）"><a href="#Android消息机制字典型探究（一）" class="headerlink" title="Android消息机制字典型探究（一）"></a>Android消息机制字典型探究（一）</h1><h2 id="子线程为啥不能更新UI？"><a href="#子线程为啥不能更新UI？" class="headerlink" title="子线程为啥不能更新UI？"></a>子线程为啥不能更新UI？</h2><p><img src="http://upload-images.jianshu.io/upload_images/1915184-96038570640d0e76?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开心一刻"><br><strong>写在前面：</strong><br>看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了<strong>Handler</strong>这个单词，关于这个知识点，几乎是<strong>面试必问的问题，重要程度不言而喻</strong>。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚<strong>Android的消息机制</strong>。<br><a id="more"></a><br>既然没有了篇幅限制，自然可以全面的去讲一讲有关Handler的一切，我先来说说当时是怎么接触到<strong>Handler</strong>这个类的。</p>
<p>在我自学Android过程中，写了一个<strong>访问网络请求图片并显示</strong>的Demo，在子线程中我直接给<strong>ImageView</strong>设置了图片，造成了崩溃。崩溃信息如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-b562b658369b0d8c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="崩溃信息"></p>
<blockquote>
<p>Only the original thread that created a view hierarchy can touch its views.</p>
</blockquote>
<p>这个错误信息在字面上翻译过来就是：<strong>只有创建视图层级的原始线程，有权利处理它的视图</strong>。说白了，就是我们经常说的“子线程不能更新UI”。这句话体现了主线程在处理视图上具有唯一权力，<strong>这也就是为什么主线程也可以称为UI线程</strong>。</p>
<p>在解决这个崩溃问题之前，我对<strong>Android中子线程不能更新UI</strong>产生了非常大的好奇心。</p>
<p><strong>Google</strong>如此设计的原因是什么呢？</p>
<ol>
<li>表象<br>我们先从表象上分析一下，假设可以在子线程更新UI，会产生那些后果呢？<br>如果不同的线程控制同一块UI，因为时间的延时性，网络的延迟性，很有可能界面图像会乱套，会花掉。而且出了问题也非常不容易排查问题出在了哪里。从硬件上考虑，每个手机只有一个显示芯片，根本上不可能同时处理多个绘制请求)，减少更新线程数，其实是提高了更新效率。</li>
<li>本质<br>如果可以并发的更新UI，事实上是 “is not thread safe”的，也就是线程不安全。我们都知道，线程安全问题其实就是，不同的线程对同一块资源的调用。在更新UI的同时，会涉及context资源的调用，所以产生了线程安全问题。</li>
</ol>
<p><strong>相关阅读：</strong></p>
<p><a href="http://www.jianshu.com/p/46c35c5079b4" target="_blank" rel="external">你足够了解Context吗？</a></p>
<p>所以在Android中是不允许在子线程更新UI的、</p>
<p>本文开了一个小头，在下一篇中，将讨论如何解决本文中的崩溃问题。<strong>卖个关子，一共有三种方式哦，敬请期待~</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android消息机制字典型探究（一）&quot;&gt;&lt;a href=&quot;#Android消息机制字典型探究（一）&quot; class=&quot;headerlink&quot; title=&quot;Android消息机制字典型探究（一）&quot;&gt;&lt;/a&gt;Android消息机制字典型探究（一）&lt;/h1&gt;&lt;h2 id=&quot;子线程为啥不能更新UI？&quot;&gt;&lt;a href=&quot;#子线程为啥不能更新UI？&quot; class=&quot;headerlink&quot; title=&quot;子线程为啥不能更新UI？&quot;&gt;&lt;/a&gt;子线程为啥不能更新UI？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1915184-96038570640d0e76?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开心一刻&quot;&gt;&lt;br&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;看到Android消息机制这几个字眼，相信大家脑海中第一时间就浮现出了&lt;strong&gt;Handler&lt;/strong&gt;这个单词，关于这个知识点，几乎是&lt;strong&gt;面试必问的问题，重要程度不言而喻&lt;/strong&gt;。我曾花了大致一周多的时间去研究它，本打算将其有关的所有知识点完完全全地写出，但发现篇幅会过于冗长而影响阅读。所以准备拆分成几个知识点模块，循序善诱，一步步带领大家弄清楚&lt;strong&gt;Android的消息机制&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="handler" scheme="http://yoursite.com/tags/handler/"/>
    
      <category term="思路" scheme="http://yoursite.com/tags/%E6%80%9D%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Android中Fragment数据保存和恢复</title>
    <link href="http://yoursite.com/2016/07/27/Android%E4%B8%ADFragment%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2016/07/27/Android中Fragment数据保存和恢复/</id>
    <published>2016-07-27T14:13:44.702Z</published>
    <updated>2016-07-27T14:14:48.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中Fragment数据保存和恢复"><a href="#Android中Fragment数据保存和恢复" class="headerlink" title="Android中Fragment数据保存和恢复"></a>Android中Fragment数据保存和恢复</h1><p><strong>写在前面：</strong><br>上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：<br><a href="http://www.jianshu.com/p/6622434511f7" target="_blank" rel="external">Android中Activity数据的保存和恢复</a><br><a id="more"></a><br><strong>一句话总结：</strong></p>
<ul>
<li><p>临时数据<br>对于<strong>临时数据</strong>，我们使用<strong>onSaveInstanceState</strong>方法进行保存，并且在<strong>onCreate</strong>方法中恢复。</p>
</li>
<li><p>永久数据<br>对于<strong>持久性数据</strong>，我们要在onPause方法中进行存储，但是要注意，onPause方法中不能进行大量操作，会影响其他Activity进入任务栈栈顶。</p>
</li>
</ul>
<p>ps：在Activity中弹出一个当前Activity的<strong>Dialog</strong>并不会有任何生命周期方法调用（以前我曾以为会调用onPause方法）。因为Dialog作为一个View本身就是属于当前Activity的，Activity并没有<strong>失去焦点</strong>。</p>
<p>ok，完成了回顾，下面来开始本篇博客：</p>
<p><strong>Fragment</strong>在我们的项目中真的太实用和常见了，它的使用频率和数量甚至超过了Activity，所以本文目的是探究Fragment的数据保存和恢复。</p>
<p>在开始讲解之前，你应该对Fragment的<strong>生命周期方法</strong>有一定了解，推荐给大家一篇博客，我认为不错：</p>
<p><a href="http://blog.csdn.net/wanghao200906/article/details/45561385" target="_blank" rel="external">Fragment生命周期方法详解</a></p>
<p>准备工作做了这么多，下面我们正式开始吧！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-84f1eaec23de028d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试App截图"></p>
<p>本文直接选用了《第一行代码》中Fragment模块的讲解例子，点击下面的按钮<strong>分别跳转</strong>这四个Fragment。为了方便观察，我重写了Fragment所有<strong>生命周期方法</strong>和<strong>onSaveInstanceState</strong>方法，并打印了Log。</p>
<p>我们目的是探究Fragment数据的保存和恢复，在这里我把它分为两大类的情况：</p>
<ol>
<li><p>单个Fragment遭遇一些突发情况</p>
</li>
<li><p>Fragment之间相互的切换或覆盖</p>
</li>
</ol>
<p>在此之前，先引入一个<strong>返回栈</strong>的概念。<br>我想你应该知道返回栈是什么，并且你以前接触的应该是保存Activity的返回栈，类比Activity，Fragment返回栈其实是保存Fragment的栈结构。区别在于：<strong>Fragment的返回栈由Activity管理；而Activity的返回栈由系统管理。</strong></p>
<p>在未修改之前，本文添加并切换Fragment的方式都是在返回栈中<strong>仅有一个</strong> fragment：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-183cacefa4387d8e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加切换fragment"></p>
<p>不要心急，过一会再说怎么去在返回栈中压入多个fragment，我们先来处理<strong>只有一个</strong>的情况</p>
<ol>
<li><p>单个Fragment遭遇突发情况</p>
<p>仍然是用以下<strong>突发情况</strong>进行测试：</p>
<ul>
<li><p>点击back键</p>
</li>
<li><p>点击锁屏键</p>
</li>
<li><p>点击home键</p>
</li>
<li><p>其他APP进入前台</p>
</li>
<li><p>启动了另一个Activity</p>
</li>
<li><p>屏幕方向旋转</p>
</li>
<li><p>APP被Kill</p>
</li>
</ul>
<p>不过与上篇博客不同的是，我们在清单文件中，给Activity做了如下配置：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-99af7b0a6ca0f2e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置configChange"></p>
<p>这么做的目的是当屏幕方向发生改变的时候，fragment所依附的Activity并不会重新销毁再创建，让<strong>情况相对简单一点</strong>。</p>
<p><strong>测试结果：</strong></p>
<p>当一个fragment孤零零地呆在返回栈时，它所处的情况与Activity如出一辙。类比Activity对数据的保存和恢复，我们可以对此得出结论：</p>
<ul>
<li><p>临时数据 对于<strong>临时数据</strong>，我们使用<strong>onSaveInstanceState</strong>方法进行保存，并且在<strong>onCreateView</strong>方法中恢复（请注意是onCreateView）。</p>
</li>
<li><p>永久数据 对于<strong>持久性数据</strong>，我们要在onPause方法中进行存储。</p>
</li>
</ul>
</li>
<li>Fragment之间的相互切换或覆盖<br>当返回栈中保证<strong>只有一个Fragment</strong>，相互切换时，生命周期方法的调用是怎样的呢？例如本例中，从fragment03切换到fragment04：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-6d89724ceff62e0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fragment03切换fragment04"><br>　　可以看到，上述的这种情况，两个fragment从创建到销毁，经历了所有的生命周期方法。<br>　　如果返回栈中fragment的数量为多个呢？首先在切换时，加上以下代码，保证将fragment放入返回栈中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d8961dd8db6cf972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="addToBackStack"><br>　　使用addToBackStack方法，就能将fragment放入相应的返回栈中去了，从表象上来看区别在于进入其他fragment时，点击back键时，可以返回上一个fragment。这时候切换时，生命周期方法就是如何调用的呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-d0fdbf4ea4c1e944.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="返回栈有多个fragment切换"></p>
<p>　　对比这两张生命周期方法的图，能得出两个结论。<br>　　1.无论任务栈中fragment数量为多少，onSaveInstanceState方法都没有调用<br>　　2.当fragment任务栈中有多个fragment时，进入下一个fragment时，并不会销毁<strong>fragment实例</strong>，而是仅仅<strong>销毁视图</strong>，最终调用的方法为onDestoryView。<br>　　所以此时我们要去保存临时数据，并不能仅保存在onSaveInstanceState中（因为它可能不会调用），还应该在onDestoryView方法中进行保存临时数据的操作，源码如下：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-dbd03c5a2f1419ea?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码截图"></p>
<p>因为没有了系统提供的bundle参数，我们选择把数据保存在Arguments中，代码就不带着大家一步一步的看了，因为逻辑并不复杂，挺好理解的。通过这种方式，我们就挺容易的将<strong>临时数据和fragment的一些状态</strong>保存进bundle中并在需要时恢复了。</p>
<p>不知不觉本篇文章就要结束了，感兴趣的可以尝试当调用<strong>ft.add()</strong>方式去添加fragment时，生命周期方法又是怎样调用的呢？</p>
<p><strong>结束之前我们来一句话总结下本文：</strong><br>Fragment对<strong>临时数据</strong>的保存，仅仅依靠<strong>onSaveInstanceState</strong>方法是不行的，还需要在<strong>onDestoryView</strong>中进行相应操作，具体参考上面的代码。</p>
<p>Fragment中对于一些持久性的数据，仍应在<strong>onPause</strong>中保存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中Fragment数据保存和恢复&quot;&gt;&lt;a href=&quot;#Android中Fragment数据保存和恢复&quot; class=&quot;headerlink&quot; title=&quot;Android中Fragment数据保存和恢复&quot;&gt;&lt;/a&gt;Android中Fragment数据保存和恢复&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;上周我们总结了Activity中数据的保存和恢复，我们花两分钟来回顾一下：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/6622434511f7&quot;&gt;Android中Activity数据的保存和恢复&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>5分钟打造Android一键退出功能</title>
    <link href="http://yoursite.com/2016/07/27/5%E5%88%86%E9%92%9F%E6%89%93%E9%80%A0Android%E4%B8%80%E9%94%AE%E9%80%80%E5%87%BA%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/07/27/5分钟打造Android一键退出功能/</id>
    <published>2016-07-27T14:11:36.057Z</published>
    <updated>2016-07-27T14:12:25.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5分钟打造Android一键退出功能"><a href="#5分钟打造Android一键退出功能" class="headerlink" title="5分钟打造Android一键退出功能"></a>5分钟打造Android一键退出功能</h1><p><strong>写在前面：</strong><br>当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个<strong>一键退出功能</strong>。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个<strong>BaseActivity</strong>管理所有启动的<strong>Activity</strong>。<br><a id="more"></a><br><strong>下面给出完整的BaseActivity代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">import java.util.LinkedList;</div><div class="line">import java.util.List;</div><div class="line">import android.app.Activity;</div><div class="line">import android.os.Bundle;</div><div class="line"></div><div class="line">public abstract class BaseActivity extends Activity &#123;</div><div class="line">	// 管理运行的所有的activity</div><div class="line">	public final static List&lt;BaseActivity&gt; mActivities = new LinkedList&lt;BaseActivity&gt;();</div><div class="line">	public static BaseActivity activity;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			mActivities.add(this);</div><div class="line">		&#125;</div><div class="line">		init();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	private void init() &#123;</div><div class="line">		initViews();</div><div class="line">		initData();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 初始化Views</div><div class="line">	 */</div><div class="line">	public abstract void initViews();</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 初始化数据</div><div class="line">	 */</div><div class="line">	public void initData() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onResume() &#123;</div><div class="line">		super.onResume();</div><div class="line">		activity = this;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onPause() &#123;</div><div class="line">		super.onPause();</div><div class="line">		activity = null;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void onDestroy() &#123;</div><div class="line">		super.onDestroy();</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			mActivities.remove(this);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 一键退出的方法</div><div class="line">	 */</div><div class="line">	public void killAll() &#123;</div><div class="line">		// 复制了一份mActivities 集合</div><div class="line">		List&lt;BaseActivity&gt; copy;</div><div class="line">		synchronized (mActivities) &#123;</div><div class="line">			copy = new LinkedList&lt;BaseActivity&gt;(mActivities);</div><div class="line">		&#125;</div><div class="line">		for (BaseActivity activity : copy) &#123;</div><div class="line">			activity.finish();</div><div class="line">		&#125;</div><div class="line">		// 杀死当前的进程</div><div class="line">		android.os.Process.killProcess(android.os.Process.myPid());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码分析：</strong><br>在项目中的所有的Activity，都<strong>继承于BaseActivity</strong>，在onCreate方法中，将这个Activity <strong>add</strong>进<strong>LinkedList</strong>中（这里选择用LinkedList是因为它增删快，适合于这个场景中），在onDestory方法中将这个Activity <strong>remove</strong>掉，这样就保证每一个启动了的Activity都存于集合LinkedList中。</p>
<p>然后我们写一个killAll方法，复制这个集合并且遍历退出，你可以在任何地方调用这个方法，这样我们的一键退出功能就完美实现了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5分钟打造Android一键退出功能&quot;&gt;&lt;a href=&quot;#5分钟打造Android一键退出功能&quot; class=&quot;headerlink&quot; title=&quot;5分钟打造Android一键退出功能&quot;&gt;&lt;/a&gt;5分钟打造Android一键退出功能&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;当我们的App打开很多Activity的时候，用户挨个返回退出显然用户体验是非常不好的，所以我们有时需要提供一个&lt;strong&gt;一键退出功能&lt;/strong&gt;。一键退出功能有很多种实现方法，本文我们选择比较常规的手段，用一个&lt;strong&gt;BaseActivity&lt;/strong&gt;管理所有启动的&lt;strong&gt;Activity&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="退出" scheme="http://yoursite.com/tags/%E9%80%80%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android中突发情况Activity数据的保存和恢复</title>
    <link href="http://yoursite.com/2016/07/27/Android%E4%B8%AD%E7%AA%81%E5%8F%91%E6%83%85%E5%86%B5Activity%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2016/07/27/Android中突发情况Activity数据的保存和恢复/</id>
    <published>2016-07-27T14:10:07.840Z</published>
    <updated>2016-07-27T14:11:04.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android中突发情况Activity数据的保存和恢复"><a href="#Android中突发情况Activity数据的保存和恢复" class="headerlink" title="Android中突发情况Activity数据的保存和恢复"></a>Android中突发情况Activity数据的保存和恢复</h1><p><strong>写在前面：</strong><br>在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。<br><a id="more"></a></p>
<h2 id="突发情况都有哪些？"><a href="#突发情况都有哪些？" class="headerlink" title="突发情况都有哪些？"></a>突发情况都有哪些？</h2><p>因为本文讨论的是当一些突发情况的出现时，对数据的保存和恢复。所以现在总结一下<strong>突发情况</strong>应该都有哪些？</p>
<ul>
<li><p>点击back键</p>
</li>
<li><p>点击锁屏键</p>
</li>
<li><p>点击home键</p>
</li>
<li><p>其他APP进入前台</p>
</li>
<li><p>启动了另一个Activity</p>
</li>
<li><p>屏幕方向旋转</p>
</li>
<li><p>APP被Kill</p>
</li>
</ul>
<p>当这些<strong>突发情况</strong>发生的时候，有哪些关键的方法会被调用呢？</p>
<p>写了一个简单的demo，我用上述的突发情况进行测试，代码中我重写了<strong>所有Activity的生命周期方法</strong>和<strong>onSaveInstanceState方法</strong>，并打印对应的log在控制台，下面是demo图：<br><img src="http://upload-images.jianshu.io/upload_images/1915184-35ac3a175abba667?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="demo图"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-f544616ba3090b78?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="部分代码示例"></p>
<p>这里就不贴出测试的过程了，直接来告诉大家<strong>测试的结果</strong>吧：</p>
<p>当我的APP处在前台，能与用户交互的情况下，出现上述的<strong>突发事件</strong>时，只有点击<strong>back键</strong>，<strong>onSaveInstanceState</strong>方法不会调用。其余的情况下， 该方法一律都会调用，这又是为什么呢？并且<strong>onPause</strong>方法是必然会调用的，这又给我们保存数据提供了怎样的思路呢？</p>
<h2 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState"></a>onSaveInstanceState</h2><p>好吧，相信当你看到本文标题的时候，你就应该想到了这个方法。因为当我们学习Android基础知识时，用onSaveInstanceState方法进行数据恢复是你必然学到过的。所以前面我营造出的一些悬念看似是失败了，不过对于onSaveInstanceState你理应知道更多知识：</p>
<ol>
<li><strong>何时调用：</strong></li>
</ol>
<pre><code>&gt; Android calls onSaveInstanceState() before the activity becomes vulnerable to being destroyed by the system, but does not bother
calling it when the instance is actually being destroyed by a user
action (such as pressing the BACK key)
</code></pre><p>找到了以上一段话，翻译过来就是当某个activity变得“<strong>容易</strong>”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户<strong>主动销毁</strong>的，例如当用户按BACK键的时候。</p>
<pre><code>结合我们以上的例子，其实都在说明一个词，就是**被动**。当Activity并不是由我主动点击back键而丧失焦点时，onSaveInstanceState方法就一定会调用。就例如我上述列举的那些除了点击back键的“**突发情况**”。
</code></pre><ol>
<li><p><strong>何地调用：</strong><br><img src="http://upload-images.jianshu.io/upload_images/1915184-81e0043a524fd228?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="何地调用"></p>
<p>在我写的这个demo中，<strong>onSaveInstanceState</strong>的调用是处于<strong>onPause</strong>和<strong>onStop</strong>之间的，（下面关于Activity的生命周期方法，会讲解一些值得大家注意的），我查阅了一下资料，能保证的是onSaveInstanceState方法会在onStop之前调用，但是是否在onPause之前就不一定了。</p>
</li>
</ol>
<p><strong>结论：</strong> google工程师们对onSaveInstanceState如此设计就是让其完成对一些<strong>临时的、非永久数据</strong>存储并进行恢复。什么样的数据属于临时数据呢？举个例子，比如EditText中输入的内容，CheckBox是否勾选，ScrollView的滑动位置，目前视频的播放位置等等。</p>
<p>当我还没有自学Android时，玩着一些APP就会产生一个疑问，比如我在一个输入框中输入了大量文字没有提交或者保存。此时来了一个电话，如果退回的时候，输入框里面的文字消失了，那我可能会砸了电话，所以这个保存数据的操作，是Android开发者做的吗？</p>
<p>然而是不需要的，因为Android的View本身自己就实现了onSaveInstanceState方法，这些控件自己就具有保存临时数据和恢复临时数据的能力。</p>
<p>例如<strong>TextView</strong>中的部分源码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-8f86d2b28227cc2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TextView中的实现"></p>
<p>其他View控件都有相似的实现原理。值得一提的是，只有当你给这个wiget在xml中指定<strong>id</strong>时，它才具有保存数据并且恢复的能力，并且不同的wiget还不能共用这个id，否则会出现<strong>数据覆盖</strong>的情况。具体的源码有兴趣大家可以自己去看，这里因为篇幅的原因不再贴出，关于onSaveInstanceState我们先说这些，赶紧看看使用姿势。</p>
<h2 id="onSaveInstanceState的使用姿势"><a href="#onSaveInstanceState的使用姿势" class="headerlink" title="onSaveInstanceState的使用姿势"></a>onSaveInstanceState的使用姿势</h2><p>比如我们要保存当前视频的<strong>播放进度</strong>，这个显然控件没有帮我们实现onSaveInstanceState，所以就只能靠自己了，代码如下所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1915184-65b77385f772bee6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="保存临时数据"><br><img src="http://upload-images.jianshu.io/upload_images/1915184-3858067a294ecc4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="恢复临时数据"></p>
<p>当在onCreate取出临时数据时，记得加一个<strong>非空判断</strong>。</p>
<p>看到这里，也许你认为本文该就此结束了，不过在回过头看看，我们刚才一直强调的是<strong>临时数据</strong>，毕竟onSaveInstanceState本身就是为临时数据服务的，但是一些<strong>永久性质</strong>的数据，比如<strong>插入数据库的操作</strong>，我们应该在什么方法中对其进行保存呢？</p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause"></a>onPause</h2><p>在介绍onPause方法之前，还是想聊聊Activity的生命周期方法，相信大家对它应该有了初步的了解，不过在相应的生命周期方法中，我们应该做什么操作呢？推荐给大家一篇文章，我觉得不错。</p>
<p><a href="http://blog.csdn.net/lonelyroamer/article/details/8927940" target="_blank" rel="external">Activity生命周期详解</a></p>
<p>关于onPause，我找到了一下关于它的特性：</p>
<blockquote>
<p>onPause(), onStop(), onDestroy() are “killable after” lifecycle methods. This indicates whether or not the system can kill the process hosting the activity at any time after the method returns, without executing another line of the activity’s code. Because onPause() is the first of the three, once the activity is created, onPause() is the last method that’s guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience.</p>
</blockquote>
<p>翻译过来就是：无论出现怎样的情况，比如程序突然死亡了，能保证的就是onPause方法是一定会调用的，而onStop和onDestory方法并不一定，所以这个特性使得<strong>onPause是持久化相关数据的最后的可靠时机</strong>。当然onPause方法不能做大量的操作，这会影响下一个Activity入栈。</p>
<p>刚才我们的测试结果还说明了一个道理，onSaveInstanceState并不是<strong>百分百</strong>调用的（比如点击了back键），显然一些永久性的数据，我们并不能在此中保存。</p>
<p><strong>关于本文的结论就显而易见了，我们来一句话总结一下：</strong></p>
<p><strong>临时数据使用onSaveInstanceState保存恢复，永久性数据使用onPause方法保存。</strong></p>
<p>下一篇准备给大家总结一下<strong>Fragment</strong>的数据保存和恢复，敬请期待哈~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android中突发情况Activity数据的保存和恢复&quot;&gt;&lt;a href=&quot;#Android中突发情况Activity数据的保存和恢复&quot; class=&quot;headerlink&quot; title=&quot;Android中突发情况Activity数据的保存和恢复&quot;&gt;&lt;/a&gt;Android中突发情况Activity数据的保存和恢复&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;br&gt;在我们的APP使用的过程中，总有可能出现各种手滑、被压在后台、甚至突然被杀死的情况。所以对APP中一些临时数据或关键持久型数据，就需要我们使用正确的方式进行保存或恢复。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
      <category term="数据" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>程序员必备简捷开发辅助工具总结</title>
    <link href="http://yoursite.com/2016/07/27/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%E7%AE%80%E6%8D%B7%E5%BC%80%E5%8F%91%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/27/程序员必备简捷开发辅助工具总结/</id>
    <published>2016-07-27T14:08:45.130Z</published>
    <updated>2016-07-27T14:09:43.507Z</updated>
    
    <content type="html"><![CDATA[<p>程序员必备简捷开发辅助工具总结<br>写在前面：<br>工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！<br><a id="more"></a><br>零：Notepad++<br>Notepad++ 程序员必备的文本编辑器，软件小巧高效，支持27种编程语言，通吃C,C++ ,Java ,C#, XML, HTML, PHP,JS 等，推荐各位下载使用。Notepad++ 可完美地取代微软的记事本。相信这是每个程序员必备的工具，神器不解释！</p>
<p>Notepad++<br>下载地址及使用说明：</p>
<p>Notepad++中文版下载</p>
<p>一：XML Marker(xml查看编辑工具)<br>XML Marker是国外的一款非常实用的xml查看编辑工具。软件功能强大，纯文本调试输出和日志文件，你可以有效增加修改你的程序才能产生XML格式他们的作用。你也可以使用XML标记的图形功能，以现场隐藏的趋势，并更快地解决你的错误。更多的功能包括表格排序，语法高亮编辑器和自动缩进，经常编辑XML文件的用户可以下载本软件使用。</p>
<p>XML Marker<br>下载地址及使用说明：</p>
<p>XML Marker(xml查看编辑工具) 下载</p>
<p>二：Everything<br>Everything是速度最快的文件搜索软件。其速度之快令人震惊，百G硬盘几十万个文件，可以在几秒钟之内完成索引；文件名搜索瞬间呈现结果。它小巧免费，支持中文，支持正则表达式，可以通过HTTP或FTP分享搜索结果。如果不满意Windows自带的搜索工具、Total Commander的搜索、Google 桌面搜索或百度硬盘搜索，如果正在使用或放弃了Locate32，都值得推荐这款体积小巧、免安装、免费、速度极快（比Locate32更快）的文件搜索工具Everything！</p>
<p>Everything<br>下载地址及使用说明：</p>
<p>Everything下载地址</p>
<p>三：MarkMan<br>既有爱又给力的长度标注神器！设计师、重构、前端工程师必备。马克鳗是基于AdobeAIR平台的方便高效的标注工具，可方便地为设计稿添加标记，极大节省设计师在设计稿上添加和修改标注的时间。马克鳗使用起来也是非常简单，双击添加测量，单击改变横纵方向等等功能，基本都是一键完成。</p>
<p>markman<br>下载地址及使用说明：</p>
<p>MarkMan下载地址</p>
<p>四：HiJson<br>使用HiJson工具并通过此工具快速查看JSON字符串、熟悉JSON的数据结构。针对程序员来说，如果了解了连续字符串对应的JSON的数据组成，便可以快速对JSON字符串进行数据处理。</p>
<p>Hijson<br>下载地址及使用说明：</p>
<p>HiJson64位下载地址</p>
<p>五：XMind<br>Xmind是一款全球领先的思维导图软件，除了可以轻松绘制基本逻辑图之外，还支持组织如结构图（竖直）、树状图（水平+竖直）、思维导图（辐射）、鱼骨图、二维图（表格）模型。在企业和教育领域都有很广泛的应用。Xmind Pro可以将您的图形显示给他人，或者将图形内容导出到MicrosoftPowerpoint、Word中，令复杂的思想和信息得到更快的交流。在企业中它可以用来进行会议管理、项目管理、信息管理、计划和时间管理、企业决策分析等，在教育领域，它通常被用于教师备课、课程规划、头脑风暴等。</p>
<p>Xmind<br>下载地址及使用说明：</p>
<p>XMind破解版下载</p>
<p>六：Beyond Compare<br>Beyond Compare是一套由Scooter Software推出的软件，主要用途是对比两个文件夹或者文件，并将差异以颜色标示。在使用git提交代码时，可以比较两个文件的不同之处，处理冲突，非常实用。</p>
<p>Beyond Compare<br>下载地址及使用说明：</p>
<p>Beyond Compare</p>
<p>七：金山词霸<br>这个就不多解释了，类、变量的命名尽量不要使用拼音，遇到拿不准的单词，就使用金山词霸查询一下吧。</p>
<p>写在后面：</p>
<p>如果大家还有什么还用的辅助开发工具，请在下方留言哈，不断地补充分享~</p>
<p>评论朋友们的补充（感谢）</p>
<p>八：Sublime Text<br>程序员必备代码编辑器，几乎每位程序员提到Sublime Text都是赞不绝口!它体积小巧，无需安装，绿色便携;它可跨平台支持Windows/Mac/Linux;支持32与64位操作系统，它在支持语法高亮、代码补全、代码片段(Snippet)、代码折叠、行号显示、自定义皮肤、配色方案等所有其它代码编辑器所拥有的功能的同时，又保证了其飞快的速度!还有着自身独特的功能，比如代码地图、多种界面布局以及全屏免打扰模式等，这些优秀特性让Sublime Text 2成了所有程序员眼中的神!</p>
<p>Sublime Text<br>下载地址及使用说明：</p>
<p>Sublime text下载链接和使用教程</p>
<p>九：Listary<br>Listary 是一款非常优秀的 Windows 文件浏览和搜索增强工具，可以为你 Windows 的「文件浏览对话框」、「资源管理器」等增加非常方便的文件快速定位、实时全盘搜索、常用文件夹收藏、打开历史、快速切换到已打开的路径、快捷右键菜单等一系列非常非常实用和高效的功能。</p>
<p>Listary<br>下载地址及使用说明：</p>
<p>Listary</p>
<p>十：strokeplus<br>strokesplus是一个类似strokeit的鼠标手势软件。无须.net运行环境即可运行，只占用250-500kb内存。strokesplus支持脚本动作，提供了更为强大的可操控性。</p>
<p>下载地址及使用说明：</p>
<p>strokeplus<br>StrokesPlus下载</p>
<p>十一：source insight<br>Source Insight 实质上是一个支持多种开发语言（java,c ,c++等等）的编辑器，只不过由于其查找、定位、彩色显示等功能的强大，而被我们当成源代码阅读工具使用 。所以，为了有效的阅读源程序，首先必须选择功能菜单上的“Project”选项的子菜单“New Project” 新建一个项目，项目名称可以自由选定，当然也可以选择删除（Remove）一个项目。当删除一个项目的时候，并不删除原有的源代码文件,只是将该软件生成的那些工程辅助文件删除。设定之后，将会弹出一个对话框如图2，接受默认选择，如果，硬盘空间足够，可以将第一个复选框选上，该选项将会需要与源代码大致同等的空间来建立一个本地数据库以加快查找的速度。</p>
<p>source insight<br>Source Insight下载地址和使用说明</p>
<p>相关阅读：</p>
<p>Android开发者需要阅读的博客总结</p>
<p>移动开发必备书单</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序员必备简捷开发辅助工具总结&lt;br&gt;写在前面：&lt;br&gt;工欲善其事必先利其器，拥有简捷的开发辅助工具能大大提高我们程序猿的开发效率。Melo刚到学校就给大家总结了一些常用的辅助开发的工具，希望大家能喜欢，闲话不多说，马上开始~！&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
